LightChaser-V3

## Summary

| |Issue|Instances| Gas Savings
|-|:-|:-:|:-:|
| [[L-01](#l-01)] | Subtractions performed on a possibly uninitialized uint  | 1| 0|
| [[D-01](#d-01)] | Gas grief possible on unsafe external calls [EXP] | 1| 0|
| [[D-02](#d-02)] | Potential division by zero should have zero checks in place [EXP] | 4| 0|
| [[D-03](#d-03)] | Unchecked blocks with subtractions may underflow [EXP] | 1| 0|
| [[D-04](#d-04)] | Emits without msg.sender parameter [EXP] | 5| 0|
| [[D-05](#d-05)] | Some if-statement can be converted to a ternary [EXP] | 5| 0|
| [[D-06](#d-06)] | Cyclomatic complexity in functions [EXP] | 2| 0|
| [[D-07](#d-07)] | Code does not follow the best practice of check-effects-interaction [EXP] | 9| 0|
| [[D-08](#d-08)] | Events may be emitted out of order due to code not follow the best practice of check-effects-interaction [EXP] | 3| 0|
| [[D-09](#d-09)] | Ids should begin at zero [EXP] | 1| 0|
| [[D-10](#d-10)] | Some error strings are not descriptive [EXP] | 1| 0|
| [[D-11](#d-11)] | Redundant use of whenNotPaused [EXP] | 4| 3200|
| [[D-12](#d-12)] | Avoid updating storage when the value hasn't changed [EXP] | 6| 8000|
| [[D-13](#d-13)] | Multiple accesses of the same mapping/array key/index should be cached [EXP] | 10| 1092|
| [[D-14](#d-14)] | Require/revert statements regarding parameters should be first in a function [EXP] | 10| 0|
| [[D-15](#d-15)] | The result of a function call should be cached rather than re-calling the function [EXP-0] | 1| 100|
| [[D-16](#d-16)] | State variables used within a function more than once should be cached to save gas [EXP-1] | 4| 500|
| [[D-17](#d-17)] | Functions with array parameters should have length checks in place [EXP-2] | 2| 0|
| [[LOW-01](#low-01)] | Potential division by zero should have zero checks in place  | 1| 0|
| [[LOW-02](#low-02)] | Unsafe use of transfer()/transferFrom() with IERC20  | 11| 0|
| [[LOW-03](#low-03)] | Some tokens may revert when zero value transfers are made  | 8| 0|
| [[LOW-04](#low-04)] | Low Level Calls to Custom Addresses | 1| 0|
| [[LOW-05](#low-05)] | Require should be used instead of assert as assert in some solidity versions does not refund remaining gas | 4| 0|
| [[LOW-06](#low-06)] | Require statements should have error string | 4| 0|
| [[LOW-07](#low-07)] | The call abi.encodeWithSelector is not type safe | 3| 0|
| [[LOW-08](#low-08)] | When using a uint index in a for loop, there should be a length check to prevent index out of range. | 1| 0|
| [[LOW-09](#low-09)] | Contracts are vulnerable to fee-on-transfer accounting-related issues | 5| 0|
| [[LOW-10](#low-10)] | Public or external initialize functions should be protected with the initializer modifier | 1| 0|
| [[LOW-11](#low-11)] | Loss of precision | 5| 0|
| [[LOW-12](#low-12)] | Function calls within for loops | 4| 0|
| [[LOW-13](#low-13)] | For loops in public or external functions should be avoided due to high gas costs and possible DOS | 4| 0|
| [[LOW-14](#low-14)] | No limits when setting min/max amounts | 12| 0|
| [[LOW-15](#low-15)] | Initialize functions do not emit an event | 1| 0|
| [[LOW-16](#low-16)] | The function decimals() is not part of the ERC20 standard | 1| 0|
| [[LOW-17](#low-17)] | Minting to the zero address should be avoided | 5| 0|
| [[LOW-18](#low-18)] | Missing zero address check in constructor | 11| 0|
| [[LOW-19](#low-19)] | Constant decimal values | 34| 0|
| [[LOW-20](#low-20)] | Revert on Transfer to the Zero Address | 20| 0|
| [[LOW-21](#low-21)] | Use of deprecated Chainlink functions | 14| 0|
| [[LOW-22](#low-22)] | Calling internal _grantRole bypasses role access checks | 1| 0|
| [[LOW-23](#low-23)] | Redundant use of ERC20Burnable | 2| 0|
| [[LOW-24](#low-24)] | Direct supportsInterface() calls may cause caller to revert | 1| 0|
| [[LOW-25](#low-25)] | Unbounded loop may run out of gas | 5| 0|
| [[LOW-26](#low-26)] | No limits when setting price values | 1| 0|
| [[LOW-27](#low-27)] | Prefer skip over revert model in iteration | 1| 0|
| [[LOW-28](#low-28)] | Missing contract-existence checks before low-level calls | 1| 0|
| [[LOW-29](#low-29)] | Use Unchecked for Divisions on Constant or Immutable Values | 8| 0|
| [[LOW-30](#low-30)] | Constructors missing validation | 7| 0|
| [[LOW-31](#low-31)] | Functions calling contracts/addresses with transfer hooks are missing reentrancy guards | 9| 0|
| [[LOW-32](#low-32)] | Inconsistent checks of address params against address(0) | 4| 0|
| [[LOW-33](#low-33)] | Division in comparison | 1| 0|
| [[LOW-34](#low-34)] | Functions calling contracts/addresses with transfer hooks are missing reentrancy guards | 9| 0|
| [[NC-01](#nc-01)] | Emits without msg.sender parameter  | 9| 0|
| [[NC-02](#nc-02)] | Some if-statement can be converted to a ternary  | 16| 0|
| [[NC-03](#nc-03)] | Local variable shadowing  | 12| 0|
| [[NC-04](#nc-04)] | Subtraction may underflow if multiplication is too large  | 1| 0|
| [[NC-05](#nc-05)] | Code does not follow the best practice of check-effects-interaction  | 1| 0|
| [[NC-06](#nc-06)] | Events may be emitted out of order due to code not follow the best practice of check-effects-interaction  | 5| 0|
| [[NC-07](#nc-07)] | Non constant/immutable state variables are missing a setter post deployment  | 2| 0|
| [[NC-08](#nc-08)] | Functions with array parameters should have length checks in place  | 1| 0|
| [[NC-09](#nc-09)] | Using abi.encodePacked can result in hash collision when used in hashing functions  | 1| 0|
| [[NC-10](#nc-10)] | Greater than comparisons made on state uints that can be set to max  | 4| 0|
| [[NC-11](#nc-11)] | .call bypasses function existence check, type checking and argument packing  | 2| 0|
| [[NC-12](#nc-12)] | Getting a bool return value does not confirm the existence of a function in an external call  | 4| 0|
| [[NC-13](#nc-13)] | Empty constructor body without natspec comments  | 3| 0|
| [[NC-14](#nc-14)] | Double type casts create complexity within the code  | 1| 0|
| [[NC-15](#nc-15)] | Inconsistent comment spacing  | 4| 0|
| [[NC-16](#nc-16)] | Return values of transfer()/transferFrom() not checked  | 11| 0|
| [[NC-17](#nc-17)] | Consider adding emergency-stop functionality  | 12| 0|
| [[NC-18](#nc-18)] | Missing events in sensitive functions  | 20| 0|
| [[NC-19](#nc-19)] | Use assembly to write address storage values  | 5| 370|
| [[NC-20](#nc-20)] | Consider making private state variables internal to increase flexibility  | 2| 0|
| [[NC-21](#nc-21)] | Inconsistent comment spacing  | 4| 0|
| [[NC-22](#nc-22)] | Instances should be declared in a separate file | 1| 0|
| [[NC-23](#nc-23)] | Empty function blocks | 3| 0|
| [[NC-24](#nc-24)] | Usage of ecrecover is vulnerable to signature malleability | 1| 0|
| [[NC-25](#nc-25)] | In functions which accept an address as a parameter, there should be a zero address check to prevent bugs | 71| 0|
| [[NC-26](#nc-26)] | Enum values should be used in place of constant array indexes | 8| 0|
| [[NC-27](#nc-27)] | Default int values are manually set | 8| 0|
| [[NC-28](#nc-28)] | Reverts should use customer errors instead of strings | 3| 0|
| [[NC-29](#nc-29)] | Functions which are either private or internal should have a preceding _ in their name | 6| 0|
| [[NC-30](#nc-30)] | Private and internal state variables should have a preceding _ in their name unless they are constants | 4| 0|
| [[NC-31](#nc-31)] | Contract lines should not be longer than 120 characters for readability | 10| 0|
| [[NC-32](#nc-32)] | Use newer solidity versions | 1| 0|
| [[NC-33](#nc-33)] | Not all event definitions are utilizing indexed variables. | 34| 0|
| [[NC-34](#nc-34)] | Call calls must have their return checked | 1| 0|
| [[NC-35](#nc-35)] | Function names should differ to make the code more readable | 25| 0|
| [[NC-36](#nc-36)] | Functions should not be longer than 50 lines | 1| 0|
| [[NC-37](#nc-37)] | Functions within contracts are not ordered according to the solidity style guide | 9| 0|
| [[NC-38](#nc-38)] | Functions which set address state variables should have zero address checks | 6| 0|
| [[NC-39](#nc-39)] | Interface imports should be declared first | 5| 0|
| [[NC-40](#nc-40)] | A function which defines named returns in it's declaration doesn't need to use return  | 6| 0|
| [[NC-41](#nc-41)] | Constant/immutable state variables defined more than once | 4| 0|
| [[NC-42](#nc-42)] | Multiple mappings can be replaced with a single struct mapping | 6| 0|
| [[NC-43](#nc-43)] | Use safeApprove in place of approve | 1| 0|
| [[NC-44](#nc-44)] | Constants should be on the left side of the  | 54| 0|
| [[NC-45](#nc-45)] | Both immutable and constant state variables should be CONSTANT_CASE | 16| 0|
| [[NC-46](#nc-46)] | Consider using named mappings | 23| 0|
| [[NC-47](#nc-47)] | Loss of precision | 5| 0|
| [[NC-48](#nc-48)] | Use a single contract or library for system wide constants | 4| 0|
| [[NC-49](#nc-49)] | Consider using modifiers for address control | 2| 0|
| [[NC-50](#nc-50)] | Off-by-one timestamp error | 2| 0|
| [[NC-51](#nc-51)] | Default address(0) can be returned | 3| 0|
| [[NC-52](#nc-52)] | Variables should be used in place of magic numbers to improve readability | 7| 0|
| [[NC-53](#nc-53)] | Redundant else statement | 4| 0|
| [[NC-54](#nc-54)] | Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning | 2| 0|
| [[NC-55](#nc-55)] | Event emit should emit a parameter | 3| 0|
| [[NC-56](#nc-56)] | Large or complicated code bases should implement invariant tests | 1| 0|
| [[NC-57](#nc-57)] | Overridden function has no body | 3| 0|
| [[NC-58](#nc-58)] | Unused structs present | 1| 0|
| [[NC-59](#nc-59)] | Empty bytes check is missing | 31| 0|
| [[NC-60](#nc-60)] | No equate comparison checks between to and from address parameters | 5| 0|
| [[NC-61](#nc-61)] | Return bool not explicit | 2| 0|
| [[NC-62](#nc-62)] | Remove unnecessary solhint-disable | 1| 0|
| [[NC-63](#nc-63)] | Consider using SMTChecker | 20| 5000|
| [[NC-64](#nc-64)] | Top level declarations should be separated by two blank lines | 10| 0|
| [[NC-65](#nc-65)] | Contracts should have full test coverage | 14| 0|
| [[NC-66](#nc-66)] | Consider using SafeTransferLib.safeTransferETH() or Address.sendValue() for clearer semantic meaning | 1| 0|
| [[NC-67](#nc-67)] | Whitespace in expressions | 1| 0|
| [[NC-68](#nc-68)] | Consider using named function calls | 43| 0|
| [[NC-69](#nc-69)] | Using XOR (^) and AND (&) bitwise equivalents | 1| 0|
| [[NC-70](#nc-70)] | Public state variables should include natspec comments | 3| 0|
| [[NC-71](#nc-71)] | Lack of space near the operator | 22| 0|
| [[NC-72](#nc-72)] | Lack Of Brace Spacing | 45| 0|
| [[NC-73](#nc-73)] | Using while for unbounded loops isn’t recommended | 1| 0|
| [[NC-74](#nc-74)] | Revert should be used on some functions instead of return | 1| 0|
| [[NC-75](#nc-75)] | Common functions should be refactored to a common base contract | 2| 0|
| [[NC-76](#nc-76)] | Use of override is unnecessary | 8| 0|
| [[NC-77](#nc-77)] | Unsafe uint to int conversion | 8| 0|
| [[NC-78](#nc-78)] | If statement control structures do not comply with best practices | 14| 0|
| [[NC-79](#nc-79)] | Contract does not follow the Solidity style guide's suggested layout ordering | 1| 0|
| [[NC-80](#nc-80)] | Consider adding formal verification proofs | 14| 0|
| [[NC-81](#nc-81)] | Unused import | 2| 0|
| [[NC-82](#nc-82)] | Use string.concat() on strings instead of abi.encodePacked() for clearer semantic meaning | 2| 0|
| [[NC-83](#nc-83)] | function names should be lowerCamelCase | 1| 0|
| [[NC-84](#nc-84)] | Consider bounding input array length | 5| 0|
| [[NC-85](#nc-85)] | Duplicated require() checks should be refactored to a modifier or function | 8| 0|
| [[NC-86](#nc-86)] | safeApprove()/approve() may revert if the current approval is not zero | 1| 0|
| [[NC-87](#nc-87)] | Consider disallowing transfers to `address(this)` | 5| 0|
| [[NC-88](#nc-88)] | Add inline comments for unnamed variables in function declarations | 1| 0|
| [[NC-89](#nc-89)] | Ensure block.timestamp is only used in long time intervals | 1| 0|
| [[NC-90](#nc-90)] | It is best practice to use linear inheritance | 5| 0|
| [[NC-91](#nc-91)] | A event should be emitted if a non immutable state variable is set in a constructor | 7| 0|
| [[NC-92](#nc-92)] | Funds can be trapped due to unreverting local payable call | 1| 0|
| [[NC-93](#nc-93)] | Superfluous parameter can only be one value | 5| 0|
| [[NC-94](#nc-94)] | Mint functions should be accompanied by a burn function and vice versa | 3| 0|
| [[NC-95](#nc-95)] | Use the Modern Upgradeable Contract Paradigm | 14| 0|
| [[NC-96](#nc-96)] | Upgrade openzeppelin to the Latest Version - 5.0.0 | 20| 0|
| [[NC-97](#nc-97)] | Use a struct to encapsulate multiple function parameters | 5| 0|
| [[NC-98](#nc-98)] | Returning a struct instead of returning many variables is better | 1| 0|
| [[NC-99](#nc-99)] | Using delete instead of setting mapping to 0 saves gas | 1| 5|
| [[NC-100](#nc-100)] | Long numbers should include underscores to improve readability and prevent typos | 4| 0|
| [[NC-101](#nc-101)] | Consider using ERC20Capped | 6| 0|
| [[NC-102](#nc-102)] | Consider using a format prettier or forge fmt | 4| 0|
| [[NC-103](#nc-103)] | Avoid defining a function in a single line including it's contents | 1| 0|
| [[NC-104](#nc-104)] | Use 'using' keyword when using specific imports rather than calling the specific import directly | 124| 0|
| [[NC-105](#nc-105)] | package.json name variable should only consist of lowercase letters and underscores | 1| 0|
| [[NC-106](#nc-106)] | package.json missing/empty description | 1| 0|
| [[NC-107](#nc-107)] | Avoid revertible function calls in a constructor | 1| 0|
| [[NC-108](#nc-108)] | Avoid declaring variables with the names of defined functions within the project | 55| 0|
| [[NC-109](#nc-109)] | Add inline comments for unnamed variables in function declarations | 1| 0|
| [[NC-110](#nc-110)] | Public state variables should include natspec comments | 3| 0|
| [[NC-111](#nc-111)] | Incorrect NatSpec Syntax | 1| 0|
| [[NC-112](#nc-112)] | Use @inheritdoc rather than using a non-standard annotation | 4| 0|
| [[NC-113](#nc-113)] | No @inheritdoc on override functions | 27| 0|
| [[NC-114](#nc-114)] | Natspec @author is missing from contract | 7| 0|
| [[NC-115](#nc-115)] | Natspec @notice is missing from contract | 3| 0|
| [[NC-116](#nc-116)] | Natspec @dev is missing from contract | 11| 0|
| [[NC-117](#nc-117)] | Natspec @title is missing from contract | 7| 0|
| [[NC-118](#nc-118)] | Natspec @author is missing from interface | 1| 0|
| [[NC-119](#nc-119)] | Natspec @title is missing from interface | 1| 0|
| [[NC-120](#nc-120)] | Natspec @dev is missing from interface | 1| 0|
| [[NC-121](#nc-121)] | Natspec @notice is missing from interface | 1| 0|
| [[NC-122](#nc-122)] | Natspec @author is missing from library | 1| 0|
| [[NC-123](#nc-123)] | Natspec @dev is missing from library | 1| 0|
| [[NC-124](#nc-124)] | Natspec @author is missing from abstract | 1| 0|
| [[NC-125](#nc-125)] | Natspec @dev is missing from abstract | 3| 0|
| [[NC-126](#nc-126)] | Natspec @notice is missing from abstract | 1| 0|
| [[NC-127](#nc-127)] | Event declarations should have NatSpec descriptions | 8| 0|
| [[NC-128](#nc-128)] | Event declarations should have @dev NatSpec comments | 8| 0|
| [[NC-129](#nc-129)] | Event declarations should have @notice NatSpec comments | 8| 0|
| [[NC-130](#nc-130)] | Event declarations should have @params NatSpec comments | 8| 0|
| [[NC-131](#nc-131)] | Error declarations should have @dev NatSpec comments | 1| 0|
| [[NC-132](#nc-132)] | Error declarations should have @notice NatSpec comments | 1| 0|
| [[NC-133](#nc-133)] | Error declarations should have @params NatSpec comments | 1| 0|
| [[NC-134](#nc-134)] | Natspec @params comments are missing from modifier | 1| 0|
| [[NC-135](#nc-135)] | Natspec @dev comments are missing from modifier | 1| 0|
| [[NC-136](#nc-136)] | Natspec @params comments are missing from struct | 12| 0|
| [[NC-137](#nc-137)] | Natspec @dev comments are missing from struct | 11| 0|
| [[NC-138](#nc-138)] | Natspec @notice comments are missing from struct | 11| 0|
| [[NC-139](#nc-139)] | Natspec @params comments are missing from function | 155| 0|
| [[NC-140](#nc-140)] | Natspec @dev comments are missing from function | 184| 0|
| [[NC-141](#nc-141)] | Natspec @notice comments are missing from function | 65| 0|
| [[NC-142](#nc-142)] | Natspec @dev comments are missing from constructor | 16| 0|
| [[NC-143](#nc-143)] | Natspec @notice comments are missing from constructor | 14| 0|
| [[NC-144](#nc-144)] | Natspec @params comments are missing from constructor | 12| 0|
| [[NC-145](#nc-145)] | Natspec @dev comments are missing from enum | 1| 0|
| [[NC-146](#nc-146)] | Natspec @notice comments are missing from enum | 1| 0|
| [[NC-147](#nc-147)] | Natspec comments are missing from unchecked blocks | 4| 0|
| [[NC-148](#nc-148)] | ERC777 tokens can introduce reentrancy risks | 15| 0|
| [[GAS-01](#gas-01)] | Internal functions never used once can be removed  | 6| 0|
| [[GAS-02](#gas-02)] | Some error strings are not descriptive  | 4| 0|
| [[GAS-03](#gas-03)] | Lack of unchecked in loops  | 2| 240|
| [[GAS-04](#gas-04)] | Multiple accesses of the same mapping/array key/index should be cached  | 2| 1092|
| [[GAS-05](#gas-05)] | State variables used within a function more than once should be cached to save gas  | 1| 500|
| [[GAS-06](#gas-06)] | Shorten the array rather than copying to a new one  | 9| 0|
| [[GAS-07](#gas-07)] | Using bools for storage incurs overhead  | 8| 560|
| [[GAS-08](#gas-08)] | Low level call can be optimized with assembly | 14| 0|
| [[GAS-09](#gas-09)] | Optimize by Using Assembly for Low-Level Calls' Return Data | 2| 318|
| [[GAS-10](#gas-10)] | Low level call can be optimized with assembly | 2| 496|
| [[GAS-11](#gas-11)] | Unbounded Gas Consumption Risk Due to External Call Recipients | 1| 0|
| [[GAS-12](#gas-12)] | Consider Using Solady's Gas Optimized Lib for Math | 20| 0|
| [[GAS-13](#gas-13)] | x + y is more efficient than using += for state variables (likewise for -=) | 16| 80|
| [[GAS-14](#gas-14)] | There is a 32 byte length threshold for error strings, strings longer than this consume more gas | 29| 406|
| [[GAS-15](#gas-15)] | Public functions not used internally can be marked as external to save gas | 7| 0|
| [[GAS-16](#gas-16)] | bytes.concat() can be used in place of abi.encodePacked | 1| 0|
| [[GAS-17](#gas-17)] | Usage of smaller uint/int types causes overhead | 14| 770|
| [[GAS-18](#gas-18)] | Use != 0 instead of > 0 | 3| 9|
| [[GAS-19](#gas-19)] | Integer increments by one can be unchecked to save on gas fees | 5| 600|
| [[GAS-20](#gas-20)] | Use byte32 in place of string | 2| 0|
| [[GAS-21](#gas-21)] | Default bool values are manually reset | 1| 0|
| [[GAS-22](#gas-22)] | Default int values are manually reset | 10| 0|
| [[GAS-23](#gas-23)] | <= or >= is more efficient than < or >  | 5| 15|
| [[GAS-24](#gas-24)] | Mappings used within a function more than once should be cached to save gas | 1| 100|
| [[GAS-25](#gas-25)] | Use assembly to check for the zero address | 8| 0|
| [[GAS-26](#gas-26)] | Divisions which do not divide by -X cannot overflow or overflow so such operations can be unchecked to save gas | 13| 0|
| [[GAS-27](#gas-27)] | Can transfer 0 | 6| 0|
| [[GAS-28](#gas-28)] | Divisions of powers of 2 can be replaced by a right shift operation to save gas | 1| 0|
| [[GAS-29](#gas-29)] | Struct variables can be packed into fewer storage slots | 4| 10000|
| [[GAS-30](#gas-30)] | Consider activating via-ir for deploying | 1| 250|
| [[GAS-31](#gas-31)] | Superfluous event fields | 15| 510|
| [[GAS-32](#gas-32)] | Add unchecked {} for subtractions where the operands cannot underflow | 33| 2805|
| [[GAS-33](#gas-33)] | Private functions never used can be removed | 2| 0|
| [[GAS-34](#gas-34)] | Private functions used once can be inlined | 1| 0|
| [[GAS-35](#gas-35)] | Use bitmap to save gas | 6| 420|
| [[GAS-36](#gas-36)] | Use assembly hashing | 10| 0|
| [[GAS-37](#gas-37)] | Consider using OZ EnumerateSet in place of nested mappings | 7| 7000|
| [[GAS-38](#gas-38)] | Use assembly to emit events | 72| 2736|
| [[GAS-39](#gas-39)] | Use solady library where possible to save gas | 6| 6000|
| [[GAS-40](#gas-40)] | Use unchecked for operations on immutable variables | 1| 0|
| [[GAS-41](#gas-41)] | Counting down in for statements is more gas efficient | 7| 0|
| [[GAS-42](#gas-42)] | State variables can be packed into fewer storage slots by truncating timestamp bytes | 4| 10000|
| [[GAS-43](#gas-43)] | Using private rather than public for constants and immutables, saves gas | 6| 0|
| [[GAS-44](#gas-44)] | Mark Functions That Revert For Normal Users As payable | 1| 25|
| [[GAS-45](#gas-45)] | State variable read in a loop | 2| 12|
| [[GAS-46](#gas-46)] | Function names can be optimized | 14| 1792|
| [[GAS-47](#gas-47)] | Consider migrating require statements to custom errors | 106| 1484|
| [[GAS-48](#gas-48)] | Consider not using libraries when implementing simple functionality. | 1| 1000|
| [[GAS-49](#gas-49)] | Where a value is casted more than once, consider caching the result to save gas | 1| 0|
| [[GAS-50](#gas-50)] | State variable can be updated more than once in a function | 3| 2400|
| [[GAS-51](#gas-51)] | Use assembly to validate msg.sender | 8| 0|
| [[GAS-52](#gas-52)] | Simple checks for zero uint can be done using assembly to save gas | 47| 282|
| [[GAS-53](#gas-53)] | Trade-offs Between Modifiers and Internal Functions | 57| 598500|
| [[GAS-54](#gas-54)] | Using nested if to save gas | 4| 24|
| [[GAS-55](#gas-55)] | Optimize Deployment Size by Fine-tuning IPFS Hash | 14| 148400|
| [[GAS-56](#gas-56)] | Avoid Unnecessary Public Variables | 47| 1034000|
| [[GAS-57](#gas-57)] | Optimize Storage with Byte Truncation for Time Related State Variables | 3| 6000|
| [[GAS-58](#gas-58)] | Stack variable cost less than state variables while used in emiting event | 6| 54|
| [[GAS-59](#gas-59)] | Use s.x = s.x + y instead of s.x += y for memory structs (same for -= etc) | 4| 400|
| [[GAS-60](#gas-60)] | Time state variables can be truncated to uint32 | 1| 20000|
| [[GAS-61](#gas-61)] | Constants are cheaper than Enums | 2| 40000|
| [[GAS-62](#gas-62)] | ++X costs slightly less gas than X++ (same with --) | 6| 30|
| [[GAS-63](#gas-63)] | Solidity versions 0.8.19 and above are more gas efficient | 1| 1000|
| [[GAS-64](#gas-64)] | Variable declared within iteration | 4| 0|
| [[GAS-65](#gas-65)] | The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement | 17| 255|
| [[GAS-66](#gas-66)] | Calling .length in a for loop wastes gas | 4| 388|
| [[GAS-67](#gas-67)] | Internal functions only used once can be inlined so save gas | 14| 420|
| [[GAS-68](#gas-68)] | Constructors can be marked as payable to save deployment gas | 15| 0|
| [[GAS-69](#gas-69)] | Order struct members to reduce size | 12| 0|
| [[GAS-70](#gas-70)] | Use assembly scratch space to build calldata for external calls | 131| 28820|
| [[GAS-71](#gas-71)] | Use assembly scratch space to build calldata for event emits | 33| 7260|
| [[GAS-72](#gas-72)] | Consider using solady's `FixedPointMathLib` | 31| 0|
| [[GAS-73](#gas-73)] | Same cast is done multiple times | 11| 0|
| [[GAS-74](#gas-74)] | Assigning to structs can be more efficient | 14| 1820|
| [[GAS-75](#gas-75)] | Cache address(this) when used more than once | 7| 0|
| [[MEDIUM-01](#medium-01)] | Privileged functions can create points of failure | 1| 0|
| [[MEDIUM-02](#medium-02)] | Using block.number for time comparisons | 4| 0|
| [[MEDIUM-03](#medium-03)] | increase/decrease allowance should be used instead of approve/safeApprove | 1| 0|
| [[MEDIUM-04](#medium-04)] | Return values not checked for approve() | 1| 0|
| [[MEDIUM-05](#medium-05)] | Large transfers may not work with some ERC20 tokens | 15| 0|


 LightChaser-V3 ### Low Risk Issues


### [L-01]<a name="l-01"></a> Subtractions performed on a possibly uninitialized uint

*There are 1 instance(s) of this issue:*

```461:     function _burn(address account, uint256 amount) internal virtual override { // <= FOUND
462:         
463:         
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) {
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares,
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount;
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         
486:         ERC20._burn(account, amount);
487: 
488:         
489:         if (_rebasingState.isRebasing == 1) {
490:             uint256 balanceAfter = balanceBefore - amount; // <= FOUND
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;
496:             rebasingState[account] = RebasingState({
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L490)### Disputed Risk Issues


### [D-01]<a name="d-01"></a> Gas grief possible on unsafe external calls [EXP]
In Solidity, the use of low-level `call` methods can expose contracts to gas griefing attacks. The potential problem arises when the callee contract returns a large amount of data. This data is allocated in the memory of the calling contract, which pays for the gas costs. If the callee contract intentionally returns an enormous amount of data, the gas costs can skyrocket, causing the transaction to fail due to an Out of Gas error. Therefore, it's advisable to limit the use of `call` when interacting with untrusted contracts, or ensure that the callee's returned data size is capped or known in advance to prevent unexpected high gas costs.

*There are 1 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params);
167:         return term;
168:     }
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L105)
### [D-02]<a name="d-02"></a> Potential division by zero should have zero checks in place [EXP]
Implement a zero address check for found instances

*There are 4 instance(s) of this issue:*

```151:     function minBorrow() external view returns (uint256) { // <= FOUND
152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
153:     }
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L151-L152)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L256)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L256)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L256)
### [D-03]<a name="d-03"></a> Unchecked blocks with subtractions may underflow [EXP]
Within unchecked blocks in Solidity, arithmetic operations bypass overflow and underflow checks. When subtractions occur without proper bounds validation, they may underflow. An underflow in an unsigned integer subtraction can wrap the value around to its maximum, leading to unintended contract behavior or potential vulnerabilities. To prevent such scenarios, developers should either avoid unchecked blocks for subtraction operations or manually implement checks to ensure operands' validity before subtraction.

*There are 1 instance(s) of this issue:*

```180:               unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease; // <= FOUND
182:                 }
```

*GitHub* : [180](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L180-L181)
### [D-04]<a name="d-04"></a> Emits without msg.sender parameter [EXP]
In Solidity, when `msg.sender` plays a crucial role in a function's logic, it's important for transparency and auditability that any events emitted by this function include `msg.sender` as a parameter. This practice enhances the traceability and accountability of transactions, allowing users and external observers to easily track who initiated a particular action. Including `msg.sender` in event logs helps in creating a clear and verifiable record of interactions with the contract, thereby increasing user trust and facilitating easier debugging and analysis of contract behavior. It's a key aspect of writing clear, transparent, and user-friendly smart contracts.

*There are 5 instance(s) of this issue:*

```481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount); // <= FOUND
486:         return super.transfer(to, amount);
487:     }
```

*GitHub* : [485](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L485-L485)

```481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount); // <= FOUND
486:         return super.transfer(to, amount);
487:     }
```

*GitHub* : [485](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L485-L485)

```481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount); // <= FOUND
486:         return super.transfer(to, amount);
487:     }
```

*GitHub* : [485](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L485-L485)

```123:     function notifyGaugeLoss(address gauge) external {
124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
125: 
126:         
127:         lastGaugeLoss[gauge] = block.timestamp;
128:         emit GaugeLoss(gauge, block.timestamp); // <= FOUND
129:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L128)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut); // <= FOUND
112:     }
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L109-L111)
### [D-05]<a name="d-05"></a> Some if-statement can be converted to a ternary [EXP]
Improving code readability and compactness is an integral part of optimal programming practices. The use of ternary operators in place of if-else conditions is one such measure. Ternary operators allow us to write conditional statements in a more concise manner, thereby enhancing readability and simplicity. They follow the syntax `condition ? exprIfTrue : exprIfFalse`, which interprets as "if the condition is true, evaluate to `exprIfTrue`, else evaluate to `exprIfFalse`". By adopting this approach, we make our code more streamlined and intuitive, which could potentially aid in better understanding and maintenance of the codebase.

*There are 5 instance(s) of this issue:*

```407:         if (newAdd) {
408:             
409:             gaugeType[gauge] = _type; // <= FOUND
410:         }
```

*GitHub* : [407](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L407-L409)

```175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta); // <= FOUND
177:         }
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L175-L176)

```229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true; // <= FOUND
231:         }
```

*GitHub* : [229](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L229-L230)

```249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) / // <= FOUND
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18; // <= FOUND
253:             if (slashed) {
254:                 guildReward = 0; // <= FOUND
255:             }
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L249-L254)

```393:                    if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18; // <= FOUND
395:                     }
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L393-L394)
### [D-06]<a name="d-06"></a> Cyclomatic complexity in functions [EXP]
Cyclomatic complexity is a software metric used to measure the complexity of a program. It quantifies the number of linearly independent paths through a program's source code, giving an idea of how complex the control flow is. High cyclomatic complexity may indicate a higher risk of defects and can make the code harder to understand, test, and maintain. It often suggests that a function or method is trying to do too much, and a refactor might be needed. By breaking down complex functions into smaller, more focused pieces, you can improve readability, ease of testing, and overall maintainability.

*There are 2 instance(s) of this issue:*

```461:     function _burn(address account, uint256 amount) internal virtual override { // <= FOUND
462:         
463:         
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) {
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares,
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount;
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         
486:         ERC20._burn(account, amount);
487: 
488:         
489:         if (_rebasingState.isRebasing == 1) {
490:             uint256 balanceAfter = balanceBefore - amount;
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;
496:             rebasingState[account] = RebasingState({
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```461:     function _burn(address account, uint256 amount) internal virtual override { // <= FOUND
462:         
463:         
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) {
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares,
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount;
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         
486:         ERC20._burn(account, amount);
487: 
488:         
489:         if (_rebasingState.isRebasing == 1) {
490:             uint256 balanceAfter = balanceBefore - amount;
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;
496:             rebasingState[account] = RebasingState({
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)
### [D-07]<a name="d-07"></a> Code does not follow the best practice of check-effects-interaction [EXP]
The "check-effects-interaction" pattern is a best practice in smart contract development, emphasizing the order of operations in functions to prevent reentrancy attacks. Violations arise when a function interacts with external contracts before settling internal state changes or checks. This misordering can expose the contract to potential threats. To adhere to this pattern, first ensure all conditions or checks are satisfied, then update any internal states, and only after these steps, interact with external contracts or addresses. Rearranging operations to this recommended sequence bolsters contract security and aligns with established best practices in the Ethereum community.

*There are 9 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L101)

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L101)

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L101)

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L101)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L458)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L458)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L458)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L458)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L458)
### [D-08]<a name="d-08"></a> Events may be emitted out of order due to code not follow the best practice of check-effects-interaction [EXP]
The "check-effects-interaction" pattern also impacts event ordering. When a contract doesn't adhere to this pattern, events might be emitted in a sequence that doesn't reflect the actual logical flow of operations. This can cause confusion during event tracking, potentially leading to erroneous off-chain interpretations. To rectify this, always ensure that checks are performed first, state modifications come next, and interactions with external contracts or addresses are done last. This will ensure events are emitted in a logical, consistent manner, providing a clear and accurate chronological record of on-chain actions for off-chain systems and observers.

*There are 3 instance(s) of this issue:*

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax); // <= FOUND
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L465)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax); // <= FOUND
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L465)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax); // <= FOUND
466:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L465)
### [D-09]<a name="d-09"></a> Ids should begin at zero [EXP]
It is standard to begin Id values at zero, not doing so can result in wrong assumptions being made in contract logic.

*There are 1 instance(s) of this issue:*

```332: 
333:         uint256 proposalId = super.propose( // <= FOUND
334:             targets,
335:             values,
336:             calldatas,
337:             description
338:         );
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L332-L333)
### [D-10]<a name="d-10"></a> Some error strings are not descriptive [EXP]
Consider adding more detail to these error strings

*There are 1 instance(s) of this issue:*

```123:     function notifyGaugeLoss(address gauge) external {
124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
125: 
126:         
127:         lastGaugeLoss[gauge] = block.timestamp;
128:         emit GaugeLoss(gauge, block.timestamp);
129:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L124)
### [D-11]<a name="d-11"></a> Redundant use of whenNotPaused [EXP]
If a function calls a function with the whenNotPaused modifier, it itself doesn't need the whenNotPaused modifier

*There are 4 instance(s) of this issue:*

```103:     function mint( // <= FOUND
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L110)

```103:     function mint( // <= FOUND
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L110)

```103:     function mint( // <= FOUND
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L110)

```103:     function mint( // <= FOUND
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L110)
### [D-12]<a name="d-12"></a> Avoid updating storage when the value hasn't changed [EXP]

*There are 6 instance(s) of this issue:*

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId]; // <= FOUND
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true; // <= FOUND
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L208)
### [D-13]<a name="d-13"></a> Multiple accesses of the same mapping/array key/index should be cached [EXP]
Caching repeated accesses to the same mapping or array key/index in smart contracts can lead to significant gas savings. In Solidity, each read operation from storage (like accessing a value in a mapping or array using a key or index) costs gas. By storing the accessed value in a local variable and reusing it within the function, you avoid multiple expensive storage read operations. This practice is particularly beneficial in loops or functions with multiple reads of the same data. Implementing this caching approach enhances efficiency and reduces transaction costs, which is crucial for optimizing smart contract performance and user experience on the blockchain.

*There are 10 instance(s) of this issue:*

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term]; // <= FOUND
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0, // <= FOUND
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight; // <= FOUND
137:         polls[snapshotBlock][term] = _weight + userWeight; // <= FOUND
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true; // <= FOUND
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L139)

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term]; // <= FOUND
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0, // <= FOUND
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight; // <= FOUND
137:         polls[snapshotBlock][term] = _weight + userWeight; // <= FOUND
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true; // <= FOUND
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L139)

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term]; // <= FOUND
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0, // <= FOUND
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight; // <= FOUND
137:         polls[snapshotBlock][term] = _weight + userWeight; // <= FOUND
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true; // <= FOUND
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L139)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp, // <= FOUND
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp; // <= FOUND
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L192)
### [D-14]<a name="d-14"></a> Require/revert statements regarding parameters should be first in a function [EXP]

*There are 10 instance(s) of this issue:*

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)
### [D-15]<a name="d-15"></a> The result of a function call should be cached rather than re-calling the function [EXP-0]
External calls in Solidity are costly in terms of gas usage. This can significantly impact contract efficiency and cost. Functions that make repetitive calls to fetch the same data from other contracts can cause unnecessary gas expenditure. To optimize this, it's advisable to store the returned value of these function calls in a state variable, essentially caching the data. This data can be updated at regular intervals or under specific conditions instead of fetching it from the external contract on every invocation. Be sure to analyze the frequency of data change in the external contract to balance data freshness with gas efficiency when implementing caching.

*There are 1 instance(s) of this issue:*

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private {
368:         Checkpoint[] storage ckpts = _checkpoints[delegatee];
369: 
370:         uint256 pos = ckpts.length;
371:         uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;
372:         uint256 newWeight = op(oldWeight, delta);
373: 
374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {
375:             ckpts[pos - 1].votes = newWeight.safeCastTo224(); // <= FOUND
376:         } else {
377:             ckpts.push(
378:                 Checkpoint({
379:                     fromBlock: block.number.safeCastTo32(),
380:                     votes: newWeight.safeCastTo224() // <= FOUND
381:                 })
382:             );
383:         }
384:         emit DelegateVotesChanged(delegatee, oldWeight, newWeight);
385:     }
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L380)
### [D-16]<a name="d-16"></a> State variables used within a function more than once should be cached to save gas [EXP-1]
Cache such variables and perform operations on them, if operations include modifications to the state variable(s) then remember to equate the state variable to it's cached counterpart at the end

*There are 4 instance(s) of this issue:*

```68:     function _setQuorum(uint256 newQuorum) internal { // <= FOUND
69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
70:         _quorum = newQuorum; // <= FOUND
71:     }
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L70)

```68:     function _setQuorum(uint256 newQuorum) internal { // <= FOUND
69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
70:         _quorum = newQuorum; // <= FOUND
71:     }
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L70)

```68:     function _setQuorum(uint256 newQuorum) internal { // <= FOUND
69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
70:         _quorum = newQuorum; // <= FOUND
71:     }
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L70)

```68:     function _setQuorum(uint256 newQuorum) internal { // <= FOUND
69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
70:         _quorum = newQuorum; // <= FOUND
71:     }
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L70)
### [D-17]<a name="d-17"></a> Functions with array parameters should have length checks in place [EXP-2]
Functions in Solidity that accept array parameters should incorporate length checks as a security measure. This is to prevent potential overflow errors, unwanted gas consumption, and manipulation attempts. Without length checks, an attacker could pass excessively large arrays as input, causing excessive computation and potentially causing the function to exceed the block gas limit, leading to a denial-of-service. Additionally, unexpected array sizes could lead to logic errors within the function. As a resolution, always validate array length at the start of functions handling array inputs, ensuring it aligns with the expectations of the function logic. This makes the code more robust and predictable.

*There are 2 instance(s) of this issue:*

```171:     function propose(
172:         address[] memory , // <= FOUND
173:         uint256[] memory , // <= FOUND
174:         bytes[] memory , // <= FOUND
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) {
177:         revert("LendingTermOnboarding: cannot propose arbitrary actions");
178:     }
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L174)

```171:     function propose(
172:         address[] memory , // <= FOUND
173:         uint256[] memory , // <= FOUND
174:         bytes[] memory , // <= FOUND
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) {
177:         revert("LendingTermOnboarding: cannot propose arbitrary actions");
178:     }
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L174)### LOW Risk Issues


### [LOW-01]<a name="low-01"></a> Potential division by zero should have zero checks in place 
Implement a zero address check for found instances

*There are 1 instance(s) of this issue:*

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L256)
### [LOW-02]<a name="low-02"></a> Unsafe use of transfer()/transferFrom() with IERC20 
SafeTransfer should be used in place of Transfer for Solidity contracts to ensure robust security and error handling. Unlike the basic Transfer function, SafeTransfer incorporates safeguards against potential smart contract vulnerabilities, such as reentrancy attacks and unexpected token loss. By automatically validating the recipient's ability to receive tokens and reverting transactions in case of failures,

*There are 11 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external { // <= FOUND
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external { // <= FOUND
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263)
### [LOW-03]<a name="low-03"></a> Some tokens may revert when zero value transfers are made 
Reason: In Solidity, ERC20 token transfers of value 0 can sometimes lead to unexpected issues. This is particularly relevant when dealing with fractional token amounts that round to 0 when less than 1 of the smallest unit is transferred, leading to an effective transfer of nothing while still consuming gas. Furthermore, some ERC20 token implementations may revert on attempts to transfer a value of 0. However, note that this issue doesn't generally apply to wrapper native tokens like WETH.

Resolution: It's advisable to include a condition before any transfer operation to bypass the transaction if the transfer amount is 0. This saves unnecessary gas expenditure and prevents potential function reverts. For handling fractions, ensure token decimals are appropriately assigned and contemplate setting a minimum transfer threshold to avoid rounding down to 0. When dealing with wrapped tokens like WETH, special consideration should be given to their unique characteristics.

*There are 8 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external { // <= FOUND
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external { // <= FOUND
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L109)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn;
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L117-L126)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L142)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)
### [LOW-04]<a name="low-04"></a> Low Level Calls to Custom Addresses
Low-level calls (such as `.call()`, `.delegatecall()`, or `.callcode()`) in Solidity provide a way to interact with other contracts or addresses. However, when these calls are made to addresses that are provided as parameters or are not well-validated, they pose a significant security risk. Untrusted addresses might contain malicious code leading to unexpected behavior, loss of funds, or vulnerabilities.

**Resolution**: Prefer using high-level Solidity function calls or interface-based interactions with known contracts to ensure security. If low-level calls are necessary, rigorously validate the addresses and test all possible interactions. Implementing additional checks and fail-safes can help mitigate potential risks associated with low-level calls.

*There are 1 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L101)
### [LOW-05]<a name="low-05"></a> Require should be used instead of assert as assert in some solidity versions does not refund remaining gas
In Solidity, require should be used instead of assert for input validation and error handling due to its more efficient and flexible nature. While both functions check for a specified condition and revert the transaction if it evaluates to false, assert consumes all remaining gas upon failure, which can lead to higher costs for users. On the other hand, require refunds unused gas, making it a more gas-efficient option. Additionally, require allows for custom error messages, which improves debugging and error reporting.

*There are 4 instance(s) of this issue:*

```156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
161:         assert( // <= FOUND
162:             credit == address(0) && guild == address(0) && psm == address(0)
163:         );
164:         credit = _credit;
165:         guild = _guild;
166:         psm = _psm;
167:     }
```

*GitHub* : [161](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L161-L161)

```246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) {
249:         ProposalState status = super.state(proposalId);
250:         bytes32 queueid = _timelockIds[proposalId];
251: 
252:         
253:         
254:         
255:         assert(queueid != bytes32(0)); // <= FOUND
256: 
257:         
258:         if (status == ProposalState.Executed) {
259:             return ProposalState.Executed;
260:         }
261:         
262:         
263:         if (status == ProposalState.Pending) {
264:             return ProposalState.Pending;
265:         }
266: 
267:         
268:         
269:         uint256 timelockOperationTimestamp = TimelockController(
270:             payable(timelock)
271:         ).getTimestamp(queueid);
272: 
273:         
274:         if (timelockOperationTimestamp == 0) {
275:             return ProposalState.Canceled;
276:         }
277:         
278:         if (timelockOperationTimestamp == 1) {
279:             return ProposalState.Defeated;
280:         }
281: 
282:         
283:         if (timelockOperationTimestamp > block.timestamp) {
284:             
285:             
286:             
287:             
288:             if (_quorumReached(proposalId)) {
289:                 return ProposalState.Succeeded;
290:             }
291:             
292:             else {
293:                 return ProposalState.Active;
294:             }
295:         }
296:         
297:         
298:         else {
299:             return ProposalState.Defeated;
300:         }
301:     }
```

*GitHub* : [255](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L255-L255)

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) {
121:         
122:         uint256 _startTime = auctions[loanId].startTime;
123:         require(_startTime != 0, "AuctionHouse: invalid auction");
124: 
125:         
126:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended");
127: 
128:         
129:         
130:         
131:         assert(block.timestamp >= _startTime); // <= FOUND
132: 
133:         
134:         if (block.timestamp < _startTime + midPoint) {
135:             
136:             creditAsked = auctions[loanId].callDebt;
137: 
138:             
139:             uint256 elapsed = block.timestamp - _startTime; 
140:             uint256 _collateralAmount = auctions[loanId].collateralAmount; 
141:             collateralReceived = (_collateralAmount * elapsed) / midPoint;
142:         }
143:         
144:         else if (block.timestamp < _startTime + auctionDuration) {
145:             
146:             collateralReceived = auctions[loanId].collateralAmount;
147: 
148:             
149:             uint256 PHASE_2_DURATION = auctionDuration - midPoint;
150:             uint256 elapsed = block.timestamp - _startTime - midPoint; 
151:             uint256 _callDebt = auctions[loanId].callDebt; 
152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION;
153:         }
154:         
155:         
156:         else {
157:             
158:             collateralReceived = auctions[loanId].collateralAmount;
159:             
160:         }
161:     }
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L131-L131)

```160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0)); // <= FOUND
167:         assert(_core != address(0)); // <= FOUND
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L166-L167)
### [LOW-06]<a name="low-06"></a> Require statements should have error string
Adding error strings to require statements in Solidity contracts, although not mandatory, enhances error handling, debugging, and overall contract maintainability. Providing a descriptive error message with each require statement helps identify the specific reason for a transaction failure, making it easier for developers to troubleshoot issues and for users to understand the cause of a revert. Including error strings improves code readability and fosters transparency, as the logic and conditions behind each requirement are clearly communicated

*There are 4 instance(s) of this issue:*

```324: require(_userGauges[user].remove(gauge));
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L324-L324)

```353: require(_delegates[delegator].remove(delegatee));
```

*GitHub* : [353](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L353-L353)

```451: require(_delegates[user].remove(delegatee));
```

*GitHub* : [451](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L451-L451)

```503: require(signer != address(0));
```

*GitHub* : [503](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L503-L503)
### [LOW-07]<a name="low-07"></a> The call abi.encodeWithSelector is not type safe
The call abi.encodeCall shout be used instead. Note abi.encodeCall is only safe from typographical errors in solidity versions 0.8.13 and above

*There are 3 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector) // <= FOUND
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
```

*GitHub* : [115](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L115-L115)

```215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     {
227:         targets = new address[](3);
228:         values = new uint256[](3);
229:         calldatas = new bytes[](3);
230:         description = string.concat(
231:             "[",
232:             Strings.toString(block.number),
233:             "]",
234:             " Enable term ",
235:             Strings.toHexString(term)
236:         );
237: 
238:         
239:         targets[0] = guildToken;
240:         calldatas[0] = abi.encodeWithSelector( // <= FOUND
241:             GuildToken.addGauge.selector,
242:             gaugeType,
243:             term
244:         );
245: 
246:         
247:         address _core = address(core());
248:         targets[1] = _core;
249:         calldatas[1] = abi.encodeWithSelector( // <= FOUND
250:             AccessControl.grantRole.selector,
251:             CoreRoles.RATE_LIMITED_CREDIT_MINTER,
252:             term
253:         );
254: 
255:         
256:         targets[2] = _core;
257:         calldatas[2] = abi.encodeWithSelector( // <= FOUND
258:             AccessControl.grantRole.selector,
259:             CoreRoles.GAUGE_PNL_NOTIFIER,
260:             term
261:         );
262:     }
```

*GitHub* : [240](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L240-L257)

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); 
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector( // <= FOUND
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId))
390:         );
391:     }
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L383-L383)
### [LOW-08]<a name="low-08"></a> When using a uint index in a for loop, there should be a length check to prevent index out of range.
This is only applicable in instances where the index is used as an array index of a array which wasn't used to calculate the for loop range

*There are 1 instance(s) of this issue:*

```17: all
```

*GitHub* :
### [LOW-09]<a name="low-09"></a> Contracts are vulnerable to fee-on-transfer accounting-related issues
The below-listed functions use `transferFrom()` to move funds from the sender to the recipient but fail to verify if the received token amount matches the transferred amount. This could pose an issue with fee-on-transfer tokens, where the post-transfer balance might be less than anticipated, leading to balance inconsistencies. There might be subsequent checks for a second transfer, but an attacker might exploit leftover funds (such as those accidentally sent by another user) to gain unjustified credit. A practical solution is to gauge the balance prior and post-transfer, and consider the differential as the transferred amount, instead of the predefined amount.

*There are 5 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external {
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external {
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L109)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn;
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L117-L126)
### [LOW-10]<a name="low-10"></a> Public or external initialize functions should be protected with the initializer modifier
The initializer modifiers ensures two key aspects. A) Only an authorised account can initialize B) initialization can only be done once. Consider using such a modifier and in instances where initialization can be done more than once, the function name should be changed to reflect that.

*There are 1 instance(s) of this issue:*

```160:     function initialize( // <= FOUND
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0));
167:         assert(_core != address(0));
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L160)
### [LOW-11]<a name="low-11"></a> Loss of precision
Dividing by large integers in Solidity may cause a loss of precision due to the inherent limitations of fixed-point arithmetic in the Ethereum Virtual Machine (EVM). Solidity, like most programming languages, uses integer division, which truncates any decimal portion of the result. When dividing by large integers, the quotient can have a significant decimal component, but this is discarded, leading to an imprecise outcome. This loss of precision can have unintended consequences in smart contracts, especially in financial applications where accurate calculations are crucial. To mitigate this issue, developers should use appropriate scaling factors or specialized libraries that provide safe and precise arithmetic operations.

*There are 5 instance(s) of this issue:*

```151:     function minBorrow() external view returns (uint256) {
152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
153:     }
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L152-L152)

```80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) {
81:         uint256 creditMultiplier = ProfitManager(profitManager)
82:             .creditMultiplier();
83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
84:     }
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L83-L83)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) {
90:         uint256 creditMultiplier = ProfitManager(profitManager)
91:             .creditMultiplier();
92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
93:     }
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [256](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L256-L256)

```338:     function distribute(uint256 amount) external {
339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero");
340: 
341:         
342:         _burn(msg.sender, amount);
343: 
344:         
345:         uint256 _rebasingSharePrice = rebasingSharePrice();
346:         uint256 _totalRebasingShares = totalRebasingShares;
347:         uint256 _rebasingSupply = _shares2balance(
348:             _totalRebasingShares,
349:             _rebasingSharePrice,
350:             0,
351:             0
352:         );
353:         emit RebaseDistribution(
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
359: 
360:         
361:         
362:         if (_rebasingSupply != 0) {
363:             
364:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;
365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares; // <= FOUND
369:             __rebasingSharePrice = InterpolatedValue({
370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
375: 
376:             
377:             uint256 _unmintedRebaseRewards = unmintedRebaseRewards();
378:             __unmintedRebaseRewards = InterpolatedValue({
379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
385:         }
386:     }
```

*GitHub* : [368](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L368-L368)
### [LOW-12]<a name="low-12"></a> Function calls within for loops
Making function calls or external calls within loops in Solidity can lead to inefficient gas usage, potential bottlenecks, and increased vulnerability to attacks. Each function call or external call consumes gas, and when executed within a loop, the gas cost multiplies, potentially causing the transaction to run out of gas or exceed block gas limits. This can result in transaction failure or unpredictable behavior.

*There are 4 instance(s) of this issue:*

```443:        for (uint256 i = 0; i < gauges.length; ) {
444:             creditEarned += claimGaugeRewards(user, gauges[i]); // <= FOUND
445:             unchecked {
446:                 ++i;
447:             }
448:         }
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L444)

```280:        for (uint256 i = 0; i < size; ) {
281:             address gauge = gaugeList[i];
282:             uint256 weight = weights[i];
283:             weightsSum += weight;
284: 
285:             require(isGauge(gauge), "ERC20Gauges: invalid gauge"); // <= FOUND
286: 
287:             _incrementGaugeWeight(msg.sender, gauge, weight); // <= FOUND
288:             unchecked {
289:                 ++i;
290:             }
291:         }
```

*GitHub* : [280](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L280-L287)

```352:        for (uint256 i = 0; i < size; ) {
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i];
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight); // <= FOUND
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i;
363:             }
364:         }
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L352-L356)

```685:        for (uint256 i = 0; i < loanIds.length; i++) {
686:             _call(msg.sender, loanIds[i], _auctionHouse); // <= FOUND
687:         }
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L686)
### [LOW-13]<a name="low-13"></a> For loops in public or external functions should be avoided due to high gas costs and possible DOS
In Solidity, for loops can potentially cause Denial of Service (DoS) attacks if not handled carefully. DoS attacks can occur when an attacker intentionally exploits the gas cost of a function, causing it to run out of gas or making it too expensive for other users to call. Below are some scenarios where for loops can lead to DoS attacks: Nested for loops can become exceptionally gas expensive and should be used sparingly

*There are 4 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) {
442:         address[] memory gauges = GuildToken(guild).userGauges(user);
443:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
444:             creditEarned += claimGaugeRewards(user, gauges[i]);
445:             unchecked {
446:                 ++i;
447:             }
448:         }
449:     }
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L443)

```452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     {
463:         address _guild = guild;
464:         gauges = GuildToken(_guild).userGauges(user);
465:         creditEarned = new uint256[](gauges.length);
466: 
467:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
491:     }
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L467-L467)

```128:     function liveGauges() external view returns (address[] memory _liveGauges) {
129:         _liveGauges = new address[](
130:             _gauges.length() - _deprecatedGauges.length()
131:         );
132:         address[] memory allGauges = _gauges.values();
133:         uint256 j;
134:         for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) { // <= FOUND
135:             if (!_deprecatedGauges.contains(allGauges[i])) {
136:                 _liveGauges[j] = allGauges[i];
137:                 unchecked {
138:                     ++j;
139:                 }
140:             }
141:             unchecked {
142:                 ++i;
143:             }
144:         }
145:         return _liveGauges;
146:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L134-L134)
### [LOW-14]<a name="low-14"></a> No limits when setting min/max amounts
When settings min/max state variables, ensure there a require checks in place to prevent incorrect values from being set

*There are 12 instance(s) of this issue:*

```179:     function setMinBorrow(
180:         uint256 newValue
181:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
182:         _minBorrow = newValue;
183:         emit MinBorrowUpdate(block.timestamp, newValue);
184:     }
```

*GitHub* : [179](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L179-L179)

```319:     function setMintRatio(
320:         uint256 _mintRatio
321:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
322:         mintRatio = _mintRatio;
323:         emit MintRatioUpdate(block.timestamp, _mintRatio);
324:     }
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L319-L319)

```43:     function setMaxDelegates(
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
46:         _setMaxDelegates(newMax);
47:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L43)

```50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
54:         _setContractExceedMaxDelegates(account, canExceedMax);
55:     }
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```59:     function setMaxDelegates(
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
62:         _setMaxDelegates(newMax);
63:     }
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L59)

```66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
70:         _setContractExceedMaxDelegates(account, canExceedMax);
71:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```89:     function setMaxGauges(
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
92:         _setMaxGauges(max);
93:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L89)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
99:         _setCanExceedMaxGauges(who, can);
100:     }
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```846:     function setHardCap(
847:         uint256 _newValue
848:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
849:         params.hardCap = _newValue;
850:     }
```

*GitHub* : [846](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L846-L846)

```75:     function setBufferCap(
76:         uint128 newBufferCap
77:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
78:         _setBufferCap(newBufferCap);
79:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L75-L75)

```78:     function setVotingDelay(
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
81:         _setVotingDelay(newVotingDelay);
82:     }
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L78)

```293:     function updateMintRatio(address user, address term) external {
294:         
295:         (, UserStake memory userStake, bool slashed) = getRewards(user, term);
296: 
297:         
298:         if (userStake.stakeTime == 0 || slashed) return;
299: 
300:         
301:         uint256 guildBefore = uint256(userStake.guild);
302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;
303:         if (guildAfter > guildBefore) {
304:             uint256 guildAmount = guildAfter - guildBefore;
305:             RateLimitedMinter(rlgm).mint(address(this), guildAmount);
306:             GuildToken(guild).incrementGauge(term, guildAmount);
307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
308:         } else if (guildAfter < guildBefore) {
309:             uint256 guildAmount = guildBefore - guildAfter;
310:             GuildToken(guild).decrementGauge(term, guildAmount);
311:             RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
312:             GuildToken(guild).burn(guildAmount);
313:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
314:         }
315:     }
```

*GitHub* : [293](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L293-L293)
### [LOW-15]<a name="low-15"></a> Initialize functions do not emit an event
Emitting an event within initializer functions in Solidity is a best practice for providing transparency and traceability. Initializer functions set the initial state and values of an upgradeable contract. Emitting an event during initialization allows anyone to verify and audit the initial state of the contract via the transaction logs. This can be particularly useful for verifying the parameters set during initialization, tracking the contract's deployment, and troubleshooting or debugging. Therefore, developers should include an event emission in their initializer functions, providing a clear record of the contract's initialization and enhancing the contract's transparency and security.

*There are 1 instance(s) of this issue:*

```160:     function initialize( // <= FOUND
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0));
167:         assert(_core != address(0));
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L160)
### [LOW-16]<a name="low-16"></a> The function decimals() is not part of the ERC20 standard
The `decimals()` function in an ERC20 token contract is used to specify how many decimal places the token can be divided into. However, it should be used with caution because not all ERC20 token contracts implement `decimals()`, and the function isn't required by the ERC20 standard. Calling `decimals()` on a contract that doesn't implement it will result in a runtime error. Moreover, even when implemented, the returned value can be manipulated or artificially set, which may cause unexpected behavior. Therefore, always verify the decimal count independently if precision is crucial for your contract logic. When interacting with other ERC20 tokens, consider implementing safeguards or checks to handle potential errors from calling `decimals()`.

*There are 1 instance(s) of this issue:*

```75: 
76:         uint256 decimals = uint256(ERC20(_pegToken).decimals()); // <= FOUND
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L75-L76)
### [LOW-17]<a name="low-17"></a> Minting to the zero address should be avoided
Minting tokens to the zero address in Solidity is a potential pitfall that should be carefully guarded against. The zero address (0x0) is generally used as a default value and represents an uninitialized or null address. Minting tokens to this address effectively burns them, making them inaccessible and permanently removing them from the total supply. This could lead to unintended token loss if performed accidentally. To prevent this, it's important to include a check in the minting function to ensure that the target address is not the zero address. Using a library like OpenZeppelin's `Address` can provide utility functions like `requireNonZero`, which simplifies this check and enhances the security of the minting function.

*There are 5 instance(s) of this issue:*

```35:     function mint(
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) {
39:         _mint(to, amount);
40:     }
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L35)

```83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) {
87:         ERC20RebaseDistributor._mint(account, amount);
88:     }
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L83)

```268:     function mint(
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {
272:         _mint(to, amount);
273:     }
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L268)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L103)

```49:     function mint(
50:         address to,
51:         uint256 amount
52:     ) external onlyCoreRole(role) whenNotPaused {
53:         _depleteBuffer(amount); 
54:         IERC20Mintable(token).mint(to, amount); 
55:     }
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L49-L49)
### [LOW-18]<a name="low-18"></a> Missing zero address check in constructor
In Solidity, constructors often take address parameters to initialize important components of a contract, such as owner or linked contracts. However, without a check, there's a risk that an address parameter could be mistakenly set to the zero address (0x0). This could occur due to a mistake or oversight during contract deployment. A zero address in a crucial role can cause serious issues, as it cannot perform actions like a normal address, and any funds sent to it are irretrievable. Therefore, it's crucial to include a zero address check in constructors to prevent such potential problems. If a zero address is detected, the constructor should revert the transaction.

*There are 11 instance(s) of this issue:*

```19:     constructor(address coreAddress) { // <= FOUND
20:         _core = Core(coreAddress);
21:     }
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L19)

```30:     constructor(
31:         address _core, // <= FOUND
32:         address _timelock, // <= FOUND
33:         address _token, // <= FOUND
34:         uint256 initialVotingDelay,
35:         uint256 initialVotingPeriod,
36:         uint256 initialProposalThreshold,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Governor")
41:         GovernorVotes(IVotes(_token))
42:         GovernorTimelockControl(TimelockController(payable(_timelock)))
43:         GovernorSettings(
44:             initialVotingDelay,
45:             initialVotingPeriod,
46:             initialProposalThreshold
47:         )
48:     {
49:         _setQuorum(initialQuorum);
50:     }
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L31-L33)

```66:     constructor(
67:         address _core, // <= FOUND
68:         address _guildToken, // <= FOUND
69:         address _psm, // <= FOUND
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken;
73:         psm = _psm;
74:         quorum = _quorum;
75:     }
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L67-L69)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core, // <= FOUND
67:         address _timelock, // <= FOUND
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     {
83:         guildToken = _lendingTermReferences.guildToken;
84:         gaugeType = _gaugeType;
85:         profitManager = _lendingTermReferences.profitManager;
86:         auctionHouse = _lendingTermReferences.auctionHouse;
87:         creditMinter = _lendingTermReferences.creditMinter;
88:         creditToken = _lendingTermReferences.creditToken;
89:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L66-L67)

```106:     constructor(address _core) CoreRef(_core) { // <= FOUND
107:         emit MinBorrowUpdate(block.timestamp, 100e18);
108:     }
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L106-L106)

```32:     constructor(
33:         address _core, // <= FOUND
34:         address initialTimelock, // <= FOUND
35:         address _token, // <= FOUND
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     {
42:         _setQuorum(initialQuorum);
43:         _updateTimelock(initialTimelock);
44:     }
```

*GitHub* : [33](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L33-L35)

```43:     constructor(
44:         address _core, // <= FOUND
45:         address _profitManager // <= FOUND
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager;
52:     }
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L44-L45)

```56:     constructor(
57:         address _core, // <= FOUND
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) {
61:         require(_midPoint < _auctionDuration, "AuctionHouse: invalid params");
62:         midPoint = _midPoint;
63:         auctionDuration = _auctionDuration;
64:     }
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L57-L57)

```65:     constructor(
66:         address _core, // <= FOUND
67:         address _profitManager, // <= FOUND
68:         address _credit, // <= FOUND
69:         address _pegToken // <= FOUND
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager;
72:         credit = _credit;
73:         pegToken = _pegToken;
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L66-L69)

```88:     constructor(
89:         address _core, // <= FOUND
90:         address _profitManager, // <= FOUND
91:         address _credit, // <= FOUND
92:         address _guild, // <= FOUND
93:         address _rlgm, // <= FOUND
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager;
98:         credit = _credit;
99:         guild = _guild;
100:         rlgm = _rlgm;
101:         mintRatio = _mintRatio;
102:         rewardRatio = _rewardRatio;
103:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L89-L93)

```30:     constructor(
31:         address _core, // <= FOUND
32:         address _token, // <= FOUND
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     {
41:         token = _token;
42:         role = _role;
43:     }
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L31-L32)
### [LOW-19]<a name="low-19"></a> Constant decimal values
The use of fixed decimal values such as 1e18 or 1e8 in Solidity contracts can lead to inaccuracies, bugs, and vulnerabilities, particularly when interacting with tokens having different decimal configurations. Not all ERC20 tokens follow the standard 18 decimal places, and assumptions about decimal places can lead to miscalculations.

Resolution: Always retrieve and use the `decimals()` function from the token contract itself when performing calculations involving token amounts. This ensures that your contract correctly handles tokens with any number of decimal places, mitigating the risk of numerical errors or under/overflows that could jeopardize contract integrity and user funds.

*There are 34 instance(s) of this issue:*

```127: 
128:         require(
129:             params.interestRate < 1e18,  // <= FOUND
130:             "LendingTermOnboarding: invalid interestRate"
131:         );
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L129-L129)

```138: 
139:         require(
140:             params.minPartialRepayPercent < 1e18,  // <= FOUND
141:             "LendingTermOnboarding: invalid minPartialRepayPercent"
142:         );
```

*GitHub* : [140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L140-L140)

```143: 
144:         require(
145:             params.openingFee <= 0.1e18,  // <= FOUND
146:             "LendingTermOnboarding: invalid openingFee"
147:         );
```

*GitHub* : [145](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L145-L145)

```87: 
96:     uint256 public creditMultiplier = 1e18; // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L96-L96)

```152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L152-L152)

```207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18, // <= FOUND
209:             "GuildToken: invalid config"
210:         );
```

*GitHub* : [208](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L208-L208)

```246:         creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit; // <= FOUND
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L246-L246)

```394:                         _gaugeProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [394](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L394-L394)

```396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) / // <= FOUND
399:                         _gaugeWeight;
```

*GitHub* : [398](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L398-L398)

```394:             _gaugeProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [394](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L394-L394)

```425:             _userGaugeProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L425-L425)

```429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [429](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L429-L429)

```394:                 _gaugeProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [394](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L394-L394)

```476:                 _userGaugeProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [476](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L476-L476)

```483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [483](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L483-L483)

```218:         uint256 interest = (borrowAmount *
219:             params.interestRate *
220:             (block.timestamp - borrowTime)) /
221:             YEAR /
222:             1e18; // <= FOUND
```

*GitHub* : [222](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L222-L222)

```226:             loanDebt += (borrowAmount * _openingFee) / 1e18; // <= FOUND
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L226-L226)

```305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) / // <= FOUND
306:             1e18; // <= FOUND
```

*GitHub* : [305](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L305-L306)

```383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18; // <= FOUND
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L387-L387)

```510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt;  // <= FOUND
```

*GitHub* : [510](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L510-L510)

```516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [516](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L516-L516)

```518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [518](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L518-L518)

```523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18, // <= FOUND
525:             "LendingTerm: repay below min"
526:         );
```

*GitHub* : [524](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L524-L524)

```83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L83-L83)

```92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)

```26:     
27:     uint256 public constant MIN_STAKE = 1e18; // <= FOUND
```

*GitHub* : [27](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L27-L27)

```134:         uint256 guildAmount = (_mintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L134-L134)

```175: 
176:         
177:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) / // <= FOUND
178:             userStake.credit; 
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L177-L177)

```177:         uint256 guildAmount = (userMintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L177-L177)

```244: 
245:         if (_profitIndex == 0) _profitIndex = 1e18; // <= FOUND
```

*GitHub* : [245](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L245-L245)

```245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [245](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L245-L245)

```250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) / // <= FOUND
251:                 1e18; // <= FOUND
```

*GitHub* : [250](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L250-L251)

```252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18; // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L252-L252)

```302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18; // <= FOUND
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L302-L302)
### [LOW-20]<a name="low-20"></a> Revert on Transfer to the Zero Address
Many ERC-20 and ERC-721 token contracts implement a safeguard that reverts transactions which attempt to transfer tokens to the zero address. This is because such transfers are often the result of programming errors. The OpenZeppelin library, a popular choice for implementing these standards, includes this safeguard. For token contract developers who want to avoid unintentional transfers to the zero address, it's good practice to include a condition that reverts the transaction if the recipient's address is the zero address.

*There are 20 instance(s) of this issue:*

```489:     function transferFrom( // <= FOUND
490:         address from,
491:         address to,
492:         uint256 amount
493:     ) public virtual override returns (bool) {
494:         _decrementWeightUntilFree(from, amount);
495:         return super.transferFrom(from, to, amount); // <= FOUND
496:     }
```

*GitHub* : [489](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L489-L495)

```416:     function transferFrom( // <= FOUND
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) {
421:         _decrementVotesUntilFree(from, amount);
422:         return super.transferFrom(from, to, amount); // <= FOUND
423:     }
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L422)

```646:     function transferFrom( // <= FOUND
647:         address from,
648:         address to,
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         
652:         
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
657:             rebasingStateTo.isRebasing == 1)
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) {
661:             uint256 shares = uint256(rebasingStateFrom.nShares);
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount;
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         
678:         bool success = ERC20.transferFrom(from, to, amount); // <= FOUND
679: 
680:         
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) {
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
689:             sharesDelta -= int256(sharesSpent);
690:             rebasingState[from] = RebasingState({
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
```

*GitHub* : [646](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L646-L678)

```125:     function transferFrom( // <= FOUND
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     {
134:         _decrementVotesUntilFree(from, amount); 
135:         return ERC20RebaseDistributor.transferFrom(from, to, amount); // <= FOUND
136:     }
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L135)

```302:     function transferFrom( // <= FOUND
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     {
312:         _decrementWeightUntilFree(from, amount);
313:         _decrementVotesUntilFree(from, amount);
314:         return ERC20.transferFrom(from, to, amount); // <= FOUND
315:     }
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L314)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal {
453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0");
454: 
455:         Loan storage loan = loans[loanId];
456: 
457:         
458:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
459:         require(loan.closeTime == 0, "LendingTerm: loan closed");
460:         require(loan.callTime == 0, "LendingTerm: loan called");
461: 
462:         
463:         loans[loanId].collateralAmount += collateralToAdd;
464: 
465:         
466:         IERC20(params.collateralToken).safeTransferFrom( // <= FOUND
467:             borrower,
468:             address(this),
469:             collateralToAdd
470:         );
471: 
472:         
473:         emit LoanAddCollateral(
474:             block.timestamp,
475:             loanId,
476:             borrower,
477:             collateralToAdd
478:         );
479:     }
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L466)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom( // <= FOUND
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L546)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom( // <= FOUND
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer( // <= FOUND
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L618)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom( // <= FOUND
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer( // <= FOUND
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L813)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer( // <= FOUND
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L371)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount);
486:         return super.transfer(to, amount); // <= FOUND
487:     }
```

*GitHub* : [481](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L481-L486)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) {
412:         _decrementVotesUntilFree(msg.sender, amount);
413:         return super.transfer(to, amount); // <= FOUND
414:     }
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L413)

```553:     function transfer(
554:         address to,
555:         uint256 amount
556:     ) public virtual override returns (bool) {
557:         
558:         
559:         RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
560:         RebasingState memory rebasingStateTo = rebasingState[to];
561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
562:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
563:             rebasingStateTo.isRebasing == 1)
564:             ? rebasingSharePrice()
565:             : 0; 
566:         if (rebasingStateFrom.isRebasing == 1) {
567:             uint256 shares = uint256(rebasingStateFrom.nShares);
568:             uint256 rebasedBalance = _shares2balance(
569:                 shares,
570:                 _rebasingSharePrice,
571:                 0,
572:                 fromBalanceBefore
573:             );
574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
575:             if (mintAmount != 0) {
576:                 ERC20._mint(msg.sender, mintAmount);
577:                 fromBalanceBefore += mintAmount;
578:                 decreaseUnmintedRebaseRewards(mintAmount);
579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount);
580:             }
581:         }
582: 
583:         
584:         bool success = ERC20.transfer(to, amount); // <= FOUND
585: 
586:         
587:         int256 sharesDelta;
588:         if (rebasingStateFrom.isRebasing == 1) {
589:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
590:             uint256 fromSharesAfter = _balance2shares(
591:                 fromBalanceAfter,
592:                 _rebasingSharePrice
593:             );
594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
595:             sharesDelta -= int256(sharesSpent);
596:             rebasingState[msg.sender] = RebasingState({
597:                 isRebasing: 1,
598:                 nShares: uint248(fromSharesAfter)
599:             });
600:         }
601: 
602:         
```

*GitHub* : [553](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L553-L584)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     {
121:         _decrementVotesUntilFree(msg.sender, amount); 
122:         return ERC20RebaseDistributor.transfer(to, amount); // <= FOUND
123:     }
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L122)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     {
297:         _decrementWeightUntilFree(msg.sender, amount);
298:         _decrementVotesUntilFree(msg.sender, amount);
299:         return ERC20.transfer(to, amount); // <= FOUND
300:     }
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L299)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L142)
### [LOW-21]<a name="low-21"></a> Use of deprecated Chainlink functions
Utilizing deprecated Chainlink functions within a smart contract can pose significant risks and challenges. Deprecated functions are those that the Chainlink development team has phased out, often due to updated and more secure alternatives. These outdated functions may not include the latest security enhancements, introducing potential vulnerabilities. Furthermore, they might not be compatible with newer versions of the libraries or other parts of the Chainlink ecosystem, potentially causing operational issues. To ensure the security and seamless operation of your smart contracts, it's highly recommended to update your code to use the most recent and officially supported Chainlink functions.

*There are 14 instance(s) of this issue:*

```269: 
270:         
271:         
272:         uint256 timelockOperationTimestamp = TimelockController(
273:             payable(timelock)
274:         ).getTimestamp(queueid); // <= FOUND
```

*GitHub* : [274](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L274-L274)

```317:         
318:         uint256 timelockExecutionTime = TimelockController(payable(timelock))
319:             .getTimestamp(timelockId); // <= FOUND
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L319-L319)

```102:         uint32 targetTimestamp; // <= FOUND
```

*GitHub* : [102](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L102-L102)

```110:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
111:             lastValue: uint224(START_REBASING_SHARE_PRICE), 
112:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND
113:             targetValue: uint224(START_REBASING_SHARE_PRICE) 
114:         });
```

*GitHub* : [112](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L112-L112)

```120:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
121:             lastValue: 0,
122:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND
123:             targetValue: 0
124:         });
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L122-L122)

```137:         uint256 targetTimestamp = uint256(val.targetTimestamp);  // <= FOUND
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L137-L137)

```141: 
142:         
143:         if (block.timestamp >= targetTimestamp) { // <= FOUND
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L143-L143)

```148:             return
149:                 lastValue +
150:                 (delta * elapsed) /
151:                 (targetTimestamp - lastTimestamp); // <= FOUND
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L151-L151)

```191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),  // <= FOUND
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
```

*GitHub* : [193](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L193-L193)

```197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND
200:                 targetValue: 0
201:             });
```

*GitHub* : [199](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L199-L199)

```219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), 
221:                 targetTimestamp: val.targetTimestamp,  // <= FOUND
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) 
223:             });
```

*GitHub* : [221](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L221-L221)

```232:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
233:             lastValue: SafeCastLib.safeCastTo224(
234:                 _unmintedRebaseRewards - amount
235:             ), 
236:             targetTimestamp: val.targetTimestamp,  // <= FOUND
237:             targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount) 
238:         });
```

*GitHub* : [236](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L236-L236)

```370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp), // <= FOUND
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
```

*GitHub* : [372](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L372-L372)

```379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp), // <= FOUND
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
```

*GitHub* : [381](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L381-L381)
### [LOW-22]<a name="low-22"></a> Calling internal _grantRole bypasses role access checks
OpenZeppelin's `AccessControl` library is designed with security in mind, encapsulating common access control patterns. Within this library, the `grantRole` function is public and ensures proper access checks before the role is granted. However, by calling the internal `_grantRole` function directly, developers bypass these pre-defined access controls. While this may be intentional, allowing for custom access controls, it risks introducing vulnerabilities if not handled with caution. Bypassing the native checks goes against the library's design philosophy, which emphasizes secure defaults. To uphold security, developers should consistently use public functions provided by OpenZeppelin, or, if choosing to call internal functions, ensure they implement and rigorously test their own access controls.

*There are 1 instance(s) of this issue:*

```41:     function _grantRole(bytes32 role, address account) internal override {} // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)
### [LOW-23]<a name="low-23"></a> Redundant use of ERC20Burnable
ERC20Burnable is an extension of the basic ERC20 token that introduces a burn mechanism, allowing holders to destroy their tokens. Integrating ERC20Burnable into a protocol that already has an exposed `_burn` function might be redundant and can lead to an increased attack surface. Multiple interfaces with similar functionality can confuse developers, potentially leading to coding errors. Additionally, attackers get more avenues to probe for vulnerabilities. To maintain the integrity and security of the system, it's advisable to avoid such overlap. Developers should assess the necessity of including ERC20Burnable and consider relying solely on the existing `_burn` mechanism, ensuring a streamlined and secure implementation.

*There are 2 instance(s) of this issue:*

```18: contract CreditToken is
19:     CoreRef,
20:     ERC20Burnable, // <= FOUND
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: 
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L20)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)
### [LOW-24]<a name="low-24"></a> Direct supportsInterface() calls may cause caller to revert
When invoking supportsInterface() on a contract, if the addressed contract doesn't adhere to the ERC-165 standard, the call may revert. This potential reversion isn't solely because of non-compliance; a contract could be designed maliciously to consume the entire transaction's gas. To circumvent these pitfalls, opt for a low-level staticcall() when calling supportsInterface(), setting a defined gas limit, and subsequently evaluating the return code. Alternatively, leverage OpenZeppelin's ERC165Checker.supportsInterface() for a safer approach.

*There are 1 instance(s) of this issue:*

```171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) {
174:         return super.supportsInterface(interfaceId); // <= FOUND
175:     }
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L171-L174)
### [LOW-25]<a name="low-25"></a> Unbounded loop may run out of gas
Unbounded loops in smart contracts pose a risk because they iterate over an unknown number of elements, potentially consuming all available gas for a transaction. This can result in unintended transaction failures. Gas consumption increases linearly with the number of iterations, and if it surpasses the gas limit, the transaction reverts, wasting the gas spent. To mitigate this, developers should either set a maximum limit on loop iterations.

*There are 5 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L96)

```439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) {
442:         address[] memory gauges = GuildToken(guild).userGauges(user);
443:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
444:             creditEarned += claimGaugeRewards(user, gauges[i]);
445:             unchecked {
446:                 ++i;
447:             }
448:         }
449:     }
```

*GitHub* : [439](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L439-L443)

```452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     {
463:         address _guild = guild;
464:         gauges = GuildToken(_guild).userGauges(user);
465:         creditEarned = new uint256[](gauges.length);
466: 
467:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
491:     }
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L452-L467)

```128:     function liveGauges() external view returns (address[] memory _liveGauges) { // <= FOUND
129:         _liveGauges = new address[](
130:             _gauges.length() - _deprecatedGauges.length()
131:         );
132:         address[] memory allGauges = _gauges.values();
133:         uint256 j;
134:         for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) { // <= FOUND
135:             if (!_deprecatedGauges.contains(allGauges[i])) {
136:                 _liveGauges[j] = allGauges[i];
137:                 unchecked {
138:                     ++j;
139:                 }
140:             }
141:             unchecked {
142:                 ++i;
143:             }
144:         }
145:         return _liveGauges;
146:     }
```

*GitHub* : [128](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L128-L134)

```683:     function callMany(bytes32[] memory loanIds) public { // <= FOUND
684:         address _auctionHouse = refs.auctionHouse;
685:         for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
688:     }
```

*GitHub* : [683](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L683-L685)
### [LOW-26]<a name="low-26"></a> No limits when setting price values
When setting price values without defined upper or lower bounds, it can lead to unpredictable behavior or potential vulnerabilities. For instance, overly high or low prices could be set maliciously or accidentally, disrupting platform functionality or enabling manipulative profit schemes. It's crucial to enforce constraints on price values to ensure they remain within a reasonable range. As a solution, implement checks to cap the minimum and maximum permissible price values. Additionally, consider implementing a governance mechanism or multi-signature approval process for significant price adjustments, ensuring an added layer of security and oversight.

*There are 1 instance(s) of this issue:*

```168:     function updateTotalRebasingShares( // <= FOUND
169:         uint256 currentRebasingSharePrice, // <= FOUND
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
196:             __unmintedRebaseRewards = InterpolatedValue({
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             });
202:             return;
203:         }
204: 
205:         
206:         
207:         
208:         
209:         
210:         InterpolatedValue memory val = __rebasingSharePrice; // <= FOUND
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice; // <= FOUND
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice + // <= FOUND
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
218:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice),  // <= FOUND
221:                 targetTimestamp: val.targetTimestamp, 
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice)  // <= FOUND
223:             });
224:         }
225:     }
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L222)
### [LOW-27]<a name="low-27"></a> Prefer skip over revert model in iteration
It is preferable to skip operations on an array index when a condition is not met rather than reverting the whole transaction as reverting can introduce the possiblity of malicous actors purposefully introducing array objects which fail conditional checks within for/while loops so group operations fail. As such it is recommended to simply skip such array indices over reverting unless there is a valid security or logic reason behind not doing so.

*There are 1 instance(s) of this issue:*

*GitHub* :
### [LOW-28]<a name="low-28"></a> Missing contract-existence checks before low-level calls
Low-level calls in Solidity, when made to addresses without contract code, don't fail but return a successful status. This behavior can be misleading, leading to unintended consequences in dApps. Ignoring this can potentially mean acting on false positive results. To address this, apart from the conventional zero-address check, developers should verify the existence of contract code at the target address by ensuring that the code length at the specified address (`<address>.code.length`) is greater than zero. By doing so, it provides a more robust validation before executing low-level calls, safeguarding against unintentional interactions with empty addresses.

*There are 1 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L114)
### [LOW-29]<a name="low-29"></a> Use Unchecked for Divisions on Constant or Immutable Values
When performing divisions in Solidity, the operation costs gas and includes a check for division by zero. However, if you are dividing by a constant or an immutable value that is guaranteed to be non-zero, this check becomes unnecessary, consuming extra gas without adding safety.

**Resolution**: Utilize the `unchecked` block for divisions involving constant or immutable values that are assuredly non-zero. This bypasses the additional safety checks, optimizing gas usage. Ensure thorough testing and code reviews are conducted to verify the non-zero condition of the denominator, preventing any potential division by zero errors and maintaining contract safety.

*There are 8 instance(s) of this issue:*

```141:             collateralReceived = (_collateralAmount * elapsed) / midPoint; // <= FOUND
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L141-L141)

```152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L152-L152)

```332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply; // <= FOUND
```

*GitHub* : [333](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L333-L333)

```230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L230-L230)

```357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier; // <= FOUND
```

*GitHub* : [358](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L358-L358)

```712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [713](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L713-L713)

```83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L83-L83)

```92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)
### [LOW-30]<a name="low-30"></a> Constructors missing validation
In Solidity, when values are being assigned in constructors to unsigned or integer variables, it's crucial to ensure the provided values adhere to the protocol's specific operational boundaries as laid out in the project specifications and documentation. If the constructors lack appropriate validation checks, there's a risk of setting state variables with values that could cause unexpected and potentially detrimental behavior within the contract's operations, violating the intended logic of the protocol. This can compromise the contract's security and impact the maintainability and reliability of the system. In order to avoid such issues, it is recommended to incorporate rigorous validation checks in constructors. These checks should align with the project's defined rules and constraints, making use of Solidity's built-in require function to enforce these conditions. If the validation checks fail, the require function will cause the transaction to revert, ensuring the integrity and adherence to the protocol's expected behavior.

*There are 7 instance(s) of this issue:*

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken; // <= FOUND ' = _guildToken;'
73:         psm = _psm; // <= FOUND ' = _psm;'
74:         quorum = _quorum; // <= FOUND ' = _quorum;'
75:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L74)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     {
83:         guildToken = _lendingTermReferences.guildToken;
84:         gaugeType = _gaugeType; // <= FOUND ' = _gaugeType;'
85:         profitManager = _lendingTermReferences.profitManager;
86:         auctionHouse = _lendingTermReferences.auctionHouse;
87:         creditMinter = _lendingTermReferences.creditMinter;
88:         creditToken = _lendingTermReferences.creditToken;
89:     }
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L84)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager; // <= FOUND ' = _profitManager;'
52:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L51)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager; // <= FOUND ' = _profitManager;'
72:         credit = _credit; // <= FOUND ' = _credit;'
73:         pegToken = _pegToken; // <= FOUND ' = _pegToken;'
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L73)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager; // <= FOUND ' = _profitManager;'
98:         credit = _credit; // <= FOUND ' = _credit;'
99:         guild = _guild; // <= FOUND ' = _guild;'
100:         rlgm = _rlgm; // <= FOUND ' = _rlgm;'
101:         mintRatio = _mintRatio; // <= FOUND ' = _mintRatio;'
102:         rewardRatio = _rewardRatio; // <= FOUND ' = _rewardRatio;'
103:     }
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L102)

```30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     {
41:         token = _token; // <= FOUND ' = _token;'
42:         role = _role; // <= FOUND ' = _role;'
43:     }
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L30-L42)

```40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) {
45:         lastBufferUsedTime = block.timestamp.safeCastTo32();
46: 
47:         _setBufferCap(_bufferCap);
48:         bufferStored = _bufferCap; // <= FOUND ' = _bufferCap;'
49: 
50:         require(
51:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
52:             "RateLimited: rateLimitPerSecond too high"
53:         );
54:         _setRateLimitPerSecond(_rateLimitPerSecond);
55: 
56:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
57:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L40-L48)
### [LOW-31]<a name="low-31"></a> Functions calling contracts/addresses with transfer hooks are missing reentrancy guards
While adherence to the check-effects-interaction pattern is commendable, the absence of a reentrancy guard in functions, especially where transfer hooks might be present, can expose the protocol users to risks of read-only reentrancies. Such reentrancy vulnerabilities can be exploited to execute malicious actions even without altering the contract state. Without a reentrancy guard, the only potential mitigation would be to blocklist the entire protocol - an extreme and disruptive measure. Therefore, incorporating a reentrancy guard into these functions is vital to bolster security, as it helps protect against both traditional reentrancy attacks and read-only reentrancies, ensuring robust and safe protocol operations.

*There are 9 instance(s) of this issue:*

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L142)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263)
### [LOW-32]<a name="low-32"></a> Inconsistent checks of address params against address(0)
Only some address parameters are checked against address(0), to ensure consistency ensure all address parameters are checked.

*There are 4 instance(s) of this issue:*

```156:     function initializeReferences(
157:         address _credit, // <= FOUND 'address _credit'
158:         address _guild, // <= FOUND 'address _guild'
159:         address _psm // <= FOUND 'address _psm'
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
161:         assert(
162:             credit == address(0) && guild == address(0) && psm == address(0)
163:         );
164:         credit = _credit;
165:         guild = _guild;
166:         psm = _psm;
167:     }
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L159)

```290:     function _delegate(
291:         address delegator, // <= FOUND 'address delegator'
292:         address newDelegatee // <= FOUND 'address newDelegatee'
293:     ) internal virtual {
294:         uint256 count = delegateCount(delegator);
295: 
296:         
297:         require(count < 2, "ERC20MultiVotes: delegation error");
298: 
299:         address oldDelegatee;
300:         
301:         if (count == 1) {
302:             oldDelegatee = _delegates[delegator].at(0);
303:             _undelegate(
304:                 delegator,
305:                 oldDelegatee,
306:                 _delegatesVotesCount[delegator][oldDelegatee]
307:             );
308:         }
309: 
310:         
311:         if (newDelegatee != address(0)) {
312:             _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));
313:         }
314:         emit DelegateChanged(delegator, oldDelegatee, newDelegatee);
315:     }
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L292)

```317:     function _incrementDelegation(
318:         address delegator, // <= FOUND 'address delegator'
319:         address delegatee, // <= FOUND 'address delegatee'
320:         uint256 amount
321:     ) internal virtual {
322:         
323:         uint256 free = freeVotes(delegator);
324:         require(
325:             delegatee != address(0) && free >= amount,
326:             "ERC20MultiVotes: delegation error"
327:         );
328: 
329:         bool newDelegate = _delegates[delegator].add(delegatee); 
330:         require(
331:             !newDelegate ||
332:                 delegateCount(delegator) <= maxDelegates ||
333:                 canContractExceedMaxDelegates[delegator],
334:             "ERC20MultiVotes: delegation error"
335:         );
336: 
337:         _delegatesVotesCount[delegator][delegatee] += amount;
338:         userDelegatedVotes[delegator] += amount;
339: 
340:         emit Delegation(delegator, delegatee, amount);
341:         _writeCheckpoint(delegatee, _add, amount);
342:     }
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L319)

```471:     function delegateBySig(
472:         address delegatee, // <= FOUND 'address delegatee'
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L472)
### [LOW-33]<a name="low-33"></a> Division in comparison
To ensure accuracy in comparisons within programming, especially when dealing with integers, it's often more efficient to use multiplication rather than division. This approach stems from the fact that division operations are generally slower and more complex than multiplication. And in the context of solidity they can cause precision errors.

Suppose you want to compare if a/b is greater than c/d (where a, b, c, and d are integers). Instead of performing division, which is prone to precision errors, you can cross-multiply to avoid division. The comparison a/b > c/d is equivalent to a*d > b*c. This way, you only use multiplication, which is faster and avoids potential inaccuracies or complexities associated with division.

*There are 1 instance(s) of this issue:*

```523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18, // <= FOUND
525:             "LendingTerm: repay below min"
526:         );
```

*GitHub* : [523](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L523-L524)
### [LOW-34]<a name="low-34"></a> Functions calling contracts/addresses with transfer hooks are missing reentrancy guards
While adherence to the check-effects-interaction pattern is commendable, the absence of a reentrancy guard in functions, especially where transfer hooks might be present, can expose the protocol users to risks of read-only reentrancies. Such reentrancy vulnerabilities can be exploited to execute malicious actions even without altering the contract state. Without a reentrancy guard, the only potential mitigation would be to blocklist the entire protocol - an extreme and disruptive measure. Therefore, incorporating a reentrancy guard into these functions is vital to bolster security, as it helps protect against both traditional reentrancy attacks and read-only reentrancies, ensuring robust and safe protocol operations.

*There are 9 instance(s) of this issue:*

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer( // <= FOUND
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L371)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer( // <= FOUND
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L546)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer( // <= FOUND
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L618)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer( // <= FOUND
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L813)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L142)### NC Risk Issues


  ### [NC-01]<a name="nc-01"></a> Emits without msg.sender parameter 
In Solidity, when `msg.sender` plays a crucial role in a function's logic, it's important for transparency and auditability that any events emitted by this function include `msg.sender` as a parameter. This practice enhances the traceability and accountability of transactions, allowing users and external observers to easily track who initiated a particular action. Including `msg.sender` in event logs helps in creating a clear and verifiable record of interactions with the contract, thereby increasing user trust and facilitating easier debugging and analysis of contract behavior. It's a key aspect of writing clear, transparent, and user-friendly smart contracts.

*There are 9 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external {
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer); // <= FOUND
256:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L252-L255)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external {
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer); // <= FOUND
264:     }
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L260-L263)

```123:     function notifyGaugeLoss(address gauge) external {
124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
125: 
126:         
127:         lastGaugeLoss[gauge] = block.timestamp;
128:         emit GaugeLoss(gauge, block.timestamp); // <= FOUND
129:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L128)

```166:     function bid(bytes32 loanId) external {
167:         
168:         
169:         (uint256 collateralReceived, uint256 creditAsked) = getBidDetail(
170:             loanId
171:         );
172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0");
173: 
174:         
175:         auctions[loanId].endTime = block.timestamp;
176:         nAuctionsInProgress--;
177: 
178:         
179:         address _lendingTerm = auctions[loanId].lendingTerm;
180:         LendingTerm(_lendingTerm).onBid(
181:             loanId,
182:             msg.sender, // <= FOUND
183:             auctions[loanId].collateralAmount - collateralReceived, 
184:             collateralReceived, 
185:             creditAsked 
186:         );
187: 
188:         
189:         emit AuctionEnd( // <= FOUND
190:             block.timestamp,
191:             loanId,
192:             LendingTerm(_lendingTerm).collateralToken(),
193:             collateralReceived, 
194:             creditAsked 
195:         );
196:     }
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L182-L189)

```202:     function forgive(bytes32 loanId) external {
203:         
204:         
205:         (, uint256 creditAsked) = getBidDetail(loanId);
206:         require(creditAsked == 0, "AuctionHouse: ongoing auction");
207: 
208:         
209:         auctions[loanId].endTime = block.timestamp;
210:         nAuctionsInProgress--;
211: 
212:         
213:         address _lendingTerm = auctions[loanId].lendingTerm;
214:         LendingTerm(_lendingTerm).onBid(
215:             loanId,
216:             msg.sender, // <= FOUND
217:             0, 
218:             0, 
219:             0 
220:         );
221: 
222:         
223:         emit AuctionEnd( // <= FOUND
224:             block.timestamp,
225:             loanId,
226:             LendingTerm(_lendingTerm).collateralToken(),
227:             0, 
228:             0 
229:         );
230:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L216-L223)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut); // <= FOUND
112:     }
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L109-L111)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn); // <= FOUND
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut);
143:         emit Redeem(block.timestamp, to, amountIn, amountOut); // <= FOUND
144:     }
```

*GitHub* : [140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L140-L143)

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender, // <= FOUND
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake; // <= FOUND
152: 
153:         
154:         emit Stake(block.timestamp, term, amount); // <= FOUND
155:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L117-L154)

```158:     function unstake(address term, uint256 amount) external {
159:         
160:         (, UserStake memory userStake, bool slashed) = getRewards(
161:             msg.sender, // <= FOUND
162:             term
163:         );
164: 
165:         
166:         if (slashed) return;
167: 
168:         
169:         require(
170:             amount != 0 && userStake.credit >= amount,
171:             "SurplusGuildMinter: invalid amount"
172:         );
173: 
174:         
175:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /
176:             userStake.credit; 
177:         uint256 guildAmount = (userMintRatio * amount) / 1e18;
178: 
179:         if (amount == userStake.credit) guildAmount = userStake.guild;
180: 
181:         userStake.credit -= SafeCastLib.safeCastTo128(amount);
182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);
183: 
184:         if (userStake.credit == 0) {
185:             userStake.stakeTime = 0;
186:             userStake.lastGaugeLoss = 0;
187:             userStake.profitIndex = 0;
188:         } else {
189:             
190:             
191:             require(
192:                 userStake.credit >= MIN_STAKE,
193:                 "SurplusGuildMinter: remaining stake below min"
194:             );
195:         }
196:         _stakes[msg.sender][term] = userStake; // <= FOUND
197: 
198:         
199:         ProfitManager(profitManager).withdrawFromTermSurplusBuffer(
200:             term,
201:             msg.sender, // <= FOUND
202:             amount
203:         );
204: 
205:         
206:         GuildToken(guild).decrementGauge(term, guildAmount);
207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
208:         GuildToken(guild).burn(guildAmount);
209: 
210:         
211:         emit Unstake(block.timestamp, term, amount); // <= FOUND
212:     }
```

*GitHub* : [161](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L161-L211)
### [NC-02]<a name="nc-02"></a> Some if-statement can be converted to a ternary 
Improving code readability and compactness is an integral part of optimal programming practices. The use of ternary operators in place of if-else conditions is one such measure. Ternary operators allow us to write conditional statements in a more concise manner, thereby enhancing readability and simplicity. They follow the syntax `condition ? exprIfTrue : exprIfFalse`, which interprets as "if the condition is true, evaluate to `exprIfTrue`, else evaluate to `exprIfFalse`". By adopting this approach, we make our code more streamlined and intuitive, which could potentially aid in better understanding and maintenance of the codebase.

*There are 16 instance(s) of this issue:*

```138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true; // <= FOUND
140:         }
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L138-L139)

```393:         if (_gaugeProfitIndex == 0) {
394:             _gaugeProfitIndex = 1e18; // <= FOUND
395:         }
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L393-L394)

```424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18; // <= FOUND
426:         }
```

*GitHub* : [424](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L424-L425)

```210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight; // <= FOUND
212:         }
```

*GitHub* : [210](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L210-L211)

```374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {
375:             ckpts[pos - 1].votes = newWeight.safeCastTo224(); // <= FOUND
376:         }
```

*GitHub* : [374](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L374-L375)

```175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta); // <= FOUND
177:         }
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L175-L176)

```269:         if (rebasedBalance < minBalance) {
270:             rebasedBalance = minBalance; // <= FOUND
271:         }
```

*GitHub* : [269](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L269-L270)

```249:         if (getUserGaugeWeight[user][gauge] == 0) {
250:             lastGaugeLossApplied[gauge][user] = block.timestamp; // <= FOUND
251:         }
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L249-L250)

```225:         if (_openingFee != 0) {
226:             loanDebt += (borrowAmount * _openingFee) / 1e18; // <= FOUND
227:         }
```

*GitHub* : [225](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L225-L226)

```413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp; // <= FOUND
415:         }
```

*GitHub* : [413](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L413-L414)

```229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true; // <= FOUND
231:         }
```

*GitHub* : [229](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L229-L230)

```253:             if (slashed) {
254:                 guildReward = 0; // <= FOUND
255:             }
```

*GitHub* : [253](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L253-L254)

```287:         if (updateState) {
288:             _stakes[user][term] = userStake; // <= FOUND
289:         }
```

*GitHub* : [287](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L287-L288)

```393:                    if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18; // <= FOUND
395:                     }
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L393-L394)

```475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18; // <= FOUND
477:             }
```

*GitHub* : [475](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L475-L476)

```112:            if (ckpts[mid].fromBlock > blockNumber) {
113:                 high = mid; // <= FOUND
114:             }
```

*GitHub* : [112](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L112-L113)
### [NC-03]<a name="nc-03"></a> Local variable shadowing 
Local variable shadowing in Solidity creates confusion by allowing a local variable within a function to share the same name as a state variable or another local variable in an outer scope. This confusion can lead to errors in code interpretation and execution. It's especially problematic when maintaining or modifying the code, as it may inadvertently introduce bugs. To resolve this issue, developers should avoid variable shadowing by using unique and descriptive names for variables. Leveraging development tools and linters that warn about shadowing can also be helpful. By paying careful attention to variable naming and being aware of shadowing, developers can create more readable and robust code.

*There are 12 instance(s) of this issue:*

```270:     function debtCeiling(
271:         int256 gaugeWeightDelta
272:     ) public view returns (uint256) {
273:         address _guildToken = refs.guildToken; 
274:         uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(
275:             address(this)
276:         );
277:         gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);
278:         uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this)); // <= FOUND 'int256 gaugeType '
279:         uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight( // <= FOUND 'int256 totalWeight '
280:             gaugeType
281:         );
282:         uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)
283:             .buffer();
284:         uint256 _hardCap = params.hardCap; 
285:         if (gaugeWeight == 0) {
286:             return 0; 
287:         } else if (gaugeWeight == totalWeight) {
288:             
289:             
290:             return
291:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
292:         }
293:         uint256 _issuance = issuance; 
294:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
295:             .totalBorrowedCredit();
296:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager) // <= FOUND 'int256 gaugeWeightTolerance '
297:             .gaugeWeightTolerance();
298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) {
299:             
300:             
301:             
302:             return
303:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
304:         }
305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /
306:             1e18;
307:         uint256 debtCeilingBefore = (totalBorrowedCredit *
308:             toleratedGaugeWeight) / totalWeight;
309:         if (_issuance >= debtCeilingBefore) {
310:             return debtCeilingBefore; 
311:         }
312:         uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; 
313:         if (toleratedGaugeWeight >= totalWeight) {
314:             
315:             
316:             return
317:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
318:         }
319:         uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; 
320:         uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /
321:             otherGaugesWeight;
322:         uint256 _debtCeiling = _issuance + maxBorrow;
323:         
324:         if (creditMinterBuffer < _debtCeiling) {
325:             return creditMinterBuffer;
326:         }
327:         if (_hardCap < _debtCeiling) {
328:             return _hardCap;
329:         }
330:         return _debtCeiling;
331:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L278-L296)

```200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) {
201:         Loan storage loan = loans[loanId];
202:         uint256 borrowTime = loan.borrowTime;
203: 
204:         if (borrowTime == 0) {
205:             return 0;
206:         }
207: 
208:         if (loan.closeTime != 0) {
209:             return 0;
210:         }
211: 
212:         if (loan.callTime != 0) {
213:             return loan.callDebt;
214:         }
215: 
216:         
217:         uint256 borrowAmount = loan.borrowAmount;
218:         uint256 interest = (borrowAmount *
219:             params.interestRate *
220:             (block.timestamp - borrowTime)) /
221:             YEAR /
222:             1e18;
223:         uint256 loanDebt = borrowAmount + interest;
224:         uint256 _openingFee = params.openingFee;
225:         if (_openingFee != 0) {
226:             loanDebt += (borrowAmount * _openingFee) / 1e18;
227:         }
228:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
229:             .creditMultiplier();
230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;
231: 
232:         return loanDebt;
233:     }
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L228-L228)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager) // <= FOUND 'int256 gaugeWeightTolerance '
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
```

*GitHub* : [355](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L355-L381)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [512](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L512-L512)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* : [583](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L583-L583)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {
696:         Loan storage loan = loans[loanId];
697: 
698:         
699:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
700: 
701:         
702:         require(loan.closeTime == 0, "LendingTerm: loan closed");
703: 
704:         
705:         loans[loanId].closeTime = block.timestamp;
706:         issuance -= loan.borrowAmount;
707: 
708:         
709:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
710:             .creditMultiplier();
711:         uint256 borrowAmount = loans[loanId].borrowAmount;
712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
714:         int256 pnl = -int256(principal);
715:         ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
716: 
717:         
718:         params.hardCap = 0;
719: 
720:         
721:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);
722:     }
```

*GitHub* : [709](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L709-L709)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager) // <= FOUND 'int256 creditMultiplier '
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
```

*GitHub* : [751](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L751-L751)

```80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) {
81:         uint256 creditMultiplier = ProfitManager(profitManager) // <= FOUND 'int256 creditMultiplier '
82:             .creditMultiplier();
83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier;
84:     }
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L81-L81)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) {
90:         uint256 creditMultiplier = ProfitManager(profitManager) // <= FOUND 'int256 creditMultiplier '
91:             .creditMultiplier();
92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection;
93:     }
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L90-L90)

```207:     function _decrementGaugeWeight(
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override {
212:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
213:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];
214:         require(
215:             _lastGaugeLossApplied >= _lastGaugeLoss,
216:             "GuildToken: pending loss"
217:         );
218: 
219:         
220:         ProfitManager(profitManager).claimGaugeRewards(user, gauge);
221: 
222:         
223:         
224:         uint256 issuance = LendingTerm(gauge).issuance(); // <= FOUND 'int256 issuance '
225:         if (issuance != 0) {
226:             uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));
227:             require(
228:                 issuance <= debtCeilingAfterDecrement,
229:                 "GuildToken: debt ceiling used"
230:             );
231:         }
232: 
233:         super._decrementGaugeWeight(user, gauge, weight);
234:     }
```

*GitHub* : [224](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L224-L224)

```215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     {
227:         targets = new address[](3);
228:         values = new uint256[](3);
229:         calldatas = new bytes[](3);
230:         description = string.concat(
231:             "[",
232:             Strings.toString(block.number),
233:             "]",
234:             " Enable term ",
235:             Strings.toHexString(term)
236:         );
237: 
238:         
239:         targets[0] = guildToken;
240:         calldatas[0] = abi.encodeWithSelector(
241:             GuildToken.addGauge.selector,
242:             gaugeType,
243:             term
244:         );
245: 
246:         
247:         address _core = address(core()); // <= FOUND 'address _core '
248:         targets[1] = _core;
249:         calldatas[1] = abi.encodeWithSelector(
250:             AccessControl.grantRole.selector,
251:             CoreRoles.RATE_LIMITED_CREDIT_MINTER,
252:             term
253:         );
254: 
255:         
256:         targets[2] = _core;
257:         calldatas[2] = abi.encodeWithSelector(
258:             AccessControl.grantRole.selector,
259:             CoreRoles.GAUGE_PNL_NOTIFIER,
260:             term
261:         );
262:     }
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L247-L247)

```160:     function initialize(
161:         address _core, // <= FOUND 'address _core,'
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0));
167:         assert(_core != address(0));
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [161](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L161-L161)
### [NC-04]<a name="nc-04"></a> Subtraction may underflow if multiplication is too large 
In arithmetic operations involving subtraction and multiplication, an underflow may occur if a subtraction result is negative, or if a multiplication result exceeds the maximum value representable in the data type. For instance, if a large multiplication precedes a subtraction, it may create a value too large to subtract from, causing an underflow. This could lead to unexpected and incorrect results in the calculation.

*There are 1 instance(s) of this issue:*

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) {
121:         
122:         uint256 _startTime = auctions[loanId].startTime;
123:         require(_startTime != 0, "AuctionHouse: invalid auction");
124: 
125:         
126:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended");
127: 
128:         
129:         
130:         
131:         assert(block.timestamp >= _startTime);
132: 
133:         
134:         if (block.timestamp < _startTime + midPoint) {
135:             
136:             creditAsked = auctions[loanId].callDebt;
137: 
138:             
139:             uint256 elapsed = block.timestamp - _startTime; 
140:             uint256 _collateralAmount = auctions[loanId].collateralAmount; 
141:             collateralReceived = (_collateralAmount * elapsed) / midPoint;
142:         }
143:         
144:         else if (block.timestamp < _startTime + auctionDuration) {
145:             
146:             collateralReceived = auctions[loanId].collateralAmount;
147: 
148:             
149:             uint256 PHASE_2_DURATION = auctionDuration - midPoint;
150:             uint256 elapsed = block.timestamp - _startTime - midPoint; 
151:             uint256 _callDebt = auctions[loanId].callDebt; 
152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION; // <= FOUND
153:         }
154:         
155:         
156:         else {
157:             
158:             collateralReceived = auctions[loanId].collateralAmount;
159:             
160:         }
161:     }
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L118-L152)
### [NC-05]<a name="nc-05"></a> Code does not follow the best practice of check-effects-interaction 
The "check-effects-interaction" pattern is a best practice in smart contract development, emphasizing the order of operations in functions to prevent reentrancy attacks. Violations arise when a function interacts with external contracts before settling internal state changes or checks. This misordering can expose the contract to potential threats. To adhere to this pattern, first ensure all conditions or checks are satisfied, then update any internal states, and only after these steps, interact with external contracts or addresses. Rearranging operations to this recommended sequence bolsters contract security and aligns with established best practices in the Ethereum community.

*There are 1 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize( // <= FOUND
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params);
167:         return term;
168:     }
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L154)
### [NC-06]<a name="nc-06"></a> Events may be emitted out of order due to code not follow the best practice of check-effects-interaction 
The "check-effects-interaction" pattern also impacts event ordering. When a contract doesn't adhere to this pattern, events might be emitted in a sequence that doesn't reflect the actual logical flow of operations. This can cause confusion during event tracking, potentially leading to erroneous off-chain interpretations. To rectify this, always ensure that checks are performed first, state modifications come next, and interactions with external contracts or addresses are done last. This will ensure events are emitted in a logical, consistent manner, providing a clear and accurate chronological record of on-chain actions for off-chain systems and observers.

*There are 5 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize( // <= FOUND
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params); // <= FOUND
167:         return term;
168:     }
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L166)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0); // <= FOUND
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate( // <= FOUND
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss); // <= FOUND
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer); // <= FOUND
328:                 emit SurplusBufferUpdate(block.timestamp, 0); // <= FOUND
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply(); // <= FOUND
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate( // <= FOUND
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate( // <= FOUND
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer( // <= FOUND
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit); // <= FOUND
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount); // <= FOUND
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L404)

```166:     function bid(bytes32 loanId) external { // <= FOUND
167:         
168:         
169:         (uint256 collateralReceived, uint256 creditAsked) = getBidDetail(
170:             loanId
171:         );
172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0");
173: 
174:         
175:         auctions[loanId].endTime = block.timestamp;
176:         nAuctionsInProgress--;
177: 
178:         
179:         address _lendingTerm = auctions[loanId].lendingTerm;
180:         LendingTerm(_lendingTerm).onBid( // <= FOUND
181:             loanId,
182:             msg.sender,
183:             auctions[loanId].collateralAmount - collateralReceived, 
184:             collateralReceived, 
185:             creditAsked 
186:         );
187: 
188:         
189:         emit AuctionEnd( // <= FOUND
190:             block.timestamp,
191:             loanId,
192:             LendingTerm(_lendingTerm).collateralToken(), // <= FOUND
193:             collateralReceived, 
194:             creditAsked 
195:         );
196:     }
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L166-L192)

```202:     function forgive(bytes32 loanId) external { // <= FOUND
203:         
204:         
205:         (, uint256 creditAsked) = getBidDetail(loanId);
206:         require(creditAsked == 0, "AuctionHouse: ongoing auction");
207: 
208:         
209:         auctions[loanId].endTime = block.timestamp;
210:         nAuctionsInProgress--;
211: 
212:         
213:         address _lendingTerm = auctions[loanId].lendingTerm;
214:         LendingTerm(_lendingTerm).onBid( // <= FOUND
215:             loanId,
216:             msg.sender,
217:             0, 
218:             0, 
219:             0 
220:         );
221: 
222:         
223:         emit AuctionEnd( // <= FOUND
224:             block.timestamp,
225:             loanId,
226:             LendingTerm(_lendingTerm).collateralToken(), // <= FOUND
227:             0, 
228:             0 
229:         );
230:     }
```

*GitHub* : [202](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L202-L226)

```634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal {
639:         Loan storage loan = loans[loanId];
640: 
641:         
642:         uint256 borrowTime = loan.borrowTime;
643:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
644: 
645:         
646:         require(loan.closeTime == 0, "LendingTerm: loan closed");
647: 
648:         
649:         require(loan.callTime == 0, "LendingTerm: loan called");
650: 
651:         
652:         require(
653:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||
654:                 partialRepayDelayPassed(loanId),
655:             "LendingTerm: cannot call"
656:         );
657: 
658:         
659:         require(
660:             borrowTime < block.timestamp,
661:             "LendingTerm: loan opened in same block"
662:         );
663: 
664:         
665:         uint256 loanDebt = getLoanDebt(loanId);
666:         loans[loanId].callTime = block.timestamp;
667:         loans[loanId].callDebt = loanDebt;
668:         loans[loanId].caller = caller;
669: 
670:         
671:         AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt); // <= FOUND
672: 
673:         
674:         emit LoanCall(block.timestamp, loanId); // <= FOUND
675:     }
```

*GitHub* : [634](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L634-L674)
### [NC-07]<a name="nc-07"></a> Non constant/immutable state variables are missing a setter post deployment 
Non-constant or non-immutable state variables lacking a setter function can create inflexibility in contract operations. If there's no way to update these variables post-deployment, the contract might not adapt to changing conditions or requirements, which can be a significant drawback, especially in upgradable or long-lived contracts. To resolve this, implement setter functions guarded by appropriate access controls, like `onlyOwner` or similar modifiers, so that these variables can be updated as required while maintaining security. This enables smoother contract maintenance and feature upgrades.

*There are 2 instance(s) of this issue:*

```88: EnumerableSet.AddressSet internal _gauges;
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L88-L88)

```91: EnumerableSet.AddressSet internal _deprecatedGauges;
```

*GitHub* : [91](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L91-L91)
### [NC-08]<a name="nc-08"></a> Functions with array parameters should have length checks in place 
Functions in Solidity that accept array parameters should incorporate length checks as a security measure. This is to prevent potential overflow errors, unwanted gas consumption, and manipulation attempts. Without length checks, an attacker could pass excessively large arrays as input, causing excessive computation and potentially causing the function to exceed the block gas limit, leading to a denial-of-service. Additionally, unexpected array sizes could lead to logic errors within the function. As a resolution, always validate array length at the start of functions handling array inputs, ensuring it aligns with the expectations of the function logic. This makes the code more robust and predictable.

*There are 1 instance(s) of this issue:*

```110:     function guardianCancel(
111:         address[] memory targets, // <= FOUND
112:         uint256[] memory values, // <= FOUND
113:         bytes[] memory calldatas, // <= FOUND
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) {
116:         return _cancel(targets, values, calldatas, descriptionHash);
117:     }
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L113)
### [NC-09]<a name="nc-09"></a> Using abi.encodePacked can result in hash collision when used in hashing functions 
Consider using abi.encode as this pads data to 32 byte segments

*There are 1 instance(s) of this issue:*

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked( // <= FOUND
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [485](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L485-L485)
### [NC-10]<a name="nc-10"></a> Greater than comparisons made on state uints that can be set to max 
When state variables (uints) that can be set to their maximum value (type(uint256).max for example) are used in "greater than" comparisons, it introduces a risk of logic errors. If the state variable ever reaches this max value, any comparison expecting it to increment further will fail. This can halt or disrupt contract functionality. To avoid this, implement checks to ensure that the state variable doesn't exceed a certain threshold below the max value.

*There are 4 instance(s) of this issue:*

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term];
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0,
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight;
137:         polls[snapshotBlock][term] = _weight + userWeight;
138:         if (_weight + userWeight >= quorum) { // <= FOUND
139:             canOffboard[term] = true;
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L138-L138)

```68:     function _setQuorum(uint256 newQuorum) internal {
69:         emit QuorumUpdated(_quorum, newQuorum);
70:         _quorum = newQuorum; // <= FOUND
71:     }
```

*GitHub* : [70](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L70-L70)

```78:     function setQuorum(
79:         uint256 _quorum
80:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
81:         emit QuorumUpdated(quorum, _quorum);
82:         quorum = _quorum; // <= FOUND
83:     }
```

*GitHub* : [82](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L82-L82)

```71:     function _setQuorum(uint256 newQuorum) internal virtual {
72:         emit QuorumUpdated(_quorum, newQuorum);
73:         _quorum = newQuorum; // <= FOUND
74:     }
```

*GitHub* : [73](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L73-L73)
### [NC-11]<a name="nc-11"></a> .call bypasses function existence check, type checking and argument packing 
Using the `.call` method in Solidity enables direct communication with an address, bypassing function existence checks, type checking, and argument packing. While this can save gas and provide flexibility, it can also introduce security risks and potential errors. The absence of these checks can lead to unexpected behavior if the callee contract's interface changes or if the input parameters are not crafted with care. The resolution to these issues is to use Solidity's high-level interface for calling functions when possible, as it automatically manages these aspects. If using `.call` is necessary, ensure that the inputs are carefully validated and that awareness of the called contract's behavior is maintained.

*There are 2 instance(s) of this issue:*

```114:         
115:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
116:             abi.encodeWithSelector(IERC20.totalSupply.selector)
117:         );
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L114-L115)

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L101-L102)
### [NC-12]<a name="nc-12"></a> Getting a bool return value does not confirm the existence of a function in an external call 
External calls to contracts using `address.call()` might return a boolean indicating success or failure. However, this boolean doesn't guarantee the existence of a called function. If a function isn't present, the call won't revert but will simply return `false`. This behavior might lead developers into mistakenly believing they're interacting with a legitimate or expected function, whereas it might not exist at all—a scenario sometimes termed as "phantom functions". Resolution: Instead of solely relying on the boolean, further validate the contract you're interacting with, or use interfaces or abstract contracts to enforce the existence of expected functions.

*There are 4 instance(s) of this issue:*

```     function emergencyAction(  Call[] calldata calls  )  external  payable  onlyCoreRole(CoreRoles.GOVERNOR)  returns (bytes[] memory returnData) {
      returnData = new bytes[](calls.length);
      for (uint256 i = 0;
i < calls.length;
i++) {             address payable target = payable(calls[i].target);
          uint256 value = calls[i].value;
          bytes calldata callData = calls[i].callData;
          (bool success, bytes memory returned) = target.call{value: value}
(                 callData );
          require(success, "CoreRef: underlying call reverted");
          returnData[i] = returned;
      }
  }
```

     *GitHub* :

```     function createTerm(  address implementation,  LendingTerm.LendingTermParams calldata params ) external returns (address) {
  require(  implementations[implementation],  "LendingTermOnboarding: invalid implementation" );
    (bool success, bytes memory returned) = params.collateralToken.call(  abi.encodeWithSelector(IERC20.totalSupply.selector) );
  require(  success && returned.length == 32,  "LendingTermOnboarding: invalid collateralToken" );
  require(  params.maxDebtPerCollateralToken != 0,   "LendingTermOnboarding: invalid maxDebtPerCollateralToken" );
  require(  params.interestRate < 1e18,   "LendingTermOnboarding: invalid interestRate" );
  require(    params.maxDelayBetweenPartialRepay < 31557601,   "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay" );
  require(  params.minPartialRepayPercent < 1e18,   "LendingTermOnboarding: invalid minPartialRepayPercent" );
  require(  params.openingFee <= 0.1e18,   "LendingTermOnboarding: invalid openingFee" );
  require(  params.hardCap != 0,   "LendingTermOnboarding: invalid hardCap" );
  address term = Clones.clone(implementation);
  LendingTerm(term).initialize(  address(core()), LendingTerm.LendingTermReferences({                 profitManager: profitManager,  guildToken: guildToken,  auctionHouse: auctionHouse,  creditMinter: creditMinter,  creditToken: creditToken }
),             params );
  created[term] = block.timestamp;
  emit TermCreated(block.timestamp, implementation, term, params);
  return term;
}
```

 *GitHub* :

```     function transfer(  address to,  uint256 amount ) public virtual override returns (bool) {
     RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
  RebasingState memory rebasingStateTo = rebasingState[to];
  uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
  uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||  rebasingStateTo.isRebasing == 1)  ? rebasingSharePrice() : 0;
   if (rebasingStateFrom.isRebasing == 1) {             uint256 shares = uint256(rebasingStateFrom.nShares);
      uint256 rebasedBalance = _shares2balance(  shares,  _rebasingSharePrice,  0,  fromBalanceBefore );
      uint256 mintAmount = rebasedBalance - fromBalanceBefore;
      if (mintAmount != 0) {                 ERC20._mint(msg.sender, mintAmount);
          fromBalanceBefore += mintAmount;
          decreaseUnmintedRebaseRewards(mintAmount);
          emit RebaseReward(msg.sender, block.timestamp, mintAmount);
      }
  }
   bool success = ERC20.transfer(to, amount);
   int256 sharesDelta;
  if (rebasingStateFrom.isRebasing == 1) {             uint256 fromBalanceAfter = fromBalanceBefore - amount;
      uint256 fromSharesAfter = _balance2shares(  fromBalanceAfter,  _rebasingSharePrice );
      uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
      sharesDelta -= int256(sharesSpent);
      rebasingState[msg.sender] = RebasingState({                 isRebasing: 1,  nShares: uint248(fromSharesAfter) }
);
  }
   if (rebasingStateTo.isRebasing == 1) {              uint256 rawToBalanceAfter = ERC20.balanceOf(to);
      uint256 toBalanceAfter = _shares2balance(  rebasingStateTo.nShares,  _rebasingSharePrice,  amount,  rawToBalanceAfter );
        uint256 toSharesAfter = _balance2shares(  toBalanceAfter,  _rebasingSharePrice );
      uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
      sharesDelta += int256(sharesReceived);
      rebasingState[to] = RebasingState({                 isRebasing: 1,  nShares: uint248(toSharesAfter) }
);
       uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
      if (mintAmount != 0) {                 ERC20._mint(to, mintAmount);
          decreaseUnmintedRebaseRewards(mintAmount);
          emit RebaseReward(to, block.timestamp, mintAmount);
      }
  }
    if (  rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1 ) {             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
  }
  return success;
}
```

 *GitHub* :

```     function transferFrom(  address from,  address to,  uint256 amount ) public virtual override returns (bool) {
     RebasingState memory rebasingStateFrom = rebasingState[from];
  RebasingState memory rebasingStateTo = rebasingState[to];
  uint256 fromBalanceBefore = ERC20.balanceOf(from);
  uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||  rebasingStateTo.isRebasing == 1)  ? rebasingSharePrice() : 0;
  if (rebasingStateFrom.isRebasing == 1) {             uint256 shares = uint256(rebasingStateFrom.nShares);
      uint256 rebasedBalance = _shares2balance(  shares,  _rebasingSharePrice,  0,  fromBalanceBefore );
      uint256 mintAmount = rebasedBalance - fromBalanceBefore;
      if (mintAmount != 0) {                 ERC20._mint(from, mintAmount);
          fromBalanceBefore += mintAmount;
          decreaseUnmintedRebaseRewards(mintAmount);
          emit RebaseReward(from, block.timestamp, mintAmount);
      }
  }
   bool success = ERC20.transferFrom(from, to, amount);
   int256 sharesDelta;
  if (rebasingStateFrom.isRebasing == 1) {             uint256 fromBalanceAfter = fromBalanceBefore - amount;
      uint256 fromSharesAfter = _balance2shares(  fromBalanceAfter,  _rebasingSharePrice );
      uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
      sharesDelta -= int256(sharesSpent);
      rebasingState[from] = RebasingState({                 isRebasing: 1,  nShares: uint248(fromSharesAfter) }
);
  }
   if (rebasingStateTo.isRebasing == 1) {              uint256 rawToBalanceAfter = ERC20.balanceOf(to);
      uint256 toBalanceAfter = _shares2balance(  rebasingStateTo.nShares,  _rebasingSharePrice,  amount,  rawToBalanceAfter );
        uint256 toSharesAfter = _balance2shares(  toBalanceAfter,  _rebasingSharePrice );
      uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
      sharesDelta += int256(sharesReceived);
      rebasingState[to] = RebasingState({                 isRebasing: 1,  nShares: uint248(toSharesAfter) }
);
       uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
      if (mintAmount != 0) {                 ERC20._mint(to, mintAmount);
          decreaseUnmintedRebaseRewards(mintAmount);
          emit RebaseReward(to, block.timestamp, mintAmount);
      }
  }
    if (  rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1 ) {             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
  }
  return success;
}
```

 *GitHub* :
### [NC-13]<a name="nc-13"></a> Empty constructor body without natspec comments 
A void constructor in Solidity refers to a constructor that has no logic or code within it. It can be redundant and should be avoided because it unnecessarily increases the contract's bytecode, leading to higher deployment and gas costs. In a contract, a constructor is often used to initialize state variables or set specific conditions at the time of deployment. If no such initialization or conditions are required, the empty or void constructor serves no functional purpose. The resolution is simply to omit the constructor if it is not needed, thereby optimizing the contract for efficiency and readability.

*There are 3 instance(s) of this issue:*

```15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     {}
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L15-L15)

```24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     {}
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L24-L24)

```153:     constructor() CoreRef(address(1)) {
154:         
155:         
156:     }
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L153-L153)
### [NC-14]<a name="nc-14"></a> Double type casts create complexity within the code 
Double type casting should be avoided in Solidity contracts to prevent unintended consequences and ensure accurate data representation. Performing multiple type casts in succession can lead to unexpected truncation, rounding errors, or loss of precision, potentially compromising the contract's functionality and reliability. Furthermore, double type casting can make the code less readable and harder to maintain, increasing the likelihood of errors and misunderstandings during development and debugging. To ensure precise and consistent data handling, developers should use appropriate data types and avoid unnecessary or excessive type casting, promoting a more robust and dependable contract execution.

*There are 1 instance(s) of this issue:*

```277:         gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta); // <= FOUND
```

*GitHub* : [277](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L277-L277)
### [NC-15]<a name="nc-15"></a> Inconsistent comment spacing 
Some comments use // X and others //X Amend comments to use only use // X or //X consistently

*There are 4 instance(s) of this issue:*

```25: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20Gauges.sol
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L25-L25)

```19: //code4rena.com/reports/2022-04-xtribe/
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L19-L19)

```20: //consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L20-L20)

```17: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20MultiVotes.sol
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L17-L17)
### [NC-16]<a name="nc-16"></a> Return values of transfer()/transferFrom() not checked 
In Solidity, it's crucial to check the return value of `.transfer` and `.transferFrom` methods because not all ERC20 and ERC721 token implementations revert on failure. Notably, If these methods fail silently and the contract doesn't verify their return value, the contract might continue execution as if the tokens were transferred successfully, leading to incorrect balances, loss of funds, or other unexpected behaviors. Therefore, the return values of these methods should always be checked, ensuring a failed token transfer operation correctly halts the execution of the contract.

*There are 11 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external { // <= FOUND
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external { // <= FOUND
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263)
### [NC-17]<a name="nc-17"></a> Consider adding emergency-stop functionality 
In the event of a security breach or any unforeseen emergency, swiftly suspending all protocol operations becomes crucial. Having a mechanism in place to halt all functions collectively, instead of pausing individual contracts separately, substantially enhances the efficiency of mitigating ongoing attacks or vulnerabilities. This not only quickens the response time to potential threats but also reduces operational stress during these critical periods. Therefore, consider integrating a 'circuit breaker' or 'emergency stop' function into the smart contract system architecture. Such a feature would provide the capability to suspend the entire protocol instantly, which could prove invaluable during a time-sensitive crisis management situation.

*There are 12 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract LendingTermOffboarding is CoreRef 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor 
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```contract CreditToken is CoreRef, ERC20Burnable, ERC20MultiVotes, ERC20RebaseDistributor 
```

*GitHub* :

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes 
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef 
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-18]<a name="nc-18"></a> Missing events in sensitive functions 
Sensitive setter functions in smart contracts often alter critical state variables. Without events emitted in these functions, external observers or dApps cannot easily track or react to these state changes. Missing events can obscure contract activity, hampering transparency and making integration more challenging. To resolve this, incorporate appropriate event emissions within these functions. Events offer an efficient way to log crucial changes, aiding in real-time tracking and post-transaction verification.

*There are 20 instance(s) of this issue:*

```39:     function setCore( // <= FOUND
40:         address newCore
41:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
42:         _setCore(newCore);
43:     }
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L39-L39)

```78:     function setVotingDelay( // <= FOUND
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
81:         _setVotingDelay(newVotingDelay);
82:     }
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L78)

```85:     function setVotingPeriod( // <= FOUND
86:         uint256 newVotingPeriod
87:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
88:         _setVotingPeriod(newVotingPeriod);
89:     }
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L85-L85)

```92:     function setProposalThreshold( // <= FOUND
93:         uint256 newProposalThreshold
94:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
95:         _setProposalThreshold(newProposalThreshold);
96:     }
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L92-L92)

```99:     function setQuorum( // <= FOUND
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) {
102:         _setQuorum(newQuorum);
103:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L99-L99)

```43:     function setMaxDelegates( // <= FOUND
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
46:         _setMaxDelegates(newMax);
47:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L43)

```50:     function setContractExceedMaxDelegates( // <= FOUND
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
54:         _setContractExceedMaxDelegates(account, canExceedMax);
55:     }
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```59:     function setMaxDelegates( // <= FOUND
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
62:         _setMaxDelegates(newMax);
63:     }
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L59)

```66:     function setContractExceedMaxDelegates( // <= FOUND
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
70:         _setContractExceedMaxDelegates(account, canExceedMax);
71:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```89:     function setMaxGauges( // <= FOUND
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
92:         _setMaxGauges(max);
93:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L89)

```95:     function setCanExceedMaxGauges( // <= FOUND
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
99:         _setCanExceedMaxGauges(who, can);
100:     }
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```829:     function setAuctionHouse( // <= FOUND
830:         address _newValue
831:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
832:         
833:         
834:         
835:         
836:         require(
837:             AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,
838:             "LendingTerm: auctions in progress"
839:         );
840: 
841:         refs.auctionHouse = _newValue;
842:     }
```

*GitHub* : [829](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L829-L829)

```846:     function setHardCap( // <= FOUND
847:         uint256 _newValue
848:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
849:         params.hardCap = _newValue;
850:     }
```

*GitHub* : [846](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L846-L846)

```61:     function setRateLimitPerSecond( // <= FOUND
62:         uint128 newRateLimitPerSecond
63:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
64:         require(
65:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
66:             "RateLimited: rateLimitPerSecond too high"
67:         );
68:         _updateBufferStored(bufferCap);
69: 
70:         _setRateLimitPerSecond(newRateLimitPerSecond);
71:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L61-L61)

```75:     function setBufferCap( // <= FOUND
76:         uint128 newBufferCap
77:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
78:         _setBufferCap(newBufferCap);
79:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L75-L75)

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {} // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```93:     function updateTimelock( // <= FOUND
94:         address newTimelock
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
96:         _updateTimelock(newTimelock);
97:     }
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L93-L93)

```168:     function updateTotalRebasingShares( // <= FOUND
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
196:             __unmintedRebaseRewards = InterpolatedValue({
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             });
202:             return;
203:         }
204: 
205:         
206:         
207:         
208:         
209:         
210:         InterpolatedValue memory val = __rebasingSharePrice;
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice +
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L168)

```293:     function updateMintRatio(address user, address term) external { // <= FOUND
294:         
295:         (, UserStake memory userStake, bool slashed) = getRewards(user, term);
296: 
297:         
298:         if (userStake.stakeTime == 0 || slashed) return;
299: 
300:         
301:         uint256 guildBefore = uint256(userStake.guild);
302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;
303:         if (guildAfter > guildBefore) {
304:             uint256 guildAmount = guildAfter - guildBefore;
305:             RateLimitedMinter(rlgm).mint(address(this), guildAmount);
306:             GuildToken(guild).incrementGauge(term, guildAmount);
307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
308:         } else if (guildAfter < guildBefore) {
309:             uint256 guildAmount = guildBefore - guildAfter;
310:             GuildToken(guild).decrementGauge(term, guildAmount);
311:             RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
312:             GuildToken(guild).burn(guildAmount);
313:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
314:         }
315:     }
```

*GitHub* : [293](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L293-L293)

```158:     function _updateBufferStored(uint128 newBufferCap) internal { // <= FOUND
159:         uint224 newBufferStored = buffer().safeCastTo224();
160:         uint32 newBlockTimestamp = block.timestamp.safeCastTo32();
161: 
162:         if (newBufferStored > newBufferCap) {
163:             bufferStored = uint224(newBufferCap); 
164:             lastBufferUsedTime = newBlockTimestamp;
165:         } else {
166:             bufferStored = newBufferStored;
167:             lastBufferUsedTime = newBlockTimestamp;
168:         }
169:     }
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L158)
### [NC-19]<a name="nc-19"></a> Use assembly to write address storage values 
Using assembly to directly write storage values can be a gas-saving optimization, bypassing some of Solidity's overhead. While this can lead to reduced transaction costs, it introduces risks, as assembly lacks the safety checks inherent in high-level Solidity. Incorrect use can lead to critical vulnerabilities. If opting for this gas optimization, ensure that: 1) The assembly block is well-documented, detailing its purpose and operation; 2) Thorough tests are written, covering all potential edge cases; and 3) A meticulous code review is conducted by developers experienced in Ethereum assembly to ensure there are no oversights or unintended consequences.

*There are 5 instance(s) of this issue:*

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken; // <= FOUND
73:         psm = _psm; // <= FOUND
74:         quorum = _quorum;
75:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L73)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager; // <= FOUND
52:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L51)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager; // <= FOUND
72:         credit = _credit; // <= FOUND
73:         pegToken = _pegToken; // <= FOUND
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L73)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager; // <= FOUND
98:         credit = _credit; // <= FOUND
99:         guild = _guild; // <= FOUND
100:         rlgm = _rlgm; // <= FOUND
101:         mintRatio = _mintRatio;
102:         rewardRatio = _rewardRatio;
103:     }
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L100)

```30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     {
41:         token = _token; // <= FOUND
42:         role = _role;
43:     }
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L30-L41)
### [NC-20]<a name="nc-20"></a> Consider making private state variables internal to increase flexibility 
In Solidity, `private` state variables are strictly confined to the contract they are defined in and can't be accessed or modified by its derived contracts. While this offers strong encapsulation, it can limit contract extensibility and modification in inheritance chains. On the other hand, `internal` variables can be accessed and potentially overridden by child contracts, granting more flexibility in contract development and upgrades. Therefore, it's recommended to use `private` only when you explicitly want to prevent child contract access. Otherwise, prefer `internal` to maintain a balance between encapsulation and the flexibility offered by inheritance patterns in Solidity.

*There are 2 instance(s) of this issue:*

```25: uint256 private _quorum; // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L25-L25)

```17: Core private _core; // <= FOUND
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L17-L17)
### [NC-21]<a name="nc-21"></a> Inconsistent comment spacing 
Some comments use // X and others //X Amend comments to use only use // X or //X consistently

*There are 4 instance(s) of this issue:*

```25: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20Gauges.sol
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L25-L25)

```19: //code4rena.com/reports/2022-04-xtribe/
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L19-L19)

```20: //consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L20-L20)

```17: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20MultiVotes.sol
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L17-L17)
### [NC-22]<a name="nc-22"></a> Instances should be declared in a separate file
It is general standard to declare interfaces on files separate from regular contract declarations

*There are 1 instance(s) of this issue:*

```10: interface IERC20Mintable  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L10-L10)
### [NC-23]<a name="nc-23"></a> Empty function blocks
Empty code blocks (i.e., {}) in a Solidity contract can be harmful as they can lead to ambiguity, misinterpretation, and unintended behavior. When developers encounter empty code blocks, it may be unclear whether the absence of code is intentional or the result of an oversight. This uncertainty can cause confusion during development, testing, and debugging, increasing the likelihood of introducing errors or vulnerabilities. Moreover, empty code blocks may give a false impression of implemented functionality or security measures, creating a misleading sense of assurance. To ensure clarity and maintainability, it is essential to avoid empty code blocks and explicitly document the intended behavior or any intentional omissions.

*There are 3 instance(s) of this issue:*

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {}
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override {}
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override {}
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)
### [NC-24]<a name="nc-24"></a> Usage of ecrecover is vulnerable to signature malleability
Avoid using ecrecovery when possible, in cases where it must be used ensure a nonce is present

*There are 1 instance(s) of this issue:*

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover( // <= FOUND
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [483](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L483-L483)
### [NC-25]<a name="nc-25"></a> In functions which accept an address as a parameter, there should be a zero address check to prevent bugs
Implement a zero address check to ensure input isn't the zero address

*There are 71 instance(s) of this issue:*

```39:     function setCore(
40:         address newCore
41:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L39-L39)

```49:     function _setCore(address newCore) internal 
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L49-L49)

```110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) 
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L110)

```123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) 
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool) 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L30-L30)

```41:     function _grantRole(bytes32 role, address account) internal override 
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override 
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```92:     function allowImplementation(
93:         address implementation,
94:         bool allowed
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L92-L92)

```215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     
```

*GitHub* : [215](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L215-L215)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external 
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L259)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L267)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L278)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) 
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) 
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L409)

```439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) 
```

*GitHub* : [439](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L439-L439)

```452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L452-L452)

```93:     function updateTimelock(
94:         address newTimelock
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L93-L93)

```99:     function _updateTimelock(address newTimelock) private 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L99-L99)

```143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool) 
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L143-L143)

```103:     function isGauge(address gauge) public view returns (bool) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L103-L103)

```108:     function isDeprecatedGauge(address gauge) public view returns (bool) 
```

*GitHub* : [108](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L108-L108)

```154:     function userGauges(address user) external view returns (address[] memory) 
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L154-L154)

```159:     function isUserGauge(
160:         address user,
161:         address gauge
162:     ) external view returns (bool) 
```

*GitHub* : [159](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L159-L159)

```167:     function numUserGauges(address user) external view returns (uint256) 
```

*GitHub* : [167](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L167-L167)

```172:     function userUnusedWeight(address user) external view returns (uint256) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L172-L172)

```182:     function calculateGaugeAllocation(
183:         address gauge,
184:         uint256 quantity
185:     ) external view returns (uint256) 
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L182-L182)

```301:     function decrementGauge(
302:         address gauge,
303:         uint256 weight
304:     ) public virtual returns (uint256 newUserWeight) 
```

*GitHub* : [301](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L301-L301)

```403:     function _burn(address from, uint256 amount) internal virtual override 
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) 
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L408)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) 
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L416)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal 
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L500-L500)

```52:     function checkpoints(
53:         address account,
54:         uint32 pos
55:     ) public view virtual returns (Checkpoint memory) 
```

*GitHub* : [52](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L52-L52)

```60:     function numCheckpoints(
61:         address account
62:     ) public view virtual returns (uint32) 
```

*GitHub* : [60](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L60-L60)

```71:     function freeVotes(address account) public view virtual returns (uint256) 
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L71-L71)

```80:     function getVotes(address account) public view virtual returns (uint256) 
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L80-L80)

```218:     function delegatesVotesCount(
219:         address delegator,
220:         address delegatee
221:     ) public view virtual returns (uint256) 
```

*GitHub* : [218](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L218-L218)

```230:     function delegates(
231:         address delegator
232:     ) public view returns (address[] memory) 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L230-L230)

```242:     function containsDelegate(
243:         address delegator,
244:         address delegatee
245:     ) public view returns (bool) 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L242-L242)

```254:     function delegateCount(address delegator) public view returns (uint256) 
```

*GitHub* : [254](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L254-L254)

```264:     function incrementDelegation(
265:         address delegatee,
266:         uint256 amount
267:     ) public virtual 
```

*GitHub* : [264](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L264-L264)

```276:     function undelegate(address delegatee, uint256 amount) public virtual 
```

*GitHub* : [276](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L276-L276)

```286:     function delegate(address newDelegatee) external virtual 
```

*GitHub* : [286](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L286-L286)

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private 
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L363)

```289:     function _enterRebase(address account) internal 
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L289)

```311:     function _exitRebase(address account) internal 
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L311)

```389:     function isRebasing(address account) public view returns (bool) 
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L389-L389)

```426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256) 
```

*GitHub* : [426](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L426-L426)

```461:     function _burn(address account, uint256 amount) internal virtual override 
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```509:     function _mint(address account, uint256 amount) internal virtual override 
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)

```35:     function mint(
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) 
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L35)

```50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L83)

```90:     function _burn(
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) 
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L90)

```98:     function balanceOf(
99:         address account
100:     ) public view override(ERC20, ERC20RebaseDistributor) returns (uint256) 
```

*GitHub* : [98](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L98-L98)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L113)

```125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L125)

```66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```76:     function addGauge(
77:         uint256 _type,
78:         address gauge
79:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) 
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L76)

```83:     function removeGauge(
84:         address gauge
85:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L83-L83)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```197:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L197-L197)

```268:     function mint(
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) 
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L268)

```279:     function _burn(
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) 
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L279)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L288)

```302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L302)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L103)

```106:     function getUserStake(
107:         address user,
108:         address term
109:     ) external view returns (UserStake memory) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L106-L106)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L216)

```293:     function updateMintRatio(address user, address term) external 
```

*GitHub* : [293](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L293-L293)

```49:     function mint(
50:         address to,
51:         uint256 amount
52:     ) external onlyCoreRole(role) whenNotPaused 
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L49-L49)
### [NC-26]<a name="nc-26"></a> Enum values should be used in place of constant array indexes
Create a commented enum value to use in place of constant array indexes, this makes the code far easier to understand

*There are 8 instance(s) of this issue:*

```239: 
240:         
241:         targets[0] = guildToken; // <= FOUND
```

*GitHub* : [239](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L239-L241)

```240:         calldatas[0] = abi.encodeWithSelector( // <= FOUND
241:             GuildToken.addGauge.selector,
242:             gaugeType,
243:             term
244:         );
```

*GitHub* : [240](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L240-L240)

```380:         targets[0] = timelock; // <= FOUND
```

*GitHub* : [380](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L380-L380)

```383:         calldatas[0] = abi.encodeWithSelector( // <= FOUND
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L383-L383)

```248:         targets[1] = _core; // <= FOUND
```

*GitHub* : [248](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L248-L248)

```249:         calldatas[1] = abi.encodeWithSelector( // <= FOUND
250:             AccessControl.grantRole.selector,
251:             CoreRoles.RATE_LIMITED_CREDIT_MINTER,
252:             term
253:         );
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L249-L249)

```256: 
257:         
258:         targets[2] = _core; // <= FOUND
```

*GitHub* : [256](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L256-L258)

```257:         calldatas[2] = abi.encodeWithSelector( // <= FOUND
258:             AccessControl.grantRole.selector,
259:             CoreRoles.GAUGE_PNL_NOTIFIER,
260:             term
261:         );
```

*GitHub* : [257](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L257-L257)
### [NC-27]<a name="nc-27"></a> Default int values are manually set
In instances where a new variable is defined, there is no need to set it to it's default value.

*There are 8 instance(s) of this issue:*

```441:         for (
442:             uint256 i = 0; // <= FOUND
```

*GitHub* : [441](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L441-L442)

```109:         uint256 low = 0; // <= FOUND
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L109-L109)

```96:         for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```443:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L443)

```443: 
444:         for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L444)

```280: 
281:         
282:         for (uint256 i = 0; i < size; ) { // <= FOUND
```

*GitHub* : [280](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L280-L282)

```280: 
281:         
282:         
283:         for (uint256 i = 0; i < size; ) { // <= FOUND
```

*GitHub* : [280](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L280-L283)

```685:         for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [NC-28]<a name="nc-28"></a> Reverts should use customer errors instead of strings
Custom error codes should be used in place of strings for revert statements in Solidity contracts to enhance efficiency and reduce gas costs. String-based error messages consume more bytecode and storage, increasing the overall gas consumption during contract deployment and execution

*There are 3 instance(s) of this issue:*

```177:         revert("LendingTermOnboarding: cannot propose arbitrary actions"); // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L177-L177)

```213:             revert("GuildVetoGovernor: can only vote against in veto proposals"); // <= FOUND
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L213-L213)

```310:         revert("GuildVetoGovernor: cannot propose arbitrary actions"); // <= FOUND
```

*GitHub* : [310](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L310-L310)
### [NC-29]<a name="nc-29"></a> Functions which are either private or internal should have a preceding _ in their name
Add a preceding underscore to the function name, take care to refactor where there functions are called

*There are 6 instance(s) of this issue:*

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) 
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) 
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L131-L131)

```168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal 
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L168)

```228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal 
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L228-L228)

```242:     function rebasingSharePrice() internal view returns (uint256) 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L242-L242)

```247:     function unmintedRebaseRewards() internal view returns (uint256) 
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L247-L247)
### [NC-30]<a name="nc-30"></a> Private and internal state variables should have a preceding _ in their name unless they are constants
Add a preceding underscore to the state variable name, take care to refactor where there variables are read/wrote

*There are 4 instance(s) of this issue:*

```64: ProfitSharingConfig internal profitSharingConfig; // <= FOUND
```

*GitHub* : [64](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L64-L64)

```112: LendingTermReferences internal refs; // <= FOUND
```

*GitHub* : [112](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L112-L112)

```151: LendingTermParams internal params; // <= FOUND
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L151-L151)

```86: uint256 internal totalRebasingShares; // <= FOUND
```

*GitHub* : [86](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L86-L86)
### [NC-31]<a name="nc-31"></a> Contract lines should not be longer than 120 characters for readability
Consider spreading these lines over multiple lines to aid in readability and the support of VIM users everywhere.

*There are 10 instance(s) of this issue:*

```281:      * @notice Delegate all votes `newDelegatee`. First undelegates from an existing delegate. If `newDelegatee` is zero, only undelegates. // <= FOUND
```

*GitHub* : [281](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L281-L281)

```284:      * NOTE This is meant for backward compatibility with the `ERC20Votes` and `ERC20VotesComp` interfaces from OpenZeppelin. // <= FOUND
```

*GitHub* : [284](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L284-L284)

```116:     /// During the first half of the auction, an increasing amount of the collateral is offered, for the full CREDIT amount. // <= FOUND
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L116-L116)

```271:         uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer // <= FOUND
```

*GitHub* : [271](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L271-L271)

```283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer // <= FOUND
```

*GitHub* : [283](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L283-L283)

```46:     - Rename `calculateGaugeAllocation` to `calculateGaugeStoredAllocation` to make clear that it reads from stored weights. // <= FOUND
```

*GitHub* : [46](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L46-L46)

```389:     /// @dev if this number is ever lowered, or a contract has an override, then existing addresses MAY have more gauges allocated to. Use `numUserGauges` to check this. // <= FOUND
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L389-L389)

```443:     /// @dev if this is set to a lower number than the current max, users MAY have more gauges active than the max. Use `numUserGauges` to check this. // <= FOUND
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L443-L443)

```82:     /// @notice For internal accounting. Number of rebasing shares for each rebasing accounts. 0 if account is not rebasing. // <= FOUND
```

*GitHub* : [82](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L82-L82)

```242:     /// - ProposalState.Succeeded (4) If action is pending in the timelock and veto quorum has been reached. Veto can be executed instantly. // <= FOUND
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L242-L242)
### [NC-32]<a name="nc-32"></a> Use newer solidity versions
Newer solidity versions have new functionality and are generally more gas efficient too (0.8.19) as such it makes sense to use them provided it is safe to do so

*There are 1 instance(s) of this issue:*

```4: pragma solidity 0.8.13;
```

*GitHub* :
### [NC-33]<a name="nc-33"></a> Not all event definitions are utilizing indexed variables.
Try to index as much as three variables in event declarations as this is more gas efficient when done on value type variables (uint, address etc) however not for bytes and string variables

*There are 34 instance(s) of this issue:*

```28: event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum); // <= FOUND
```

*GitHub* : [28](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L28-L28)

```50: event ImplementationAllowChanged( // <= FOUND
51:         uint256 indexed when,
52:         address indexed implementation,
53:         bool allowed
54:     );
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L50-L50)

```111: event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl); // <= FOUND
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L111-L111)

```114: event SurplusBufferUpdate(uint256 indexed when, uint256 newValue); // <= FOUND
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L114-L114)

```117: event TermSurplusBufferUpdate( // <= FOUND
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L117-L117)

```124: event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue); // <= FOUND
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L124-L124)

```127: event ProfitSharingConfigUpdate( // <= FOUND
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
132:         uint256 otherSplit,
133:         address otherRecipient
134:     );
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L127-L127)

```145: event MinBorrowUpdate(uint256 indexed when, uint256 newValue); // <= FOUND
```

*GitHub* : [145](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L145-L145)

```148: event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue); // <= FOUND
```

*GitHub* : [148](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L148-L148)

```83: event TimelockChange(address oldTimelock, address newTimelock); // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L83-L83)

```109: event GaugeLossApply( // <= FOUND
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
114:     );
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L109-L109)

```172: event TransfersEnabled(uint256 block, uint256 timestamp); // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L172-L172)

```194: event ProfitManagerUpdated(uint256 timestamp, address newValue); // <= FOUND
```

*GitHub* : [194](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L194-L194)

```12: event AuctionStart( // <= FOUND
13:         uint256 indexed when,
14:         bytes32 indexed loanId,
15:         address collateralToken,
16:         uint256 collateralAmount,
17:         uint256 callDebt
18:     );
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L12-L12)

```20: event AuctionEnd( // <= FOUND
21:         uint256 indexed when,
22:         bytes32 indexed loanId,
23:         address collateralToken,
24:         uint256 collateralSold,
25:         uint256 debtRecovered
26:     );
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L20-L20)

```49: event Redeem( // <= FOUND
50:         uint256 indexed when,
51:         address indexed to,
52:         uint256 amountIn,
53:         uint256 amountOut
54:     );
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L49-L49)

```56: event Mint( // <= FOUND
57:         uint256 indexed when,
58:         address indexed to,
59:         uint256 amountIn,
60:         uint256 amountOut
61:     );
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L56-L56)

```63: event RedemptionsPaused(uint256 indexed when, bool status); // <= FOUND
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L63-L63)

```32: event Stake( // <= FOUND
33:         uint256 indexed timestamp,
34:         address indexed term,
35:         uint256 amount
36:     );
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L32-L32)

```38: event Unstake( // <= FOUND
39:         uint256 indexed timestamp,
40:         address indexed term,
41:         uint256 amount
42:     );
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L38-L38)

```45: event GuildReward( // <= FOUND
46:         uint256 indexed timestamp,
47:         address indexed user,
48:         uint256 amount
49:     );
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L45-L45)

```51: event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio); // <= FOUND
```

*GitHub* : [51](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L51-L51)

```53: event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio); // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L53-L53)

```200: event IncrementGaugeWeight( // <= FOUND
201:         address indexed user,
202:         address indexed gauge,
203:         uint256 weight
204:     );
```

*GitHub* : [200](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L200-L200)

```207: event DecrementGaugeWeight( // <= FOUND
208:         address indexed user,
209:         address indexed gauge,
210:         uint256 weight
211:     );
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L207-L207)

```380: event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges); // <= FOUND
```

*GitHub* : [380](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L380-L380)

```383: event CanExceedMaxGaugesUpdate( // <= FOUND
384:         address indexed account,
385:         bool canExceedMaxGauges
386:     );
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L383-L383)

```132: event MaxDelegatesUpdate(uint256 oldMaxDelegates, uint256 newMaxDelegates); // <= FOUND
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L132-L132)

```135: event CanContractExceedMaxDelegatesUpdate( // <= FOUND
136:         address indexed account,
137:         bool canContractExceedMaxDelegates
138:     );
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L135-L135)

```174: event Delegation( // <= FOUND
175:         address indexed delegator,
176:         address indexed delegate,
177:         uint256 amount
178:     );
```

*GitHub* : [174](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L174-L174)

```181: event Undelegation( // <= FOUND
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L181-L181)

```188: event DelegateVotesChanged( // <= FOUND
189:         address indexed delegate,
190:         uint256 previousBalance,
191:         uint256 newBalance
192:     );
```

*GitHub* : [188](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L188-L188)

```52: event RebaseDistribution( // <= FOUND
53:         address indexed source,
54:         uint256 indexed timestamp,
55:         uint256 amountDistributed,
56:         uint256 amountRebasing
57:     );
```

*GitHub* : [52](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L52-L52)

```67: event RebaseReward( // <= FOUND
68:         address indexed account,
69:         uint256 indexed timestamp,
70:         uint256 amount
71:     );
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L67-L67)
### [NC-34]<a name="nc-34"></a> Call calls must have their return checked
External calls in Solidity should have their return values checked to ensure the expected behavior, enhance error handling, and maintain the overall security and integrity of the contract. Unchecked return values can lead to silent failures, allowing the contract to continue executing despite an error in the external call.

*There are 1 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L114-L114)
### [NC-35]<a name="nc-35"></a> Function names should differ to make the code more readable
In Solidity, while function overriding allows for functions with the same name to coexist, it is advisable to avoid this practice to enhance code readability and maintainability. Having multiple functions with the same name, even with different parameters or in inherited contracts, can cause confusion and increase the likelihood of errors during development, testing, and debugging. Using distinct and descriptive function names not only clarifies the purpose and behavior of each function, but also helps prevent unintended function calls or incorrect overriding. By adopting a clear and consistent naming convention, developers can create more comprehensible and maintainable smart contracts.

*There are 25 instance(s) of this issue:*

```99:     function setQuorum( // <= FOUND
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L99-L99)

```78:     function setQuorum( // <= FOUND
79:         uint256 _quorum
80:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L78-L78)

```57:     function quorum( // <= FOUND
58:         uint256 
59:     ) public view override returns (uint256) 
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L57-L57)

```68:     function _setQuorum(uint256 newQuorum) internal  // <= FOUND
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L68)

```71:     function _setQuorum(uint256 newQuorum) internal virtual  // <= FOUND
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L71-L71)

```160:     function state( // <= FOUND
161:         uint256 proposalId
162:     )
163:         public
164:         view
165:         override(Governor, GovernorTimelockControl)
166:         returns (ProposalState)
167:     
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L160-L160)

```246:     function state( // <= FOUND
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) 
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L246-L246)

```171:     function propose( // <= FOUND
172:         address[] memory ,
173:         uint256[] memory ,
174:         bytes[] memory ,
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L171)

```304:     function propose( // <= FOUND
305:         address[] memory ,
306:         uint256[] memory ,
307:         bytes[] memory ,
308:         string memory 
309:     ) public pure override returns (uint256) 
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L304-L304)

```403:     function _burn(address from, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```461:     function _burn(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```90:     function _burn( // <= FOUND
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) 
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L90)

```279:     function _burn( // <= FOUND
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) 
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L279)

```43:     function setMaxDelegates( // <= FOUND
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L43)

```59:     function setMaxDelegates( // <= FOUND
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L59)

```50:     function setContractExceedMaxDelegates( // <= FOUND
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```66:     function setContractExceedMaxDelegates( // <= FOUND
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```314:     function _decrementGaugeWeight( // <= FOUND
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual 
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L314-L314)

```207:     function _decrementGaugeWeight( // <= FOUND
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override 
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L207-L207)

```230:     function _incrementGaugeWeight( // <= FOUND
231:         address user,
232:         address gauge,
233:         uint256 weight
234:     ) internal virtual 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L230-L230)

```242:     function _incrementGaugeWeight( // <= FOUND
243:         address user,
244:         address gauge,
245:         uint256 weight
246:     ) internal override 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L242-L242)

```270:     function debtCeiling( // <= FOUND
271:         int256 gaugeWeightDelta
272:     ) public view returns (uint256) 
```

*GitHub* : [270](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270-L270)

```334:     function debtCeiling() external view returns (uint256)  // <= FOUND
```

*GitHub* : [334](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L334-L334)

```202:     function forgive(bytes32 loanId) external  // <= FOUND
```

*GitHub* : [202](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L202-L202)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR)  // <= FOUND
```

*GitHub* : [695](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L695-L695)
### [NC-36]<a name="nc-36"></a> Functions should not be longer than 50 lines
Overly complex code can make understanding functionality more difficult, try to further modularise your code to ensure readability

*There are 1 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) 
```

*GitHub* :
### [NC-37]<a name="nc-37"></a> Functions within contracts are not ordered according to the solidity style guide
The following order should be used within contracts

constructor

receive function (if exists)

fallback function (if exists)

external

public

internal

private

Rearrange the contract functions and contructors to fit this ordering

*There are 9 instance(s) of this issue:*

```16: contract GuildGovernor is
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: 
```

*GitHub* :

```23: contract LendingTermOnboarding is GuildGovernor  // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is
19:     CoreRef,
20:     ERC20Burnable,
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: 
```

*GitHub* :

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef  // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)
### [NC-38]<a name="nc-38"></a> Functions which set address state variables should have zero address checks

*There are 6 instance(s) of this issue:*

```49:     function _setCore(address newCore) internal {
50:         address oldCore = address(_core);
51:         _core = Core(newCore);
52: 
53:         emit CoreUpdate(oldCore, newCore);
54:     }
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L49-L49)

```39:     function setCore(
40:         address newCore
41:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
42:         _setCore(newCore);
43:     }
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L39-L39)

```50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
54:         _setContractExceedMaxDelegates(account, canExceedMax);
55:     }
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
70:         _setContractExceedMaxDelegates(account, canExceedMax);
71:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
99:         _setCanExceedMaxGauges(who, can);
100:     }
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```197:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {
198:         profitManager = _newProfitManager;
199:         emit ProfitManagerUpdated(block.timestamp, _newProfitManager);
200:     }
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L197-L197)
### [NC-39]<a name="nc-39"></a> Interface imports should be declared first
Amend the ordering of imports to import interfaces first followed by other imports

*There are 5 instance(s) of this issue:*

```2: 
3: pragma solidity 0.8.13;
4: 
5: import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol"; // <= FOUND
6: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
7: import {Strings} from "@openzeppelin/contracts/utils/Strings.sol"; // <= FOUND
8: import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol"; // <= FOUND
9: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
10: 
11: import {Core} from "@src/core/Core.sol"; // <= FOUND
12: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
13: import {GuildToken} from "@src/tokens/GuildToken.sol"; // <= FOUND
14: import {LendingTerm} from "@src/loan/LendingTerm.sol"; // <= FOUND
15: import {GuildGovernor} from "@src/governance/GuildGovernor.sol"; // <= FOUND
16: 
24: contract LendingTermOnboarding is GuildGovernor {
25:     
26:     uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days;
27:     
28:     mapping(address => uint256) public lastProposal;
29: 
31:     mapping(address => bool) public implementations;
32:     
33:     address public immutable guildToken;
34:     
35:     uint256 public immutable gaugeType;
36: 
39:     mapping(address => uint256) public created;
40: 
42:     address public immutable profitManager;
43:     
44:     address public immutable auctionHouse;
45:     
46:     address public immutable creditMinter;
47:     
48:     address public immutable creditToken;
49: 
51:     event ImplementationAllowChanged(
52:         uint256 indexed when,
53:         address indexed implementation,
54:         bool allowed
55:     );
56:     
57:     event TermCreated(
58:         uint256 indexed when,
59:         address indexed implementation,
60:         address indexed term,
61:         LendingTerm.LendingTermParams params
62:     );
63: 
64:     constructor(
65:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
66:         uint256 _gaugeType,
67:         address _core,
68:         address _timelock,
69:         uint256 initialVotingDelay,
70:         uint256 initialVotingPeriod,
71:         uint256 initialProposalThreshold,
72:         uint256 initialQuorum
73:     )
74:         GuildGovernor(
75:             _core,
76:             _timelock,
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L5-L15)

```2: 
3: pragma solidity 0.8.13;
4: 
5: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
6: import {GovernorSettings} from "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol"; // <= FOUND
7: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"; // <= FOUND
8: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; // <= FOUND
9: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol"; // <= FOUND
10: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol"; // <= FOUND
11: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol"; // <= FOUND
12: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
13: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
14: 
17: contract GuildGovernor is
18:     CoreRef,
19:     Governor,
20:     GovernorVotes,
21:     GovernorTimelockControl,
22:     GovernorSettings,
23:     GovernorCountingSimple
24: {
25:     
26:     uint256 private _quorum;
27: 
29:     event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
30: 
31:     constructor(
32:         address _core,
33:         address _timelock,
34:         address _token,
35:         uint256 initialVotingDelay,
36:         uint256 initialVotingPeriod,
37:         uint256 initialProposalThreshold,
38:         uint256 initialQuorum
39:     )
40:         CoreRef(_core)
41:         Governor("ECG Governor")
42:         GovernorVotes(IVotes(_token))
43:         GovernorTimelockControl(TimelockController(payable(_timelock)))
44:         GovernorSettings(
45:             initialVotingDelay,
46:             initialVotingPeriod,
47:             initialProposalThreshold
48:         )
49:     {
50:         _setQuorum(initialQuorum);
51:     }
52: 
58:     function quorum(
59:         uint256 
60:     ) public view override returns (uint256) {
61:         return _quorum;
62:     }
63: 
69:     function _setQuorum(uint256 newQuorum) internal {
70:         emit QuorumUpdated(_quorum, newQuorum);
71:         _quorum = newQuorum;
72:     }
73: 
79:     function setVotingDelay(
80:         uint256 newVotingDelay
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L5-L13)

```2: 
3: pragma solidity 0.8.13;
4: 
5: import {Math} from "@openzeppelin/contracts/utils/math/Math.sol"; // <= FOUND
6: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol"; // <= FOUND
7: 
8: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
9: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
10: import {IRateLimitedV2} from "@src/utils/IRateLimitedV2.sol"; // <= FOUND
11: 
15: abstract contract RateLimitedV2 is IRateLimitedV2, CoreRef {
16:     using SafeCastLib for *;
17: 
19:     uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;
20: 
24:     uint128 public rateLimitPerSecond;
25: 
27:     uint128 public bufferCap;
28: 
32:     uint32 public lastBufferUsedTime;
33: 
35:     uint224 public bufferStored;
36: 
41:     constructor(
42:         uint256 _maxRateLimitPerSecond,
43:         uint128 _rateLimitPerSecond,
44:         uint128 _bufferCap
45:     ) {
46:         lastBufferUsedTime = block.timestamp.safeCastTo32();
47: 
48:         _setBufferCap(_bufferCap);
49:         bufferStored = _bufferCap;
50: 
51:         require(
52:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
53:             "RateLimited: rateLimitPerSecond too high"
54:         );
55:         _setRateLimitPerSecond(_rateLimitPerSecond);
56: 
57:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
58:     }
59: 
62:     function setRateLimitPerSecond(
63:         uint128 newRateLimitPerSecond
64:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
65:         require(
66:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
67:             "RateLimited: rateLimitPerSecond too high"
68:         );
69:         _updateBufferStored(bufferCap);
70: 
71:         _setRateLimitPerSecond(newRateLimitPerSecond);
72:     }
73: 
76:     function setBufferCap(
77:         uint128 newBufferCap
78:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
79:         _setBufferCap(newBufferCap);
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L5-L10)

```2: 
3: pragma solidity 0.8.13;
4: 
5: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
6: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // <= FOUND
7: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"; // <= FOUND
8: 
9: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
10: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
11: import {GuildToken} from "@src/tokens/GuildToken.sol"; // <= FOUND
12: import {CreditToken} from "@src/tokens/CreditToken.sol"; // <= FOUND
13: import {AuctionHouse} from "@src/loan/AuctionHouse.sol"; // <= FOUND
14: import {ProfitManager} from "@src/governance/ProfitManager.sol"; // <= FOUND
15: import {RateLimitedMinter} from "@src/rate-limits/RateLimitedMinter.sol"; // <= FOUND
16: 
21: contract LendingTerm is CoreRef {
22:     using SafeERC20 for IERC20;
23: 
26:     event LoanOpen(
27:         uint256 indexed when,
28:         bytes32 indexed loanId,
29:         address indexed borrower,
30:         uint256 collateralAmount,
31:         uint256 borrowAmount
32:     );
33:     
34:     event LoanCall(uint256 indexed when, bytes32 indexed loanId);
35:     
36:     enum LoanCloseType {
37:         Repay,
38:         Call,
39:         Forgive
40:     }
41:     event LoanClose(
42:         uint256 indexed when,
43:         bytes32 indexed loanId,
44:         LoanCloseType indexed closeType,
45:         uint256 debtRepaid
46:     );
47:     
48:     event LoanAddCollateral(
49:         uint256 indexed when,
50:         bytes32 indexed loanId,
51:         address indexed borrower,
52:         uint256 collateralAmount
53:     );
54:     
55:     event LoanPartialRepay(
56:         uint256 indexed when,
57:         bytes32 indexed loanId,
58:         address indexed repayer,
59:         uint256 repayAmount
60:     );
61: 
62:     struct Signature {
63:         uint8 v;
64:         bytes32 r;
65:         bytes32 s;
66:     }
67: 
69:     uint256 public constant YEAR = 31557600;
70: 
74:     mapping(bytes32 => uint256) public lastPartialRepay;
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L5-L15)

```2: 
3: pragma solidity 0.8.13;
4: 
5: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
6: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"; // <= FOUND
7: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; // <= FOUND
8: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol"; // <= FOUND
9: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol"; // <= FOUND
10: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol"; // <= FOUND
11: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
12: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
13: 
26: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes {
27:     
28:     uint256 private _quorum;
29: 
31:     event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
32: 
33:     constructor(
34:         address _core,
35:         address initialTimelock,
36:         address _token,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Veto Governor")
41:         GovernorVotes(IVotes(_token))
42:     {
43:         _setQuorum(initialQuorum);
44:         _updateTimelock(initialTimelock);
45:     }
46: 
54:     function quorum(
55:         uint256 
56:     ) public view override returns (uint256) {
57:         return _quorum;
58:     }
59: 
61:     function setQuorum(
62:         uint256 newQuorum
63:     ) public onlyCoreRole(CoreRoles.GOVERNOR) {
64:         _setQuorum(newQuorum);
65:     }
66: 
72:     function _setQuorum(uint256 newQuorum) internal virtual {
73:         emit QuorumUpdated(_quorum, newQuorum);
74:         _quorum = newQuorum;
75:     }
76: 
84:     event TimelockChange(address oldTimelock, address newTimelock);
85: 
87:     address public timelock;
88: 
91:     mapping(uint256 => bytes32) private _timelockIds;
92: 
94:     function updateTimelock(
95:         address newTimelock
96:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
97:         _updateTimelock(newTimelock);
98:     }
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L5-L12)
### [NC-40]<a name="nc-40"></a> A function which defines named returns in it's declaration doesn't need to use return 
Remove the return statement once ensuring it is safe to do so

*There are 6 instance(s) of this issue:*

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term");
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp,
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp;
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description); // <= FOUND
212:     }
```

*GitHub* : [211](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L211-L211)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0; // <= FOUND
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned);
435:         }
436:     }
```

*GitHub* : [417](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L417-L417)

```219:     function incrementGauge(
220:         address gauge,
221:         uint256 weight
222:     ) public virtual returns (uint256 newUserWeight) {
223:         require(isGauge(gauge), "ERC20Gauges: invalid gauge");
224:         _incrementGaugeWeight(msg.sender, gauge, weight);
225:         return _incrementUserAndGlobalWeights(msg.sender, weight); // <= FOUND
226:     }
```

*GitHub* : [225](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L225-L225)

```269:     function incrementGauges(
270:         address[] calldata gaugeList,
271:         uint256[] calldata weights
272:     ) public virtual returns (uint256 newUserWeight) {
273:         uint256 size = gaugeList.length;
274:         require(weights.length == size, "ERC20Gauges: size mismatch");
275: 
276:         
277:         uint256 weightsSum;
278: 
279:         
280:         for (uint256 i = 0; i < size; ) {
281:             address gauge = gaugeList[i];
282:             uint256 weight = weights[i];
283:             weightsSum += weight;
284: 
285:             require(isGauge(gauge), "ERC20Gauges: invalid gauge");
286: 
287:             _incrementGaugeWeight(msg.sender, gauge, weight);
288:             unchecked {
289:                 ++i;
290:             }
291:         }
292:         return _incrementUserAndGlobalWeights(msg.sender, weightsSum); // <= FOUND
293:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L292-L292)

```301:     function decrementGauge(
302:         address gauge,
303:         uint256 weight
304:     ) public virtual returns (uint256 newUserWeight) {
305:         
306:         _decrementGaugeWeight(msg.sender, gauge, weight);
307:         if (!_deprecatedGauges.contains(gauge)) {
308:             totalTypeWeight[gaugeType[gauge]] -= weight;
309:             totalWeight -= weight;
310:         }
311:         return getUserWeight[msg.sender]; // <= FOUND
312:     }
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L311-L311)

```340:     function decrementGauges(
341:         address[] calldata gaugeList,
342:         uint256[] calldata weights
343:     ) public virtual returns (uint256 newUserWeight) {
344:         uint256 size = gaugeList.length;
345:         require(weights.length == size, "ERC20Gauges: size mismatch");
346: 
347:         
348:         uint256 weightsSum;
349: 
350:         
351:         
352:         for (uint256 i = 0; i < size; ) {
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i];
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight);
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i;
363:             }
364:         }
365:         totalWeight -= weightsSum;
366:         return getUserWeight[msg.sender]; // <= FOUND
367:     }
```

*GitHub* : [366](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L366-L366)
### [NC-41]<a name="nc-41"></a> Constant/immutable state variables defined more than once
Rather than redefining state variable constant/immutable, consider utilising a library to store all constants as this will prevent data redundancy

*There are 4 instance(s) of this issue:*

```29: uint256 public constant YEAR = 31557600; // <= FOUND
```

*GitHub* : [29](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L29-L29)

```32: address public immutable guildToken; // <= FOUND
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L32-L32)

```56: address public immutable profitManager; // <= FOUND
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L56-L56)

```59: address public immutable credit; // <= FOUND
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L59-L59)
### [NC-42]<a name="nc-42"></a> Multiple mappings can be replaced with a single struct mapping
Using a single struct mapping in place of multiple defined mappings in a Solidity contract can lead to improved code organization, better readability, and easier maintainability. By consolidating related data into a single struct, developers can create a more cohesive data structure that logically groups together relevant pieces of information, thus reducing redundancy and clutter. This approach simplifies the codebase, making it easier to understand, navigate, and modify. Additionally, it can result in more efficient gas usage when accessing or updating multiple related data points simultaneously.

*There are 6 instance(s) of this issue:*

```16: contract LendingTermOffboarding is CoreRef {
17:     
30:     uint256 public constant POLL_DURATION_BLOCKS = 46523; 
31: 
33:     uint256 public quorum;
34: 
36:     address public immutable guildToken;
37: 
39:     address public immutable psm;
40: 
43:     mapping(uint256 => mapping(address => uint256)) public polls; // <= FOUND
44: 
47:     mapping(address => mapping(uint256 => mapping(address => uint256))) // <= FOUND
48:         public userPollVotes;
49: 
52:     mapping(address => uint256) public lastPollBlock; // <= FOUND
53: 
55:     mapping(address => bool) public canOffboard; // <= FOUND
56: 
58:     uint256 public nOffboardingsInProgress;
59: 
83: }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L43-L55)

```23: contract LendingTermOnboarding is GuildGovernor {
24:     
25:     uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days;
26:     
27:     mapping(address => uint256) public lastProposal; // <= FOUND
28: 
30:     mapping(address => bool) public implementations; // <= FOUND
31:     
32:     address public immutable guildToken;
33:     
34:     uint256 public immutable gaugeType;
35: 
38:     mapping(address => uint256) public created; // <= FOUND
39: 
41:     address public immutable profitManager;
42:     
43:     address public immutable auctionHouse;
44:     
45:     address public immutable creditMinter;
46:     
47:     address public immutable creditToken;
48: 
70: }
```

*GitHub* : [27](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L27-L38)

```30: contract ProfitManager is CoreRef {
31:     
32:     address public guild;
33: 
35:     address public credit;
36: 
38:     address public psm;
39: 
41:     mapping(address => uint256) public gaugeProfitIndex; // <= FOUND
42: 
44:     mapping(address => mapping(address => uint256)) public userGaugeProfitIndex; // <= FOUND
45: 
59:     ProfitSharingConfig internal profitSharingConfig;
60: 
65:     uint256 public surplusBuffer;
66: 
72:     mapping(address => uint256) public termSurplusBuffer; // <= FOUND
73: 
82:     uint256 public creditMultiplier = 1e18;
83: 
89:     uint256 internal _minBorrow = 100e18;
90: 
99:     uint256 public gaugeWeightTolerance = 1.2e18; 
100: 
176: }
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L41-L72)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes {
26:     
27:     uint256 private _quorum;
28: 
63:     address public timelock;
64: 
67:     mapping(uint256 => bytes32) private _timelockIds; // <= FOUND
68: 
81:     enum VoteType {
82:         Against,
83:         For,
84:         Abstain
85:     }
86: 
89:     mapping(uint256 => ProposalVote) private _proposalVotes; // <= FOUND
90: 
165: }
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L67-L89)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {
38:     using EnumerableSet for EnumerableSet.AddressSet;
39: 
41:     address public profitManager;
42: 
76:     mapping(address => uint256) public lastGaugeLoss; // <= FOUND
77: 
79:     mapping(address => mapping(address => uint256)) public lastGaugeLossApplied; // <= FOUND
80: 
94:     bool public transferable; 
95: 
143: }
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L79)

```20: contract LendingTerm is CoreRef {
21:     using SafeERC20 for IERC20;
22: 
29:     enum LoanCloseType {
30:         Repay,
31:         Call,
32:         Forgive
33:     }
34:     
43:     uint256 public constant YEAR = 31557600;
44: 
48:     mapping(bytes32 => uint256) public lastPartialRepay; // <= FOUND
49: 
54:     mapping(bytes32 => Loan) internal loans; // <= FOUND
55: 
60:     uint256 public issuance;
61: 
65:     LendingTermReferences internal refs;
66: 
70:     LendingTermParams internal params;
71: 
173: }
```

*GitHub* : [48](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L48-L54)
### [NC-43]<a name="nc-43"></a> Use safeApprove in place of approve
safeApprove should be used in place of the standard approve function in Solidity contracts to enhance security and prevent potential double-spend exploits. The approve function in ERC20 tokens allows users to set an allowance for a third party to spend on their behalf. However, changing an existing allowance without setting it to zero first can be exploited by malicious actors through a front-running attack. safeApprove mitigates this risk by ensuring that the allowance is set to zero before updating it to a new value

*There are 1 instance(s) of this issue:*

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount); // <= FOUND
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L129)
### [NC-44]<a name="nc-44"></a> Constants should be on the left side of the 
Putting constants on the left side of a comparison operator like `==` or `<` is a best practice known as "Yoda conditions", which can help prevent accidental assignment instead of comparison. In some programming languages, if a variable is mistakenly put on the left with a single `=` instead of `==`, it assigns the constant's value to the variable without any compiler error. However, doing this with the constant on the left would generate an error, as constants cannot be assigned values. Although Solidity's static typing system prevents accidental assignments within conditionals, adopting this practice enhances code readability and consistency, especially when developers are working across multiple languages that support this convention.

*There are 54 instance(s) of this issue:*

```162:         if (
163:             nOffboardingsInProgress++ == 0 && // <= FOUND
164:             !SimplePSM(psm).redemptionsPaused()
165:         ) 
```

*GitHub* : [163](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L163-L163)

```191:         if (
192:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused() // <= FOUND
193:         ) 
```

*GitHub* : [192](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L192-L192)

```361:             if (amountForSurplusBuffer != 0)  // <= FOUND
```

*GitHub* : [361](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L361-L361)

```416:         if (_userGaugeWeight == 0)  // <= FOUND
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L416-L416)

```393:         if (_gaugeProfitIndex == 0)  // <= FOUND
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L393-L393)

```424:         if (_userGaugeProfitIndex == 0)  // <= FOUND
```

*GitHub* : [424](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L424-L424)

```428:         if (deltaIndex != 0)  // <= FOUND
```

*GitHub* : [428](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L428-L428)

```432:         if (creditEarned != 0)  // <= FOUND
```

*GitHub* : [432](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L432-L432)

```274:         if (timelockOperationTimestamp == 0)  // <= FOUND
```

*GitHub* : [274](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L274-L274)

```417:         if (weight != 0)  // <= FOUND
```

*GitHub* : [417](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L417-L417)

```352:         if (newDelegates == 0)  // <= FOUND
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L352-L352)

```323:         if (mintAmount != 0)  // <= FOUND
```

*GitHub* : [323](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L323-L323)

```362:         if (_rebasingSupply != 0)  // <= FOUND
```

*GitHub* : [362](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L362-L362)

```430:         if (_rebasingState.isRebasing == 0)  // <= FOUND
```

*GitHub* : [430](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L430-L430)

```225:         if (issuance != 0)  // <= FOUND
```

*GitHub* : [225](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L225-L225)

```249:         if (getUserGaugeWeight[user][gauge] == 0)  // <= FOUND
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L249-L249)

```204:         if (borrowTime == 0)  // <= FOUND
```

*GitHub* : [204](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L204-L204)

```208:         if (loan.closeTime != 0)  // <= FOUND
```

*GitHub* : [208](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L208-L208)

```212:         if (loan.callTime != 0)  // <= FOUND
```

*GitHub* : [212](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L212-L212)

```225:         if (_openingFee != 0)  // <= FOUND
```

*GitHub* : [225](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L225-L225)

```285:         if (gaugeWeight == 0)  // <= FOUND
```

*GitHub* : [285](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L285-L285)

```298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0)  // <= FOUND
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L298-L298)

```388:         if (totalBorrowedCredit == 0)  // <= FOUND
```

*GitHub* : [388](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L388-L388)

```413:         if (params.maxDelayBetweenPartialRepay != 0)  // <= FOUND
```

*GitHub* : [413](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L413-L413)

```595:         if (interest != 0)  // <= FOUND
```

*GitHub* : [595](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L595-L595)

```774:         if (creditFromBidder != 0)  // <= FOUND
```

*GitHub* : [774](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L774-L774)

```783:         if (principal != 0)  // <= FOUND
```

*GitHub* : [783](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L783-L783)

```791:             if (interest != 0)  // <= FOUND
```

*GitHub* : [791](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L791-L791)

```804:         if (collateralToBorrower != 0)  // <= FOUND
```

*GitHub* : [804](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L804-L804)

```812:         if (collateralToBidder != 0)  // <= FOUND
```

*GitHub* : [812](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L812-L812)

```184:         if (userStake.credit == 0)  // <= FOUND
```

*GitHub* : [184](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L184-L184)

```309:             if (_termSurplusBuffer != 0)  // <= FOUND
```

*GitHub* : [309](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L309-L309)

```370:             if (amountForOther != 0)  // <= FOUND
```

*GitHub* : [370](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L370-L370)

```378:             if (amountForCredit != 0)  // <= FOUND
```

*GitHub* : [378](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L378-L378)

```393:                    if (_gaugeProfitIndex == 0)  // <= FOUND
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L393-L393)

```475:             if (_userGaugeProfitIndex == 0)  // <= FOUND
```

*GitHub* : [475](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L475-L475)

```479:             if (deltaIndex != 0)  // <= FOUND
```

*GitHub* : [479](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L479-L479)

```189:         if (sharesAfter == 0)  // <= FOUND
```

*GitHub* : [189](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L189-L189)

```212:         if (delta != 0)  // <= FOUND
```

*GitHub* : [212](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L212-L212)

```477:            if (mintAmount != 0)  // <= FOUND
```

*GitHub* : [477](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L477-L477)

```477:             if (mintAmount != 0)  // <= FOUND
```

*GitHub* : [477](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L477-L477)

```789:         if (pnl != 0)  // <= FOUND
```

*GitHub* : [789](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L789-L789)

```258:             if (guildReward != 0)  // <= FOUND
```

*GitHub* : [258](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L258-L258)

```262:             if (creditReward != 0)  // <= FOUND
```

*GitHub* : [262](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L262-L262)

```383:             if (amountForGuild != 0)  // <= FOUND
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L383-L383)

```278:         if (timelockOperationTimestamp == 1)  // <= FOUND
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L278-L278)

```301:         if (count == 1)  // <= FOUND
```

*GitHub* : [301](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L301-L301)

```467:         if (_rebasingState.isRebasing == 1)  // <= FOUND
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L467-L467)

```566:         if (rebasingStateFrom.isRebasing == 1)  // <= FOUND
```

*GitHub* : [566](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L566-L566)

```635:         if (
636:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1 // <= FOUND
637:         ) 
```

*GitHub* : [636](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L636-L636)

```603:         if (rebasingStateTo.isRebasing == 1)  // <= FOUND
```

*GitHub* : [603](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L603-L603)

```374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number)  // <= FOUND
```

*GitHub* : [374](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L374-L374)

```175:         if (sharesDelta > 0)  // <= FOUND
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L175-L175)

```301:         if (amount < 0)  // <= FOUND
```

*GitHub* : [301](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L301-L301)
### [NC-45]<a name="nc-45"></a> Both immutable and constant state variables should be CONSTANT_CASE
Make found instants CAPITAL_CASE

*There are 16 instance(s) of this issue:*

```34: uint256 public immutable gaugeType; // <= FOUND
```

*GitHub* : [34](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L34-L34)

```56: address public immutable profitManager; // <= FOUND
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L56-L56)

```43: address public immutable auctionHouse; // <= FOUND
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L43-L43)

```38: uint256 public immutable auctionDuration; // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L38-L38)

```43: uint256 public immutable decimalCorrection; // <= FOUND
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L43-L43)

```45: address public immutable creditMinter; // <= FOUND
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L45-L45)

```47: address public immutable creditToken; // <= FOUND
```

*GitHub* : [47](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L47-L47)

```59: address public immutable credit; // <= FOUND
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L59-L59)

```32: address public immutable guildToken; // <= FOUND
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L32-L32)

```31: uint256 public immutable midPoint; // <= FOUND
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L31-L31)

```62: address public immutable guild; // <= FOUND
```

*GitHub* : [62](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L62-L62)

```35: address public immutable pegToken; // <= FOUND
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L35-L35)

```19: address public immutable token; // <= FOUND
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L19-L19)

```22: bytes32 public immutable role; // <= FOUND
```

*GitHub* : [22](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L22-L22)

```65: address public immutable rlgm; // <= FOUND
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L65-L65)

```45: address public immutable psm; // <= FOUND
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L45-L45)
### [NC-46]<a name="nc-46"></a> Consider using named mappings
In Solidity version 0.8.18 and beyond mapping parameters can be named. This makes the purpose and function of a given mapping far clearer which in turn improves readability.

*There are 23 instance(s) of this issue:*

```61:     mapping(address => bool) public canOffboard; // <= FOUND
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L61-L61)

```30:     mapping(address => bool) public implementations; // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L30-L30)

```393:     mapping(address => bool) public canExceedMaxGauges; // <= FOUND
```

*GitHub* : [393](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L393-L393)

```144:     mapping(address => bool) public canContractExceedMaxDelegates; // <= FOUND
```

*GitHub* : [144](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L144-L144)

```90:     mapping(uint256 => bytes32) private _timelockIds; // <= FOUND
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L90-L90)

```49:     mapping(uint256 => mapping(address => uint256)) public polls; // <= FOUND
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L49-L49)

```53:     mapping(address => mapping(uint256 => mapping(address => uint256))) // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L53-L53)

```58:     mapping(address => uint256) public lastPollBlock; // <= FOUND
```

*GitHub* : [58](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L58-L58)

```27:     mapping(address => uint256) public lastProposal; // <= FOUND
```

*GitHub* : [27](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L27-L27)

```38:     mapping(address => uint256) public created; // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L38-L38)

```41:     mapping(address => uint256) public gaugeProfitIndex; // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L41-L41)

```44:     mapping(address => mapping(address => uint256)) public userGaugeProfitIndex; // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L44-L44)

```77:     mapping(address => uint256) public termSurplusBuffer; // <= FOUND
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L77-L77)

```117:     mapping(address => uint256) public lastGaugeLoss; // <= FOUND
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L117-L117)

```120:     mapping(address => mapping(address => uint256)) public lastGaugeLossApplied; // <= FOUND
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L120-L120)

```73:     mapping(bytes32 => uint256) public lastPartialRepay; // <= FOUND
```

*GitHub* : [73](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L73-L73)

```66:     mapping(address => mapping(address => uint256)) public getUserGaugeWeight; // <= FOUND
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L66-L66)

```70:     mapping(address => uint256) public getUserWeight; // <= FOUND
```

*GitHub* : [70](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L70-L70)

```74:     mapping(address => uint256) public getGaugeWeight; // <= FOUND
```

*GitHub* : [74](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L74-L74)

```81:     mapping(uint256 => uint256) public totalTypeWeight; // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L81-L81)

```84:     mapping(address => uint256) public gaugeType; // <= FOUND
```

*GitHub* : [84](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L84-L84)

```203:     mapping(address => mapping(address => uint256)) // <= FOUND
```

*GitHub* : [203](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L203-L203)

```207:     mapping(address => uint256) public userDelegatedVotes; // <= FOUND
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L207-L207)
### [NC-47]<a name="nc-47"></a> Loss of precision
Dividing by large numbers in Solidity can cause a loss of precision due to the language's inherent integer division behavior. Solidity does not support floating-point arithmetic, and as a result, division between integers yields an integer result, truncating any fractional part. When dividing by a large number, the resulting value may become significantly smaller, leading to a loss of precision, as the fractional part is discarded.

*There are 5 instance(s) of this issue:*

```151:     function minBorrow() external view returns (uint256) { // <= FOUND
152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
153:     }
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L151-L152)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
257:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L256)

```338:     function distribute(uint256 amount) external { // <= FOUND
339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero");
340: 
341:         
342:         _burn(msg.sender, amount);
343: 
344:         
345:         uint256 _rebasingSharePrice = rebasingSharePrice();
346:         uint256 _totalRebasingShares = totalRebasingShares;
347:         uint256 _rebasingSupply = _shares2balance(
348:             _totalRebasingShares,
349:             _rebasingSharePrice,
350:             0,
351:             0
352:         );
353:         emit RebaseDistribution(
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
359: 
360:         
361:         
362:         if (_rebasingSupply != 0) {
363:             
364:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;
365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares;
369:             __rebasingSharePrice = InterpolatedValue({
370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
375: 
376:             
377:             uint256 _unmintedRebaseRewards = unmintedRebaseRewards();
378:             __unmintedRebaseRewards = InterpolatedValue({
379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
385:         }
386:     }
```

*GitHub* : [338](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L338-L338)

```80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) { // <= FOUND
81:         uint256 creditMultiplier = ProfitManager(profitManager)
82:             .creditMultiplier();
83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
84:     }
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L80-L83)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) {
90:         uint256 creditMultiplier = ProfitManager(profitManager)
91:             .creditMultiplier();
92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
93:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L87-L92)
### [NC-48]<a name="nc-48"></a> Use a single contract or library for system wide constants

*There are 4 instance(s) of this issue:*

```16: contract LendingTermOffboarding is CoreRef {
17:     
30:     uint256 public constant POLL_DURATION_BLOCKS = 46523;  // <= FOUND
31: 
33:     uint256 public quorum;
34: 
36:     address public immutable guildToken;
37: 
39:     address public immutable psm;
40: 
43:     mapping(uint256 => mapping(address => uint256)) public polls;
44: 
47:     mapping(address => mapping(uint256 => mapping(address => uint256)))
48:         public userPollVotes;
49: 
52:     mapping(address => uint256) public lastPollBlock;
53: 
55:     mapping(address => bool) public canOffboard;
56: 
58:     uint256 public nOffboardingsInProgress;
59: 
83: }
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L30-L30)

```23: contract LendingTermOnboarding is GuildGovernor {
24:     
25:     uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days; // <= FOUND
26:     
27:     mapping(address => uint256) public lastProposal;
28: 
30:     mapping(address => bool) public implementations;
31:     
32:     address public immutable guildToken;
33:     
34:     uint256 public immutable gaugeType;
35: 
38:     mapping(address => uint256) public created;
39: 
41:     address public immutable profitManager;
42:     
43:     address public immutable auctionHouse;
44:     
45:     address public immutable creditMinter;
46:     
47:     address public immutable creditToken;
48: 
70: }
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L25-L25)

```20: contract LendingTerm is CoreRef {
21:     using SafeERC20 for IERC20;
22: 
29:     enum LoanCloseType {
30:         Repay,
31:         Call,
32:         Forgive
33:     }
34:     
43:     uint256 public constant YEAR = 31557600; // <= FOUND
44: 
48:     mapping(bytes32 => uint256) public lastPartialRepay;
49: 
54:     mapping(bytes32 => Loan) internal loans;
55: 
60:     uint256 public issuance;
61: 
65:     LendingTermReferences internal refs;
66: 
70:     LendingTermParams internal params;
71: 
173: }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L43-L43)

```24: contract SurplusGuildMinter is CoreRef {
25:     
26:     uint256 public constant MIN_STAKE = 1e18; // <= FOUND
27: 
29:     uint256 public constant YEAR = 31557600; // <= FOUND
30: 
44:     address public immutable profitManager;
45: 
47:     address public immutable credit;
48: 
50:     address public immutable guild;
51: 
53:     address public immutable rlgm;
54: 
58:     uint256 public mintRatio;
59: 
63:     uint256 public rewardRatio;
64: 
68:     mapping(address => mapping(address => UserStake)) internal _stakes;
69: 
95: }
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L26-L29)
### [NC-49]<a name="nc-49"></a> Consider using modifiers for address control
Modifiers in Solidity can improve code readability and modularity by encapsulating repetitive checks, such as address validity checks, into a reusable construct. For example, an `onlyOwner` modifier can be used to replace repetitive `require(msg.sender == owner)` checks across several functions, reducing code redundancy and enhancing maintainability. To implement, define a modifier with the check, then apply the modifier to relevant functions.

*There are 2 instance(s) of this issue:*

```124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L124)

```733:         
734:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller"); // <= FOUND
```

*GitHub* : [733](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L733-L734)
### [NC-50]<a name="nc-50"></a> Off-by-one timestamp error
In Solidity, using `>=` or `<=` to compare against `block.timestamp` (alias `now`) may introduce off-by-one errors due to the fact that `block.timestamp` is only updated once per block and its value remains constant throughout the block's execution. If an operation happens at the exact second when `block.timestamp` changes, it could result in unexpected behavior. To avoid this, it's safer to use strict inequality operators (`>` or `<`). For instance, if a condition should only be met after a certain time, use `block.timestamp > time` rather than `block.timestamp >= time`. This way, potential off-by-one errors due to the exact timing of block mining are mitigated, leading to safer, more predictable contract behavior.

*There are 2 instance(s) of this issue:*

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)

```131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) {
134:         
135:         uint256 lastTimestamp = uint256(val.lastTimestamp); 
136:         uint256 lastValue = uint256(val.lastValue); 
137:         uint256 targetTimestamp = uint256(val.targetTimestamp); 
138:         uint256 targetValue = uint256(val.targetValue); 
139: 
140:         
141:         if (block.timestamp >= targetTimestamp) {
142:             
143:             return targetValue;
144:         } else {
145:             
146:             uint256 elapsed = block.timestamp - lastTimestamp;
147:             uint256 delta = targetValue - lastValue;
148:             return
149:                 lastValue +
150:                 (delta * elapsed) /
151:                 (targetTimestamp - lastTimestamp);
152:         }
153:     }
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L131-L131)
### [NC-51]<a name="nc-51"></a> Default address(0) can be returned
Allowing a function in Solidity to return the default address (address(0)) can be problematic as it can represent uninitialized or invalid addresses. If such an address is utilized in transfer operations or other sensitive actions, it could lead to loss of funds or unpredicted behavior. It's prudent to include checks in your functions to prevent the return of the zero address, enhancing contract security.

*There are 3 instance(s) of this issue:*

```142:     function _executor()
143:         internal
144:         view
145:         override(Governor, GovernorTimelockControl)
146:         returns (address)
147:     {
148:         return super._executor();
149:     }
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L142-L142)

```230:     function getProfitSharingConfig()
231:         external
232:         view
233:         returns (
234:             uint256 surplusBufferSplit,
235:             uint256 creditSplit,
236:             uint256 guildSplit,
237:             uint256 otherSplit,
238:             address otherRecipient
239:         )
240:     {
241:         surplusBufferSplit =
242:             uint256(profitSharingConfig.surplusBufferSplit) *
243:             1e9;
244:         guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;
245:         otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;
246:         creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;
247:         otherRecipient = profitSharingConfig.otherRecipient;
248:     }
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L230-L230)

```190:     function collateralToken() external view returns (address) {
191:         return params.collateralToken;
192:     }
```

*GitHub* : [190](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L190-L190)
### [NC-52]<a name="nc-52"></a> Variables should be used in place of magic numbers to improve readability
Magic numbers should be avoided in Solidity code to enhance readability, maintainability, and reduce the likelihood of errors. Magic numbers are hard-coded values with no clear meaning or context, which can create confusion and make the code harder to understand for developers. Using well-defined constants or variables with descriptive names instead of magic numbers not only clarifies the purpose and significance of the value but also simplifies code updates and modifications.

*There are 7 instance(s) of this issue:*

```106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1 // <= FOUND
112:         );
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L106-L111)

```107:         emit MinBorrowUpdate(block.timestamp, 100e18); // <= FOUND
```

*GitHub* : [107](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L107-L107)

```231:         return 2425847;  // <= FOUND
```

*GitHub* : [231](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L231-L231)

```124:         
125:         return (a & b) + (a ^ b) / 2; // <= FOUND
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L124-L125)

```297: 
298:         
299:         require(count < 2, "ERC20MultiVotes: delegation error"); // <= FOUND
```

*GitHub* : [297](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L297-L299)

```117:         require(
118:             success && returned.length == 32, // <= FOUND
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L117-L118)

```132: 
133:         require(
134:             
135:             params.maxDelayBetweenPartialRepay < 31557601,  // <= FOUND
136:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
137:         );
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L132-L135)
### [NC-53]<a name="nc-53"></a> Redundant else statement

*There are 4 instance(s) of this issue:*

```246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) {
249:         ProposalState status = super.state(proposalId);
250:         bytes32 queueid = _timelockIds[proposalId];
251: 
252:         
253:         
254:         
255:         assert(queueid != bytes32(0));
256: 
257:         
258:         if (status == ProposalState.Executed) {
259:             return ProposalState.Executed;
260:         }
261:         
262:         
263:         if (status == ProposalState.Pending) {
264:             return ProposalState.Pending;
265:         }
266: 
267:         
268:         
269:         uint256 timelockOperationTimestamp = TimelockController(
270:             payable(timelock)
271:         ).getTimestamp(queueid);
272: 
273:         
274:         if (timelockOperationTimestamp == 0) {
275:             return ProposalState.Canceled;
276:         }
277:         
278:         if (timelockOperationTimestamp == 1) {
279:             return ProposalState.Defeated;
280:         }
281: 
282:         
283:         if (timelockOperationTimestamp > block.timestamp) {
284:             
285:             
286:             
287:             
288:             if (_quorumReached(proposalId)) {
289:                 return ProposalState.Succeeded;
290:             }
291:             
292:             else {
293:                 return ProposalState.Active;
294:             }
295:         }
296:         
297:         
298:         else {
299:             return ProposalState.Defeated;
300:         }
301:     }
```

*GitHub* :

```131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) {
134:         
135:         uint256 lastTimestamp = uint256(val.lastTimestamp); 
136:         uint256 lastValue = uint256(val.lastValue); 
137:         uint256 targetTimestamp = uint256(val.targetTimestamp); 
138:         uint256 targetValue = uint256(val.targetValue); 
139: 
140:         
141:         if (block.timestamp >= targetTimestamp) {
142:             
143:             return targetValue;
144:         } else {
145:             
146:             uint256 elapsed = block.timestamp - lastTimestamp;
147:             uint256 delta = targetValue - lastValue;
148:             return
149:                 lastValue +
150:                 (delta * elapsed) /
151:                 (targetTimestamp - lastTimestamp);
152:         }
153:     }
```

*GitHub* :

```399:     function nonRebasingSupply() external view virtual returns (uint256) { // <= FOUND
400:         uint256 _totalSupply = totalSupply();
401:         uint256 _rebasingSupply = rebasingSupply();
402: 
403:         
404:         
405:         
406:         if (_rebasingSupply > _totalSupply) {
407:             return 0;
408:         } else {
409:             return _totalSupply - _rebasingSupply;
410:         }
411:     }
```

*GitHub* : [399](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L399-L399)

```426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256) {
429:         RebasingState memory _rebasingState = rebasingState[account];
430:         if (_rebasingState.isRebasing == 0) {
431:             return ERC20.balanceOf(account);
432:         } else {
433:             return
434:                 _shares2balance(
435:                     _rebasingState.nShares,
436:                     rebasingSharePrice(),
437:                     0,
438:                     ERC20.balanceOf(account)
439:                 );
440:         }
441:     }
```

*GitHub* :
### [NC-54]<a name="nc-54"></a> Employ Explicit Casting to Bytes or Bytes32 for Enhanced Code Clarity and Meaning
Smart contracts are complex entities, and clarity in their operations is fundamental to ensure that they function as intended. Casting a single argument instead of utilizing 'abi.encodePacked()' improves the transparency of the operation. It elucidates the intent of the code, reducing ambiguity and making it easier for auditors and developers to understand the code’s purpose. Such practices promote readability and maintainability, thus reducing the likelihood of errors and misunderstandings. Therefore, it's recommended to employ explicit casts for single arguments where possible, to increase the contract's comprehensibility and ensure a smoother review process.

*There are 2 instance(s) of this issue:*

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); 
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId)) // <= FOUND
390:         );
391:     }
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L389-L389)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked( // <= FOUND
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [485](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L485-L485)
### [NC-55]<a name="nc-55"></a> Event emit should emit a parameter
Events in Solidity offer valuable insight into the contract's execution as they log specific instances of state changes or value transfers. However, if events do not include any parameters, their usefulness can be significantly reduced. Events without parameters can provide limited information, mainly signaling that a specific operation occurred, but lacking the context of what exactly changed. It's generally recommended to include relevant parameters, such as state changes or value modifications, in the emitted events.

*There are 3 instance(s) of this issue:*

```106: 
107:         
108:         emit AuctionStart( // <= FOUND
109:             block.timestamp,
110:             loanId,
111:             LendingTerm(msg.sender).collateralToken(), // <= FOUND
112:             loan.collateralAmount,
113:             callDebt
114:         );
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L106-L111)

```189: 
190:         
191:         emit AuctionEnd( // <= FOUND
192:             block.timestamp,
193:             loanId,
194:             LendingTerm(_lendingTerm).collateralToken(), // <= FOUND
195:             collateralReceived, 
196:             creditAsked 
197:         );
```

*GitHub* : [189](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L189-L194)

```223: 
224:         
225:         emit AuctionEnd( // <= FOUND
226:             block.timestamp,
227:             loanId,
228:             LendingTerm(_lendingTerm).collateralToken(), // <= FOUND
229:             0, 
230:             0 
231:         );
```

*GitHub* : [223](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L223-L228)
### [NC-56]<a name="nc-56"></a> Large or complicated code bases should implement invariant tests
Reason: Contracts with large codebases, complex inline-assembly, intricate math, or multifaceted inter-contract interactions can harbor elusive bugs, even with full code coverage. These bugs can surface depending on the sequence of operations performed by the user.

Resolution: Implement invariant fuzzing tests using tools like Echidna. Define comprehensive invariants – conditions that must always hold true – and let the fuzzer generate various input and function call sequences to test them. This way, you can significantly mitigate the risks posed by unexplored operation orders and bolster the contract's robustness.

*There are 1 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) 
```

*GitHub* :
### [NC-57]<a name="nc-57"></a> Overridden function has no body
In Ethereum Solidity, functions can be overridden, meaning a contract can change the behavior of a function inherited from a base contract. Sometimes, the overriding function might not have a body. This could be due to a variety of reasons. For instance, the overriding function could be setting up a default behavior (like failing with an error) that can be further overridden in derived contracts, or it could be providing an optional hook that's left empty unless certain specific conditions are met.

In such cases, it can be extremely helpful to future developers, auditors, and users of the contract if a NatSpec comment is added to describe the function's purpose and the reason why it does not have a body. NatSpec, short for Natural Specification, is a form of documentation standard in Ethereum used for expressing what a function does in a human-readable format.

*There are 3 instance(s) of this issue:*

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {}
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override {}
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override {}
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)
### [NC-58]<a name="nc-58"></a> Unused structs present
If these serve no purpose, they should be safely removed

*There are 1 instance(s) of this issue:*

```61:     struct Signature { // <= FOUND
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L61-L61)
### [NC-59]<a name="nc-59"></a> Empty bytes check is missing
When developing smart contracts in Solidity, it's crucial to validate the inputs of your functions. This includes ensuring that the bytes parameters are not empty, especially when they represent crucial data such as addresses, identifiers, or raw data that the contract needs to process.

Missing empty bytes checks can lead to unexpected behaviour in your contract. For instance, certain operations might fail, produce incorrect results, or consume unnecessary gas when performed with empty bytes. Moreover, missing input validation can potentially expose your contract to malicious activity, including exploitation of unhandled edge cases.

To mitigate these issues, always validate that bytes parameters are not empty when the logic of your contract requires it.

*There are 31 instance(s) of this issue:*

```50:     function createRole(
51:         bytes32 role,
52:         bytes32 adminRole
53:     ) external onlyRole(CoreRoles.GOVERNOR) {
54:         _setRoleAdmin(role, adminRole);
55:     }
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L50-L50)

```110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) {
116:         return _cancel(targets, values, calldatas, descriptionHash);
117:     }
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L110)

```123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
129:         return super._cancel(targets, values, calldatas, descriptionHash);
130:     }
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) {
139:         super._execute(proposalId, targets, values, calldatas, descriptionHash);
140:     }
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) {
174:         return super.supportsInterface(interfaceId);
175:     }
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L171-L171)

```30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool) {
34:         return core().hasRole(role, account);
35:     }
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L30-L30)

```171:     function propose(
172:         address[] memory ,
173:         uint256[] memory ,
174:         bytes[] memory ,
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) {
177:         revert("LendingTermOnboarding: cannot propose arbitrary actions");
178:     }
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L171)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId];
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true;
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L195)

```304:     function propose(
305:         address[] memory ,
306:         uint256[] memory ,
307:         bytes[] memory ,
308:         string memory 
309:     ) public pure override returns (uint256) {
310:         revert("GuildVetoGovernor: cannot propose arbitrary actions");
311:     }
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L304-L304)

```315:     function createVeto(bytes32 timelockId) external returns (uint256) {
316:         
317:         uint256 timelockExecutionTime = TimelockController(payable(timelock))
318:             .getTimestamp(timelockId);
319:         require(
320:             timelockExecutionTime > 1,
321:             "GuildVetoGovernor: action must be pending"
322:         );
323: 
324:         
325:         (
326:             address[] memory targets,
327:             uint256[] memory values,
328:             bytes[] memory calldatas,
329:             string memory description
330:         ) = _getVetoCalls(timelockId);
331: 
332:         uint256 proposalId = super.propose(
333:             targets,
334:             values,
335:             calldatas,
336:             description
337:         );
338: 
339:         
340:         _timelockIds[proposalId] = timelockId;
341: 
342:         return proposalId;
343:     }
```

*GitHub* : [315](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L315-L315)

```349:     function executeVeto(bytes32 timelockId) external returns (uint256) {
350:         
351:         (
352:             address[] memory targets,
353:             uint256[] memory values,
354:             bytes[] memory calldatas,
355:             string memory description
356:         ) = _getVetoCalls(timelockId);
357:         
358:         return
359:             super.execute(
360:                 targets,
361:                 values,
362:                 calldatas,
363:                 keccak256(bytes(description))
364:             );
365:     }
```

*GitHub* : [349](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L349-L349)

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); 
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId))
390:         );
391:     }
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L367)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)

```67:     function getAuction(bytes32 loanId) external view returns (Auction memory) {
68:         return auctions[loanId];
69:     }
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L67-L67)

```75:     function startAuction(bytes32 loanId, uint256 callDebt) external {
76:         
77:         require(
78:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
79:             "AuctionHouse: invalid caller"
80:         );
81: 
82:         
83:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId);
84:         require(
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         );
88: 
89:         
90:         require(
91:             auctions[loanId].startTime == 0,
92:             "AuctionHouse: auction exists"
93:         );
94: 
95:         
96:         auctions[loanId] = Auction({
97:             startTime: block.timestamp,
98:             endTime: 0,
99:             lendingTerm: msg.sender,
100:             collateralAmount: loan.collateralAmount,
101:             callDebt: callDebt
102:         });
103:         nAuctionsInProgress++;
104: 
105:         
106:         emit AuctionStart(
107:             block.timestamp,
108:             loanId,
109:             LendingTerm(msg.sender).collateralToken(),
110:             loan.collateralAmount,
111:             callDebt
112:         );
113:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L75-L75)

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) {
121:         
122:         uint256 _startTime = auctions[loanId].startTime;
123:         require(_startTime != 0, "AuctionHouse: invalid auction");
124: 
125:         
126:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended");
127: 
128:         
129:         
130:         
131:         assert(block.timestamp >= _startTime);
132: 
133:         
134:         if (block.timestamp < _startTime + midPoint) {
135:             
136:             creditAsked = auctions[loanId].callDebt;
137: 
138:             
139:             uint256 elapsed = block.timestamp - _startTime; 
140:             uint256 _collateralAmount = auctions[loanId].collateralAmount; 
141:             collateralReceived = (_collateralAmount * elapsed) / midPoint;
142:         }
143:         
144:         else if (block.timestamp < _startTime + auctionDuration) {
145:             
146:             collateralReceived = auctions[loanId].collateralAmount;
147: 
148:             
149:             uint256 PHASE_2_DURATION = auctionDuration - midPoint;
150:             uint256 elapsed = block.timestamp - _startTime - midPoint; 
151:             uint256 _callDebt = auctions[loanId].callDebt; 
152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION;
153:         }
154:         
155:         
156:         else {
157:             
158:             collateralReceived = auctions[loanId].collateralAmount;
159:             
160:         }
161:     }
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L118-L118)

```166:     function bid(bytes32 loanId) external {
167:         
168:         
169:         (uint256 collateralReceived, uint256 creditAsked) = getBidDetail(
170:             loanId
171:         );
172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0");
173: 
174:         
175:         auctions[loanId].endTime = block.timestamp;
176:         nAuctionsInProgress--;
177: 
178:         
179:         address _lendingTerm = auctions[loanId].lendingTerm;
180:         LendingTerm(_lendingTerm).onBid(
181:             loanId,
182:             msg.sender,
183:             auctions[loanId].collateralAmount - collateralReceived, 
184:             collateralReceived, 
185:             creditAsked 
186:         );
187: 
188:         
189:         emit AuctionEnd(
190:             block.timestamp,
191:             loanId,
192:             LendingTerm(_lendingTerm).collateralToken(),
193:             collateralReceived, 
194:             creditAsked 
195:         );
196:     }
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L166-L166)

```202:     function forgive(bytes32 loanId) external {
203:         
204:         
205:         (, uint256 creditAsked) = getBidDetail(loanId);
206:         require(creditAsked == 0, "AuctionHouse: ongoing auction");
207: 
208:         
209:         auctions[loanId].endTime = block.timestamp;
210:         nAuctionsInProgress--;
211: 
212:         
213:         address _lendingTerm = auctions[loanId].lendingTerm;
214:         LendingTerm(_lendingTerm).onBid(
215:             loanId,
216:             msg.sender,
217:             0, 
218:             0, 
219:             0 
220:         );
221: 
222:         
223:         emit AuctionEnd(
224:             block.timestamp,
225:             loanId,
226:             LendingTerm(_lendingTerm).collateralToken(),
227:             0, 
228:             0 
229:         );
230:     }
```

*GitHub* : [202](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L202-L202)

```195:     function getLoan(bytes32 loanId) external view returns (Loan memory) {
196:         return loans[loanId];
197:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L195-L195)

```200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) {
201:         Loan storage loan = loans[loanId];
202:         uint256 borrowTime = loan.borrowTime;
203: 
204:         if (borrowTime == 0) {
205:             return 0;
206:         }
207: 
208:         if (loan.closeTime != 0) {
209:             return 0;
210:         }
211: 
212:         if (loan.callTime != 0) {
213:             return loan.callDebt;
214:         }
215: 
216:         
217:         uint256 borrowAmount = loan.borrowAmount;
218:         uint256 interest = (borrowAmount *
219:             params.interestRate *
220:             (block.timestamp - borrowTime)) /
221:             YEAR /
222:             1e18;
223:         uint256 loanDebt = borrowAmount + interest;
224:         uint256 _openingFee = params.openingFee;
225:         if (_openingFee != 0) {
226:             loanDebt += (borrowAmount * _openingFee) / 1e18;
227:         }
228:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
229:             .creditMultiplier();
230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;
231: 
232:         return loanDebt;
233:     }
```

*GitHub* : [200](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L200-L200)

```237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) {
240:         
241:         if (params.maxDelayBetweenPartialRepay == 0) return false;
242: 
243:         
244:         if (loans[loanId].borrowTime == 0) return false;
245: 
246:         
247:         if (loans[loanId].closeTime != 0) return false;
248: 
249:         
250:         return
251:             lastPartialRepay[loanId] <
252:             block.timestamp - params.maxDelayBetweenPartialRepay;
253:     }
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L237-L237)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal {
453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0");
454: 
455:         Loan storage loan = loans[loanId];
456: 
457:         
458:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
459:         require(loan.closeTime == 0, "LendingTerm: loan closed");
460:         require(loan.callTime == 0, "LendingTerm: loan called");
461: 
462:         
463:         loans[loanId].collateralAmount += collateralToAdd;
464: 
465:         
466:         IERC20(params.collateralToken).safeTransferFrom(
467:             borrower,
468:             address(this),
469:             collateralToAdd
470:         );
471: 
472:         
473:         emit LoanAddCollateral(
474:             block.timestamp,
475:             loanId,
476:             borrower,
477:             collateralToAdd
478:         );
479:     }
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```482:     function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {
483:         _addCollateral(msg.sender, loanId, collateralToAdd);
484:     }
```

*GitHub* : [482](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L482-L482)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```562:     function partialRepay(bytes32 loanId, uint256 debtToRepay) external {
563:         _partialRepay(msg.sender, loanId, debtToRepay);
564:     }
```

*GitHub* : [562](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L562-L562)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```628:     function repay(bytes32 loanId) external {
629:         _repay(msg.sender, loanId);
630:     }
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L628-L628)

```634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal {
639:         Loan storage loan = loans[loanId];
640: 
641:         
642:         uint256 borrowTime = loan.borrowTime;
643:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
644: 
645:         
646:         require(loan.closeTime == 0, "LendingTerm: loan closed");
647: 
648:         
649:         require(loan.callTime == 0, "LendingTerm: loan called");
650: 
651:         
652:         require(
653:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||
654:                 partialRepayDelayPassed(loanId),
655:             "LendingTerm: cannot call"
656:         );
657: 
658:         
659:         require(
660:             borrowTime < block.timestamp,
661:             "LendingTerm: loan opened in same block"
662:         );
663: 
664:         
665:         uint256 loanDebt = getLoanDebt(loanId);
666:         loans[loanId].callTime = block.timestamp;
667:         loans[loanId].callDebt = loanDebt;
668:         loans[loanId].caller = caller;
669: 
670:         
671:         AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);
672: 
673:         
674:         emit LoanCall(block.timestamp, loanId);
675:     }
```

*GitHub* : [634](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L634-L634)

```678:     function call(bytes32 loanId) external {
679:         _call(msg.sender, loanId, refs.auctionHouse);
680:     }
```

*GitHub* : [678](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L678-L678)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {
696:         Loan storage loan = loans[loanId];
697: 
698:         
699:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
700: 
701:         
702:         require(loan.closeTime == 0, "LendingTerm: loan closed");
703: 
704:         
705:         loans[loanId].closeTime = block.timestamp;
706:         issuance -= loan.borrowAmount;
707: 
708:         
709:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
710:             .creditMultiplier();
711:         uint256 borrowAmount = loans[loanId].borrowAmount;
712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
714:         int256 pnl = -int256(principal);
715:         ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
716: 
717:         
718:         params.hardCap = 0;
719: 
720:         
721:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);
722:     }
```

*GitHub* : [695](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L695-L695)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)
### [NC-60]<a name="nc-60"></a> No equate comparison checks between to and from address parameters
The function lacks a standard check: it does not validate if the 'to' and 'from' addresses are identical. This omission can lead to unintended outcomes if the same address is used in both parameters. To rectify this, we recommend implementing a comparison check at the beginning of the function. In the context of Solidity, the command `require(to != from, "To and From addresses can't be the same");` could be utilized. This addition will generate an error if the 'to' and 'from' addresses are the same, thereby fortifying the function's robustness and security.

*There are 5 instance(s) of this issue:*

```489:     function transferFrom(
490:         address from, // <= FOUND
491:         address to, // <= FOUND
492:         uint256 amount
493:     ) public virtual override returns (bool) {
494:         _decrementWeightUntilFree(from, amount);
495:         return super.transferFrom(from, to, amount);
496:     }
```

*GitHub* : [489](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L489-L491)

```416:     function transferFrom(
417:         address from, // <= FOUND
418:         address to, // <= FOUND
419:         uint256 amount
420:     ) public virtual override returns (bool) {
421:         _decrementVotesUntilFree(from, amount);
422:         return super.transferFrom(from, to, amount);
423:     }
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L418)

```646:     function transferFrom(
647:         address from, // <= FOUND
648:         address to, // <= FOUND
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         
652:         
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
657:             rebasingStateTo.isRebasing == 1)
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) {
661:             uint256 shares = uint256(rebasingStateFrom.nShares);
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount;
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         
678:         bool success = ERC20.transferFrom(from, to, amount);
679: 
680:         
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) {
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
689:             sharesDelta -= int256(sharesSpent);
690:             rebasingState[from] = RebasingState({
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
696:         
697:         if (rebasingStateTo.isRebasing == 1) {
```

*GitHub* : [646](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L646-L648)

```125:     function transferFrom(
126:         address from, // <= FOUND
127:         address to, // <= FOUND
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     {
134:         _decrementVotesUntilFree(from, amount); 
135:         return ERC20RebaseDistributor.transferFrom(from, to, amount);
136:     }
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L127)

```302:     function transferFrom(
303:         address from, // <= FOUND
304:         address to, // <= FOUND
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     {
312:         _decrementWeightUntilFree(from, amount);
313:         _decrementVotesUntilFree(from, amount);
314:         return ERC20.transferFrom(from, to, amount);
315:     }
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L304)
### [NC-61]<a name="nc-61"></a> Return bool not explicit
In Solidity, when designing functions that return boolean values, it's crucial for clarity and maintainability to explicitly handle both `true` and `false` return scenarios. If a function is intended to return `true` under certain conditions, it should also explicitly return `false` when these conditions are not met, and vice versa. This approach eliminates ambiguity and makes the code's intent more transparent. Explicitly handling all possible outcomes of a boolean function ensures that future modifications or extensions of the contract do not unintentionally alter its logic. It contributes to better readability, easier debugging, and reduces the risk of bugs related to unintended fall-through cases.

*There are 2 instance(s) of this issue:*

```186:     function _voteSucceeded(
187:         uint256 
188:     ) internal pure virtual override returns (bool) {
189:         return true; // <= FOUND
190:     }
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L189)

```237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) {
240:         
241:         if (params.maxDelayBetweenPartialRepay == 0) return false; // <= FOUND
242: 
243:         
244:         if (loans[loanId].borrowTime == 0) return false; // <= FOUND
245: 
246:         
247:         if (loans[loanId].closeTime != 0) return false; // <= FOUND
248: 
249:         
250:         return
251:             lastPartialRepay[loanId] <
252:             block.timestamp - params.maxDelayBetweenPartialRepay;
253:     }
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L237-L247)
### [NC-62]<a name="nc-62"></a> Remove unnecessary solhint-disable

*There are 1 instance(s) of this issue:*

```129:     // solhint-disable-next-line func-name-mixedcase // <= FOUND
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L129-L129)
### [NC-63]<a name="nc-63"></a> Consider using SMTChecker
The SMTChecker is a valuable tool for Solidity developers as it helps detect potential vulnerabilities and logical errors in the contract's code. By utilizing Satisfiability Modulo Theories (SMT) solvers, it can reason about the potential states a contract can be in, and therefore, identify conditions that could lead to undesirable behavior. This automatic formal verification can catch issues that might otherwise be missed in manual code reviews or standard testing, enhancing the overall contract's security and reliability.

*There are 20 instance(s) of this issue:*

```1: // SPDX-License-Identifier: MIT
2: // Voting logic inspired by OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Votes.sol)
3: 
4: pragma solidity 0.8.13;
5: 
6: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
7: import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
8: 
9: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol";
10: 
11: /**
12: @title  ERC20 Multi-Delegation Voting contract
13: @notice an ERC20 extension which allows delegations to multiple delegatees up to a user's balance on a given block.
14: @dev    SECURITY NOTES: `maxDelegates` is a critical variable to protect against gas DOS attacks upon token transfer. 
15:         This must be low enough to allow complicated transactions to fit in a block.
16: @dev This contract was originally published as part of TribeDAO's flywheel-v2 repo, please see:
17:     https://github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20MultiVotes.sol
18:     The original version was included in 2 audits :
19:     - https://code4rena.com/reports/2022-04-xtribe/
20:     - https://consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/
21:     ECG made the following changes to the original flywheel-v2 version :
22:     - Does not inherit Solmate's Auth (all requiresAuth functions are now internal, see below)
23:         -> This contract is abstract, and permissioned public functions can be added in parent.
24:         -> permissioned public functions to add in parent:
25:             - function setMaxDelegates(uint256) external
26:             - function setContractExceedMaxDelegates(address,bool) external
27:     - Remove public setMaxDelegates(uint256) requiresAuth method 
28:         ... Add internal _setMaxDelegates(uint256) method
29:     - Remove public setContractExceedMaxDelegates(address,bool) requiresAuth method
30:         ... Add internal _setContractExceedMaxDelegates(address,bool) method
31:     - Import OpenZeppelin ERC20Permit & EnumerableSet instead of Solmate's
32:     - Update error management style (use require + messages instead of Solidity errors)
33:     - Implement C4 audit fix for [L-01] & [N-06].
34: */
35: abstract contract ERC20MultiVotes is ERC20Permit {
36:     using EnumerableSet for EnumerableSet.AddressSet;
37:     using SafeCastLib for *;
38: 
39:     /*///////////////////////////////////////////////////////////////
40:                         VOTE CALCULATION LOGIC
41:     //////////////////////////////////////////////////////////////*/
42: 
43:     struct Checkpoint {
44:         uint32 fromBlock;
45:         uint224 votes;
46:     }
47: 
48:     /// @notice votes checkpoint list per user.
49:     mapping(address => Checkpoint[]) private _checkpoints;
50: 
51:     /// @notice Get the `pos`-th checkpoint for `account`.
52:     function checkpoints(
53:         address account,
54:         uint32 pos
55:     ) public view virtual returns (Checkpoint memory) {
56:         return _checkpoints[account][pos];
57:     }
58: 
59:     /// @notice Get number of checkpoints for `account`.
60:     function numCheckpoints(
61:         address account
62:     ) public view virtual returns (uint32) {
63:         return _checkpoints[account].length.safeCastTo32();
64:     }
65: 
66:     /**
67:      * @notice Gets the amount of unallocated votes for `account`.
68:      * @param account the address to get free votes of.
69:      * @return the amount of unallocated votes.
70:      */
71:     function freeVotes(address account) public view virtual returns (uint256) {
72:         return balanceOf(account) - userDelegatedVotes[account];
73:     }
74: 
75:     /**
76:      * @notice Gets the current votes balance for `account`.
77:      * @param account the address to get votes of.
78:      * @return the amount of votes.
79:      */
80:     function getVotes(address account) public view virtual returns (uint256) {
81:         uint256 pos = _checkpoints[account].length;
82:         return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;
83:     }
84: 
85:     /**
86:      * @notice Retrieve the number of votes for `account` at the end of `blockNumber`.
87:      * @param account the address to get votes of.
88:      * @param blockNumber the block to calculate votes for.
89:      * @return the amount of votes.
90:      */
91:     function getPastVotes(
92:         address account,
93:         uint256 blockNumber
94:     ) public view virtual returns (uint256) {
95:         require(
96:             blockNumber < block.number,
97:             "ERC20MultiVotes: not a past block"
98:         );
99:         return _checkpointsLookup(_checkpoints[account], blockNumber);
100:     }
101: 
102:     /// @dev Lookup a value in a list of (sorted) checkpoints.
103:     function _checkpointsLookup(
104:         Checkpoint[] storage ckpts,
105:         uint256 blockNumber
106:     ) private view returns (uint256) {
107:         // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.
108:         uint256 high = ckpts.length;
109:         uint256 low = 0;
110:         while (low < high) {
111:             uint256 mid = average(low, high);
112:             if (ckpts[mid].fromBlock > blockNumber) {
113:                 high = mid;
114:             } else {
115:                 low = mid + 1;
116:             }
117:         }
118: 
119:         return high == 0 ? 0 : ckpts[high - 1].votes;
120:     }
121: 
122:     function average(uint256 a, uint256 b) internal pure returns (uint256) {
123:         // (a + b) / 2 can overflow.
124:         return (a & b) + (a ^ b) / 2;
125:     }
126: 
127:     /*///////////////////////////////////////////////////////////////
128:                         ADMIN OPERATIONS
129:     //////////////////////////////////////////////////////////////*/
130: 
131:     /// @notice emitted when updating the maximum amount of delegates per user
132:     event MaxDelegatesUpdate(uint256 oldMaxDelegates, uint256 newMaxDelegates);
133: 
134:     /// @notice emitted when updating the canContractExceedMaxDelegates flag for an account
135:     event CanContractExceedMaxDelegatesUpdate(
136:         address indexed account,
137:         bool canContractExceedMaxDelegates
138:     );
139: 
140:     /// @notice the maximum amount of delegates for a user at a given time
141:     uint256 public maxDelegates;
142: 
143:     /// @notice an approve list for contracts to go above the max delegate limit.
144:     mapping(address => bool) public canContractExceedMaxDelegates;
145: 
146:     /// @notice set the new max delegates per user. Requires auth by `authority`.
147:     function _setMaxDelegates(uint256 newMax) internal {
148:         uint256 oldMax = maxDelegates;
149:         maxDelegates = newMax;
150: 
151:         emit MaxDelegatesUpdate(oldMax, newMax);
152:     }
153: 
154:     /// @notice set the canContractExceedMaxDelegates flag for an account.
155:     function _setContractExceedMaxDelegates(
156:         address account,
157:         bool canExceedMax
158:     ) internal {
159:         require(
160:             !canExceedMax || account.code.length != 0,
161:             "ERC20MultiVotes: not a smart contract"
162:         ); // can only approve contracts
163: 
164:         canContractExceedMaxDelegates[account] = canExceedMax;
165: 
166:         emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);
167:     }
168: 
169:     /*///////////////////////////////////////////////////////////////
170:                         DELEGATION LOGIC
171:     //////////////////////////////////////////////////////////////*/
172: 
173:     /// @dev Emitted when a `delegator` delegates `amount` votes to `delegate`.
174:     event Delegation(
175:         address indexed delegator,
176:         address indexed delegate,
177:         uint256 amount
178:     );
179: 
180:     /// @dev Emitted when a `delegator` undelegates `amount` votes from `delegate`.
181:     event Undelegation(
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
186: 
187:     /// @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.
188:     event DelegateVotesChanged(
189:         address indexed delegate,
190:         uint256 previousBalance,
191:         uint256 newBalance
192:     );
193: 
194:     /// @notice An event that is emitted when an account changes its delegate
195:     /// @dev this is used for backward compatibility with OZ interfaces for ERC20Votes and ERC20VotesComp.
196:     event DelegateChanged(
197:         address indexed delegator,
198:         address indexed fromDelegate,
199:         address indexed toDelegate
200:     );
201: 
202:     /// @notice mapping from a delegator and delegatee to the delegated amount.
203:     mapping(address => mapping(address => uint256))
204:         private _delegatesVotesCount;
205: 
206:     /// @notice mapping from a delegator to the total number of delegated votes.
207:     mapping(address => uint256) public userDelegatedVotes;
208: 
209:     /// @notice list of delegates per user.
210:     mapping(address => EnumerableSet.AddressSet) private _delegates;
211: 
212:     /**
213:      * @notice Get the amount of votes currently delegated by `delegator` to `delegatee`.
214:      * @param delegator the account which is delegating votes to `delegatee`.
215:      * @param delegatee the account receiving votes from `delegator`.
216:      * @return the total amount of votes delegated to `delegatee` by `delegator`
217:      */
218:     function delegatesVotesCount(
219:         address delegator,
220:         address delegatee
221:     ) public view virtual returns (uint256) {
222:         return _delegatesVotesCount[delegator][delegatee];
223:     }
224: 
225:     /**
226:      * @notice Get the list of delegates from `delegator`.
227:      * @param delegator the account which is delegating votes to delegates.
228:      * @return the list of delegated accounts.
229:      */
230:     function delegates(
231:         address delegator
232:     ) public view returns (address[] memory) {
233:         return _delegates[delegator].values();
234:     }
235: 
236:     /**
237:      * @notice Checks whether delegatee is in the `delegator` mapping.
238:      * @param delegator the account which is delegating votes to delegates.
239:      * @param delegatee the account which receives votes from delegate.
240:      * @return true or false
241:      */
242:     function containsDelegate(
243:         address delegator,
244:         address delegatee
245:     ) public view returns (bool) {
246:         return _delegates[delegator].contains(delegatee);
247:     }
248: 
249:     /**
250:      * @notice Get the number of delegates from `delegator`.
251:      * @param delegator the account which is delegating votes to delegates.
252:      * @return the number of delegated accounts.
253:      */
254:     function delegateCount(address delegator) public view returns (uint256) {
255:         return _delegates[delegator].length();
256:     }
257: 
258:     /**
259:      * @notice Delegate `amount` votes from the sender to `delegatee`.
260:      * @param delegatee the receiver of votes.
261:      * @param amount the amount of votes received.
262:      * @dev requires "freeVotes(msg.sender) > amount" and will not exceed max delegates
263:      */
264:     function incrementDelegation(
265:         address delegatee,
266:         uint256 amount
267:     ) public virtual {
268:         _incrementDelegation(msg.sender, delegatee, amount);
269:     }
270: 
271:     /**
272:      * @notice Undelegate `amount` votes from the sender from `delegatee`.
273:      * @param delegatee the receivier of undelegation.
274:      * @param amount the amount of votes taken away.
275:      */
276:     function undelegate(address delegatee, uint256 amount) public virtual {
277:         _undelegate(msg.sender, delegatee, amount);
278:     }
279: 
280:     /**
281:      * @notice Delegate all votes `newDelegatee`. First undelegates from an existing delegate. If `newDelegatee` is zero, only undelegates.
282:      * @param newDelegatee the receiver of votes.
283:      * @dev undefined for `delegateCount(msg.sender) > 1`
284:      * NOTE This is meant for backward compatibility with the `ERC20Votes` and `ERC20VotesComp` interfaces from OpenZeppelin.
285:      */
286:     function delegate(address newDelegatee) external virtual {
287:         _delegate(msg.sender, newDelegatee);
288:     }
289: 
290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual {
294:         uint256 count = delegateCount(delegator);
295: 
296:         // undefined behavior for delegateCount > 1
297:         require(count < 2, "ERC20MultiVotes: delegation error");
298: 
299:         address oldDelegatee;
300:         // if already delegated, undelegate first
301:         if (count == 1) {
302:             oldDelegatee = _delegates[delegator].at(0);
303:             _undelegate(
304:                 delegator,
305:                 oldDelegatee,
306:                 _delegatesVotesCount[delegator][oldDelegatee]
307:             );
308:         }
309: 
310:         // redelegate only if newDelegatee is not empty
311:         if (newDelegatee != address(0)) {
312:             _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));
313:         }
314:         emit DelegateChanged(delegator, oldDelegatee, newDelegatee);
315:     }
316: 
317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual {
322:         // Require freeVotes exceed the delegation size
323:         uint256 free = freeVotes(delegator);
324:         require(
325:             delegatee != address(0) && free >= amount,
326:             "ERC20MultiVotes: delegation error"
327:         );
328: 
329:         bool newDelegate = _delegates[delegator].add(delegatee); // idempotent add
330:         require(
331:             !newDelegate ||
332:                 delegateCount(delegator) <= maxDelegates ||
333:                 canContractExceedMaxDelegates[delegator],
334:             "ERC20MultiVotes: delegation error"
335:         );
336: 
337:         _delegatesVotesCount[delegator][delegatee] += amount;
338:         userDelegatedVotes[delegator] += amount;
339: 
340:         emit Delegation(delegator, delegatee, amount);
341:         _writeCheckpoint(delegatee, _add, amount);
342:     }
343: 
344:     function _undelegate(
345:         address delegator,
346:         address delegatee,
347:         uint256 amount
348:     ) internal virtual {
349:         uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] -
350:             amount;
351: 
352:         if (newDelegates == 0) {
353:             require(_delegates[delegator].remove(delegatee));
354:         }
355: 
356:         _delegatesVotesCount[delegator][delegatee] = newDelegates;
357:         userDelegatedVotes[delegator] -= amount;
358: 
359:         emit Undelegation(delegator, delegatee, amount);
360:         _writeCheckpoint(delegatee, _subtract, amount);
361:     }
362: 
363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private {
368:         Checkpoint[] storage ckpts = _checkpoints[delegatee];
369: 
370:         uint256 pos = ckpts.length;
371:         uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;
372:         uint256 newWeight = op(oldWeight, delta);
373: 
374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {
375:             ckpts[pos - 1].votes = newWeight.safeCastTo224();
376:         } else {
377:             ckpts.push(
378:                 Checkpoint({
379:                     fromBlock: block.number.safeCastTo32(),
380:                     votes: newWeight.safeCastTo224()
381:                 })
382:             );
383:         }
384:         emit DelegateVotesChanged(delegatee, oldWeight, newWeight);
385:     }
386: 
387:     function _add(uint256 a, uint256 b) private pure returns (uint256) {
388:         return a + b;
389:     }
390: 
391:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) {
392:         return a - b;
393:     }
394: 
395:     /*///////////////////////////////////////////////////////////////
396:                              ERC20 LOGIC
397:     //////////////////////////////////////////////////////////////*/
398: 
399:     /// NOTE: any "removal" of tokens from a user requires freeVotes(user) < amount.
400:     /// _decrementVotesUntilFree is called as a greedy algorithm to free up votes.
401:     /// It may be more gas efficient to free weight before burning or transferring tokens.
402: 
403:     function _burn(address from, uint256 amount) internal virtual override {
404:         _decrementVotesUntilFree(from, amount);
405:         super._burn(from, amount);
406:     }
407: 
408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) {
412:         _decrementVotesUntilFree(msg.sender, amount);
413:         return super.transfer(to, amount);
414:     }
415: 
416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) {
421:         _decrementVotesUntilFree(from, amount);
422:         return super.transferFrom(from, to, amount);
423:     }
424: 
425:     /// a greedy algorithm for freeing votes before a token burn/transfer
426:     /// frees up entire delegates, so likely will free more than `votes`
427:     function _decrementVotesUntilFree(address user, uint256 votes) internal {
428:         uint256 userFreeVotes = freeVotes(user);
429: 
430:         // early return if already free
431:         if (userFreeVotes >= votes) return;
432: 
433:         // cache total for batch updates
434:         uint256 totalFreed;
435: 
436:         // Loop through all delegates
437:         address[] memory delegateList = _delegates[user].values();
438: 
439:         // Free delegates until through entire list or under votes amount
440:         uint256 size = delegateList.length;
441:         for (
442:             uint256 i = 0;
443:             i < size && (userFreeVotes + totalFreed) < votes;
444:             i++
445:         ) {
446:             address delegatee = delegateList[i];
447:             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];
448:             if (delegateVotes != 0) {
449:                 totalFreed += delegateVotes;
450: 
451:                 require(_delegates[user].remove(delegatee)); // Remove from set. Should never fail.
452: 
453:                 _delegatesVotesCount[user][delegatee] = 0;
454: 
455:                 _writeCheckpoint(delegatee, _subtract, delegateVotes);
456:                 emit Undelegation(user, delegatee, delegateVotes);
457:             }
458:         }
459: 
460:         userDelegatedVotes[user] -= totalFreed;
461:     }
462: 
463:     /*///////////////////////////////////////////////////////////////
464:                              EIP-712 LOGIC
465:     //////////////////////////////////////////////////////////////*/
466: 
467:     bytes32 public constant DELEGATION_TYPEHASH =
468:         keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
469: 
470:     /// @dev this consumes the same nonce as permit(), so the order of call matters.
471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
506: }
507: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: /**
5: @title Ethereum Credit Guild ACL Roles
6: @notice Holds a complete list of all roles which can be held by contracts inside the Ethereum Credit Guild.
7: */
8: library CoreRoles {
9:     /// ----------- Core roles for access control --------------
10: 
11:     /// @notice the all-powerful role. Controls all other roles and protocol functionality.
12:     bytes32 internal constant GOVERNOR = keccak256("GOVERNOR_ROLE");
13: 
14:     /// @notice the protector role. Can pause contracts and revoke roles in an emergency.
15:     bytes32 internal constant GUARDIAN = keccak256("GUARDIAN_ROLE");
16: 
17:     /// ----------- Token supply roles -------------------------
18: 
19:     /// @notice can mint CREDIT arbitrarily
20:     bytes32 internal constant CREDIT_MINTER = keccak256("CREDIT_MINTER_ROLE");
21: 
22:     /// @notice can mint CREDIT within rate limits & cap
23:     bytes32 internal constant RATE_LIMITED_CREDIT_MINTER =
24:         keccak256("RATE_LIMITED_CREDIT_MINTER_ROLE");
25: 
26:     /// @notice can mint GUILD arbitrarily
27:     bytes32 internal constant GUILD_MINTER = keccak256("GUILD_MINTER_ROLE");
28: 
29:     /// @notice can mint GUILD within rate limits & cap
30:     bytes32 internal constant RATE_LIMITED_GUILD_MINTER =
31:         keccak256("RATE_LIMITED_GUILD_MINTER_ROLE");
32: 
33:     /// ----------- GUILD Token Management ---------------
34: 
35:     /// @notice can manage add new gauges to the system
36:     bytes32 internal constant GAUGE_ADD = keccak256("GAUGE_ADD_ROLE");
37: 
38:     /// @notice can remove gauges from the system
39:     bytes32 internal constant GAUGE_REMOVE = keccak256("GAUGE_REMOVE_ROLE");
40: 
41:     /// @notice can manage gauge parameters (max gauges, individual cap)
42:     bytes32 internal constant GAUGE_PARAMETERS =
43:         keccak256("GAUGE_PARAMETERS_ROLE");
44: 
45:     /// @notice can notify of profits & losses in a given gauge
46:     bytes32 internal constant GAUGE_PNL_NOTIFIER =
47:         keccak256("GAUGE_PNL_NOTIFIER_ROLE");
48: 
49:     /// @notice can update governance parameters for GUILD delegations
50:     bytes32 internal constant GUILD_GOVERNANCE_PARAMETERS =
51:         keccak256("GUILD_GOVERNANCE_PARAMETERS_ROLE");
52: 
53:     /// @notice can withdraw from GUILD surplus buffer
54:     bytes32 internal constant GUILD_SURPLUS_BUFFER_WITHDRAW =
55:         keccak256("GUILD_SURPLUS_BUFFER_WITHDRAW_ROLE");
56: 
57:     /// ----------- CREDIT Token Management ---------------
58: 
59:     /// @notice can update governance parameters for CREDIT delegations
60:     bytes32 internal constant CREDIT_GOVERNANCE_PARAMETERS =
61:         keccak256("CREDIT_GOVERNANCE_PARAMETERS_ROLE");
62: 
63:     /// @notice can update rebase parameters for CREDIT holders
64:     bytes32 internal constant CREDIT_REBASE_PARAMETERS =
65:         keccak256("CREDIT_REBASE_PARAMETERS_ROLE");
66: 
67:     /// ----------- Timelock management ------------------------
68:     /// The hashes are the same as OpenZeppelins's roles in TimelockController
69: 
70:     /// @notice can propose new actions in timelocks
71:     bytes32 internal constant TIMELOCK_PROPOSER = keccak256("PROPOSER_ROLE");
72: 
73:     /// @notice can execute actions in timelocks after their delay
74:     bytes32 internal constant TIMELOCK_EXECUTOR = keccak256("EXECUTOR_ROLE");
75: 
76:     /// @notice can cancel actions in timelocks
77:     bytes32 internal constant TIMELOCK_CANCELLER = keccak256("CANCELLER_ROLE");
78: }
79: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {CoreRoles} from "@src/core/CoreRoles.sol";
5: import {AccessControlEnumerable} from "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
6: 
7: /// @title Core access control of the Ethereum Credit Guild
8: /// @author eswak
9: /// @notice maintains roles and access control
10: contract Core is AccessControlEnumerable {
11:     /// @notice construct Core
12:     constructor() {
13:         // For initial setup before going live, deployer can then call
14:         // renounceRole(bytes32 role, address account)
15:         _grantRole(CoreRoles.GOVERNOR, msg.sender);
16: 
17:         // Initial roles setup: direct hierarchy, everything under governor
18:         _setRoleAdmin(CoreRoles.GOVERNOR, CoreRoles.GOVERNOR);
19:         _setRoleAdmin(CoreRoles.GUARDIAN, CoreRoles.GOVERNOR);
20:         _setRoleAdmin(CoreRoles.CREDIT_MINTER, CoreRoles.GOVERNOR);
21:         _setRoleAdmin(CoreRoles.RATE_LIMITED_CREDIT_MINTER, CoreRoles.GOVERNOR);
22:         _setRoleAdmin(CoreRoles.GUILD_MINTER, CoreRoles.GOVERNOR);
23:         _setRoleAdmin(CoreRoles.RATE_LIMITED_GUILD_MINTER, CoreRoles.GOVERNOR);
24:         _setRoleAdmin(CoreRoles.GAUGE_ADD, CoreRoles.GOVERNOR);
25:         _setRoleAdmin(CoreRoles.GAUGE_REMOVE, CoreRoles.GOVERNOR);
26:         _setRoleAdmin(CoreRoles.GAUGE_PARAMETERS, CoreRoles.GOVERNOR);
27:         _setRoleAdmin(CoreRoles.GAUGE_PNL_NOTIFIER, CoreRoles.GOVERNOR);
28:         _setRoleAdmin(
29:             CoreRoles.GUILD_GOVERNANCE_PARAMETERS,
30:             CoreRoles.GOVERNOR
31:         );
32:         _setRoleAdmin(
33:             CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW,
34:             CoreRoles.GOVERNOR
35:         );
36:         _setRoleAdmin(
37:             CoreRoles.CREDIT_GOVERNANCE_PARAMETERS,
38:             CoreRoles.GOVERNOR
39:         );
40:         _setRoleAdmin(CoreRoles.CREDIT_REBASE_PARAMETERS, CoreRoles.GOVERNOR);
41:         _setRoleAdmin(CoreRoles.TIMELOCK_PROPOSER, CoreRoles.GOVERNOR);
42:         _setRoleAdmin(CoreRoles.TIMELOCK_EXECUTOR, CoreRoles.GOVERNOR);
43:         _setRoleAdmin(CoreRoles.TIMELOCK_CANCELLER, CoreRoles.GOVERNOR);
44:     }
45: 
46:     /// @notice creates a new role to be maintained
47:     /// @param role the new role id
48:     /// @param adminRole the admin role id for `role`
49:     /// @dev can also be used to update admin of existing role
50:     function createRole(
51:         bytes32 role,
52:         bytes32 adminRole
53:     ) external onlyRole(CoreRoles.GOVERNOR) {
54:         _setRoleAdmin(role, adminRole);
55:     }
56: 
57:     // AccessControlEnumerable is AccessControl, and also has the following functions :
58:     // hasRole(bytes32 role, address account) -> bool
59:     // getRoleAdmin(bytes32 role) -> bytes32
60:     // grantRole(bytes32 role, address account)
61:     // revokeRole(bytes32 role, address account)
62:     // renounceRole(bytes32 role, address account)
63: }
64: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {CoreRef} from "@src/core/CoreRef.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: import {LendingTerm} from "@src/loan/LendingTerm.sol";
7: 
8: /// @notice Auction House contract of the Ethereum Credit Guild,
9: /// where collateral of borrowers is auctioned to cover their CREDIT debt.
10: contract AuctionHouse is CoreRef {
11:     /// @notice emitted when au action starts
12:     event AuctionStart(
13:         uint256 indexed when,
14:         bytes32 indexed loanId,
15:         address collateralToken,
16:         uint256 collateralAmount,
17:         uint256 callDebt
18:     );
19:     /// @notice emitted when au anction ends
20:     event AuctionEnd(
21:         uint256 indexed when,
22:         bytes32 indexed loanId,
23:         address collateralToken,
24:         uint256 collateralSold,
25:         uint256 debtRecovered
26:     );
27: 
28:     /// @notice number of seconds before the midpoint of the auction, at which time the
29:     /// mechanism switches from "offer an increasing amount of collateral" to
30:     /// "ask a decreasing amount of debt".
31:     uint256 public immutable midPoint;
32: 
33:     /// @notice maximum duration of auctions, in seconds.
34:     /// with a midpoint of 650 (10m50s) and an auction duration of 30min, and a block every
35:     /// 13s, first phase will last around 50 blocks and each block will offer an additional
36:     /// 1/(650/13)=2% of the collateral during the first phase. During the second phase,
37:     /// every block will ask 1/((1800-650)/13)=1.13% less CREDIT in each block.
38:     uint256 public immutable auctionDuration;
39: 
40:     struct Auction {
41:         uint256 startTime;
42:         uint256 endTime;
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
47: 
48:     /// @notice the list of all auctions that existed or are still active.
49:     /// key is the loanId for which the auction has been created.
50:     /// @dev see public getAuction(loanId) getter.
51:     mapping(bytes32 => Auction) internal auctions;
52: 
53:     /// @notice number of auctions currently in progress
54:     uint256 public nAuctionsInProgress;
55: 
56:     constructor(
57:         address _core,
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) {
61:         require(_midPoint < _auctionDuration, "AuctionHouse: invalid params");
62:         midPoint = _midPoint;
63:         auctionDuration = _auctionDuration;
64:     }
65: 
66:     /// @notice get a full auction structure from storage
67:     function getAuction(bytes32 loanId) external view returns (Auction memory) {
68:         return auctions[loanId];
69:     }
70: 
71:     /// @notice start the auction of the collateral of a loan, to be exchanged for CREDIT,
72:     /// in order to pay the debt of a loan.
73:     /// @param loanId the ID of the loan which collateral is auctioned
74:     /// @param callDebt the amount of CREDIT debt to recover from the collateral auction
75:     function startAuction(bytes32 loanId, uint256 callDebt) external {
76:         // check that caller is a lending term that still has PnL reporting role
77:         require(
78:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
79:             "AuctionHouse: invalid caller"
80:         );
81: 
82:         // check the loan exists in calling lending term and has been called in the current block
83:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId);
84:         require(
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         );
88: 
89:         // check auction for this loan has not already been created
90:         require(
91:             auctions[loanId].startTime == 0,
92:             "AuctionHouse: auction exists"
93:         );
94: 
95:         // save auction in state
96:         auctions[loanId] = Auction({
97:             startTime: block.timestamp,
98:             endTime: 0,
99:             lendingTerm: msg.sender,
100:             collateralAmount: loan.collateralAmount,
101:             callDebt: callDebt
102:         });
103:         nAuctionsInProgress++;
104: 
105:         // emit event
106:         emit AuctionStart(
107:             block.timestamp,
108:             loanId,
109:             LendingTerm(msg.sender).collateralToken(),
110:             loan.collateralAmount,
111:             callDebt
112:         );
113:     }
114: 
115:     /// @notice Get the bid details for an active auction.
116:     /// During the first half of the auction, an increasing amount of the collateral is offered, for the full CREDIT amount.
117:     /// During the second half of the action, all collateral is offered, for a decreasing CREDIT amount.
118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) {
121:         // check the auction for this loan exists
122:         uint256 _startTime = auctions[loanId].startTime;
123:         require(_startTime != 0, "AuctionHouse: invalid auction");
124: 
125:         // check the auction for this loan isn't ended
126:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended");
127: 
128:         // assertion should never fail because when an auction is created,
129:         // block.timestamp is recorded as the auction start time, and we check in previous
130:         // lines that start time != 0, so the auction has started.
131:         assert(block.timestamp >= _startTime);
132: 
133:         // first phase of the auction, where more and more collateral is offered
134:         if (block.timestamp < _startTime + midPoint) {
135:             // ask for the full debt
136:             creditAsked = auctions[loanId].callDebt;
137: 
138:             // compute amount of collateral received
139:             uint256 elapsed = block.timestamp - _startTime; // [0, midPoint[
140:             uint256 _collateralAmount = auctions[loanId].collateralAmount; // SLOAD
141:             collateralReceived = (_collateralAmount * elapsed) / midPoint;
142:         }
143:         // second phase of the auction, where less and less CREDIT is asked
144:         else if (block.timestamp < _startTime + auctionDuration) {
145:             // receive the full collateral
146:             collateralReceived = auctions[loanId].collateralAmount;
147: 
148:             // compute amount of CREDIT to ask
149:             uint256 PHASE_2_DURATION = auctionDuration - midPoint;
150:             uint256 elapsed = block.timestamp - _startTime - midPoint; // [0, PHASE_2_DURATION[
151:             uint256 _callDebt = auctions[loanId].callDebt; // SLOAD
152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION;
153:         }
154:         // second phase fully elapsed, anyone can receive the full collateral and give 0 CREDIT
155:         // in practice, somebody should have taken the arb before we reach this condition.
156:         else {
157:             // receive the full collateral
158:             collateralReceived = auctions[loanId].collateralAmount;
159:             //creditAsked = 0; // implicit
160:         }
161:     }
162: 
163:     /// @notice bid for an active auction
164:     /// @dev as a bidder, you must approve CREDIT tokens on the LendingTerm contract associated
165:     /// with the loan `getAuction(loanId).lendingTerm`, not on the AuctionHouse itself.
166:     function bid(bytes32 loanId) external {
167:         // this view function will revert if the auction is not started,
168:         // or if the auction is already ended.
169:         (uint256 collateralReceived, uint256 creditAsked) = getBidDetail(
170:             loanId
171:         );
172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0");
173: 
174:         // close the auction in state
175:         auctions[loanId].endTime = block.timestamp;
176:         nAuctionsInProgress--;
177: 
178:         // notify LendingTerm of auction result
179:         address _lendingTerm = auctions[loanId].lendingTerm;
180:         LendingTerm(_lendingTerm).onBid(
181:             loanId,
182:             msg.sender,
183:             auctions[loanId].collateralAmount - collateralReceived, // collateralToBorrower
184:             collateralReceived, // collateralToBidder
185:             creditAsked // creditFromBidder
186:         );
187: 
188:         // emit event
189:         emit AuctionEnd(
190:             block.timestamp,
191:             loanId,
192:             LendingTerm(_lendingTerm).collateralToken(),
193:             collateralReceived, // collateralSold
194:             creditAsked // debtRecovered
195:         );
196:     }
197: 
198:     /// @notice forgive a loan, by marking the debt as a total loss
199:     /// @dev this is meant to be used when an auction concludes without anyone bidding,
200:     /// even if 0 CREDIT is asked in return. This situation could arise
201:     /// if collateral assets are frozen within the lending term contract.
202:     function forgive(bytes32 loanId) external {
203:         // this view function will revert if the auction is not started,
204:         // or if the auction is already ended.
205:         (, uint256 creditAsked) = getBidDetail(loanId);
206:         require(creditAsked == 0, "AuctionHouse: ongoing auction");
207: 
208:         // close the auction in state
209:         auctions[loanId].endTime = block.timestamp;
210:         nAuctionsInProgress--;
211: 
212:         // notify LendingTerm of auction result
213:         address _lendingTerm = auctions[loanId].lendingTerm;
214:         LendingTerm(_lendingTerm).onBid(
215:             loanId,
216:             msg.sender,
217:             0, // collateralToBorrower
218:             0, // collateralToBidder
219:             0 // creditFromBidder
220:         );
221: 
222:         // emit event
223:         emit AuctionEnd(
224:             block.timestamp,
225:             loanId,
226:             LendingTerm(_lendingTerm).collateralToken(),
227:             0, // collateralSold
228:             0 // debtRecovered
229:         );
230:     }
231: }
232: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
5: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
6: import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
7: import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
8: 
9: import {CoreRef} from "@src/core/CoreRef.sol";
10: import {CoreRoles} from "@src/core/CoreRoles.sol";
11: import {LendingTerm} from "@src/loan/LendingTerm.sol";
12: import {ERC20Gauges} from "@src/tokens/ERC20Gauges.sol";
13: import {ProfitManager} from "@src/governance/ProfitManager.sol";
14: import {ERC20MultiVotes} from "@src/tokens/ERC20MultiVotes.sol";
15: 
16: /** 
17: @title  GUILD ERC20 Token
18: @author eswak
19: @notice This is the governance token of the Ethereum Credit Guild.
20:     On deploy, this token is non-transferrable.
21:     During the non-transferrable period, GUILD can still be minted & burnt, only
22:     `transfer` and `transferFrom` are reverting.
23: 
24:     The gauge system is used to define debt ceilings on a set of lending terms.
25:     Lending terms can be whitelisted by adding a gauge for their address, if GUILD
26:     holders vote for these lending terms in the gauge system, the lending terms will
27:     have a non-zero debt ceiling, and borrowing will be available under these terms.
28: 
29:     When a lending term creates bad debt, a loss is notified in a gauge on this
30:     contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting
31:     for this gauge becomes non-transferable and can be permissionlessly slashed. Until the
32:     loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or
33:     decrease the weight they assign to the gauge that suffered a loss.
34:     Even when a loss occur, users can still transfer tokens with which they vote for gauges
35:     that did not suffer a loss.
36: */
37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {
38:     using EnumerableSet for EnumerableSet.AddressSet;
39: 
40:     /// @notice reference to ProfitManager
41:     address public profitManager;
42: 
43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager;
52:     }
53: 
54:     /*///////////////////////////////////////////////////////////////
55:                         VOTING MANAGEMENT
56:     //////////////////////////////////////////////////////////////*/
57: 
58:     /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.
59:     function setMaxDelegates(
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
62:         _setMaxDelegates(newMax);
63:     }
64: 
65:     /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.
66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {
70:         _setContractExceedMaxDelegates(account, canExceedMax);
71:     }
72: 
73:     /*///////////////////////////////////////////////////////////////
74:                         GAUGE MANAGEMENT
75:     //////////////////////////////////////////////////////////////*/
76:     function addGauge(
77:         uint256 _type,
78:         address gauge
79:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {
80:         return _addGauge(_type, gauge);
81:     }
82: 
83:     function removeGauge(
84:         address gauge
85:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {
86:         _removeGauge(gauge);
87:     }
88: 
89:     function setMaxGauges(
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
92:         _setMaxGauges(max);
93:     }
94: 
95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {
99:         _setCanExceedMaxGauges(who, can);
100:     }
101: 
102:     /*///////////////////////////////////////////////////////////////
103:                         LOSS MANAGEMENT
104:     //////////////////////////////////////////////////////////////*/
105: 
106:     /// @notice emitted when a loss in a gauge is notified.
107:     event GaugeLoss(address indexed gauge, uint256 indexed when);
108:     /// @notice emitted when a loss in a gauge is applied (for each user).
109:     event GaugeLossApply(
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
114:     );
115: 
116:     /// @notice last block.timestamp when a loss occurred in a given gauge
117:     mapping(address => uint256) public lastGaugeLoss;
118: 
119:     /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge
120:     mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;
121: 
122:     /// @notice notify loss in a given gauge
123:     function notifyGaugeLoss(address gauge) external {
124:         require(msg.sender == profitManager, "UNAUTHORIZED");
125: 
126:         // save gauge loss
127:         lastGaugeLoss[gauge] = block.timestamp;
128:         emit GaugeLoss(gauge, block.timestamp);
129:     }
130: 
131:     /// @notice apply a loss that occurred in a given gauge
132:     /// anyone can apply the loss on behalf of anyone else
133:     function applyGaugeLoss(address gauge, address who) external {
134:         // check preconditions
135:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
136:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];
137:         require(
138:             _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,
139:             "GuildToken: no loss to apply"
140:         );
141: 
142:         // read user weight allocated to the lossy gauge
143:         uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];
144: 
145:         // remove gauge weight allocation
146:         lastGaugeLossApplied[gauge][who] = block.timestamp;
147:         _decrementGaugeWeight(who, gauge, _userGaugeWeight);
148:         if (!_deprecatedGauges.contains(gauge)) {
149:             totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;
150:             totalWeight -= _userGaugeWeight;
151:         }
152: 
153:         // apply loss
154:         _burn(who, uint256(_userGaugeWeight));
155:         emit GaugeLossApply(
156:             gauge,
157:             who,
158:             uint256(_userGaugeWeight),
159:             block.timestamp
160:         );
161:     }
162: 
163:     /*///////////////////////////////////////////////////////////////
164:                         TRANSFERABILITY
165:     //////////////////////////////////////////////////////////////*/
166: 
167:     /// @notice at deployment, tokens are not transferable (can only mint/burn).
168:     /// Governance can enable transfers with `enableTransfers()`.
169:     bool public transferable; // default = false
170: 
171:     /// @notice emitted when transfers are enabled.
172:     event TransfersEnabled(uint256 block, uint256 timestamp);
173: 
174:     /// @notice permanently enable token transfers.
175:     function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {
176:         transferable = true;
177:         emit TransfersEnabled(block.number, block.timestamp);
178:     }
179: 
180:     /// @dev prevent transfers if they are not globally enabled.
181:     /// mint and burn (transfers to and from address 0) are accepted.
182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 /* amount*/
186:     ) internal view override {
187:         require(
188:             transferable || from == address(0) || to == address(0),
189:             "GuildToken: transfers disabled"
190:         );
191:     }
192: 
193:     /// @notice emitted when reference to ProfitManager is updated
194:     event ProfitManagerUpdated(uint256 timestamp, address newValue);
195: 
196:     /// @notice set reference to ProfitManager
197:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {
198:         profitManager = _newProfitManager;
199:         emit ProfitManagerUpdated(block.timestamp, _newProfitManager);
200:     }
201: 
202:     /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease
203:     /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the
204:     /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders
205:     /// might have to call loans if the debt ceiling is used.
206:     /// Also update the user profit index and claim rewards.
207:     function _decrementGaugeWeight(
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override {
212:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
213:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];
214:         require(
215:             _lastGaugeLossApplied >= _lastGaugeLoss,
216:             "GuildToken: pending loss"
217:         );
218: 
219:         // update the user profit index and claim rewards
220:         ProfitManager(profitManager).claimGaugeRewards(user, gauge);
221: 
222:         // check if gauge is currently using its allocated debt ceiling.
223:         // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.
224:         uint256 issuance = LendingTerm(gauge).issuance();
225:         if (issuance != 0) {
226:             uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));
227:             require(
228:                 issuance <= debtCeilingAfterDecrement,
229:                 "GuildToken: debt ceiling used"
230:             );
231:         }
232: 
233:         super._decrementGaugeWeight(user, gauge, weight);
234:     }
235: 
236:     /// @dev prevent weight increment for gauge if user has an unapplied loss.
237:     /// If the user has 0 weight (i.e. no loss to realize), allow incrementing
238:     /// gauge weight & update lastGaugeLossApplied to current time.
239:     /// Also update the user profit index an claim rewards.
240:     /// @dev note that users voting for a gauge that is not a proper lending term could result in this
241:     /// share of the user's tokens to be frozen, due to being unable to decrement weight.
242:     function _incrementGaugeWeight(
243:         address user,
244:         address gauge,
245:         uint256 weight
246:     ) internal override {
247:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
248:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];
249:         if (getUserGaugeWeight[user][gauge] == 0) {
250:             lastGaugeLossApplied[gauge][user] = block.timestamp;
251:         } else {
252:             require(
253:                 _lastGaugeLossApplied >= _lastGaugeLoss,
254:                 "GuildToken: pending loss"
255:             );
256:         }
257: 
258:         ProfitManager(profitManager).claimGaugeRewards(user, gauge);
259: 
260:         super._incrementGaugeWeight(user, gauge, weight);
261:     }
262: 
263:     /*///////////////////////////////////////////////////////////////
264:                         MINT / BURN
265:     //////////////////////////////////////////////////////////////*/
266: 
267:     /// @notice mint new tokens to the target address
268:     function mint(
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {
272:         _mint(to, amount);
273:     }
274: 
275:     /*///////////////////////////////////////////////////////////////
276:                         Inheritance reconciliation
277:     //////////////////////////////////////////////////////////////*/
278: 
279:     function _burn(
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {
283:         _decrementWeightUntilFree(from, amount);
284:         _decrementVotesUntilFree(from, amount);
285:         ERC20._burn(from, amount);
286:     }
287: 
288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     {
297:         _decrementWeightUntilFree(msg.sender, amount);
298:         _decrementVotesUntilFree(msg.sender, amount);
299:         return ERC20.transfer(to, amount);
300:     }
301: 
302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     {
312:         _decrementWeightUntilFree(from, amount);
313:         _decrementVotesUntilFree(from, amount);
314:         return ERC20.transferFrom(from, to, amount);
315:     }
316: }
317: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {CoreRef} from "@src/core/CoreRef.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: import {SimplePSM} from "@src/loan/SimplePSM.sol";
7: import {GuildToken} from "@src/tokens/GuildToken.sol";
8: import {CreditToken} from "@src/tokens/CreditToken.sol";
9: 
10: /** 
11: @title ProfitManager
12: @author eswak
13: @notice This contract manages profits generated in the system and how it is distributed
14:     between the various stakeholders.
15: 
16:     This contract also manages a surplus buffer, which acts as first-loss capital in case of
17:     bad debt. When bad debt is created beyond the surplus buffer, this contract decrements
18:     the `creditMultiplier` value held in its storage, which has the effect of reducing the
19:     value of CREDIT everywhere in the system.
20: 
21:     When a loan generates profit (interests), the profit is traced back to users voting for
22:     this lending term (gauge), which subsequently allows pro-rata distribution of profits to
23:     GUILD holders that vote for the most productive gauges.
24: 
25:     Seniority stack of the debt, in case of losses :
26:     - per term surplus buffer (donated to global surplus buffer when loss is reported)
27:     - global surplus buffer
28:     - finally, credit holders (by updating down the creditMultiplier)
29: */
30: contract ProfitManager is CoreRef {
31:     /// @notice reference to GUILD token.
32:     address public guild;
33: 
34:     /// @notice reference to CREDIT token.
35:     address public credit;
36: 
37:     /// @notice reference to CREDIT token PSM.
38:     address public psm;
39: 
40:     /// @notice profit index of a given gauge
41:     mapping(address => uint256) public gaugeProfitIndex;
42: 
43:     /// @notice profit index of a given user in a given gauge
44:     mapping(address => mapping(address => uint256)) public userGaugeProfitIndex;
45: 
46:     /// @dev internal structure used to optimize storage read, public functions use
47:     /// uint256 numbers with 18 decimals.
48:     struct ProfitSharingConfig {
49:         uint32 surplusBufferSplit; // percentage, with 9 decimals (!) that go to surplus buffer
50:         uint32 guildSplit; // percentage, with 9 decimals (!) that go to GUILD holders
51:         uint32 otherSplit; // percentage, with 9 decimals (!) that go to other address if != address(0)
52:         address otherRecipient; // address receiving `otherSplit`
53:     }
54: 
55:     /// @notice configuration of profit sharing.
56:     /// `surplusBufferSplit`, `guildSplit`, and `otherSplit` are expressed as percentages with 9 decimals,
57:     /// so a value of 1e9 would direct 100% of profits. The sum should be <= 1e9.
58:     /// The rest (if the sum of `guildSplit` + `otherSplit` is < 1e9) is distributed to lenders of the
59:     /// system, CREDIT holders, through the rebasing mechanism (`CreditToken.distribute()`).
60:     /// If `otherRecipient` is set to address(0), `otherSplit` must equal 0.
61:     /// The share of profit to `otherRecipient` is sent through a regular ERC20.transfer().
62:     /// This structure is optimized for storage packing, all external interfaces reference
63:     /// percentages encoded as uint256 with 18 decimals.
64:     ProfitSharingConfig internal profitSharingConfig;
65: 
66:     /// @notice amount of first-loss capital in the system.
67:     /// This is a number of CREDIT token held on this contract that can be used to absorb losses in
68:     /// cases where a loss is reported through `notifyPnL`. The surplus buffer is depleted first, and
69:     /// if the loss is greater than the surplus buffer, the `creditMultiplier` is updated down.
70:     uint256 public surplusBuffer;
71: 
72:     /// @notice amount of first-loss capital for a given term.
73:     /// This is a number of CREDIT token held on this contract that can be used to absorb losses in
74:     /// cases where a loss is reported through `notifyPnL` in a given term.
75:     /// When a loss is reported in a given term, its termSuplusBuffer is donated to the general
76:     /// surplusBuffer before calculating the loss.
77:     mapping(address => uint256) public termSurplusBuffer;
78: 
79:     /// @notice multiplier for CREDIT value in the system.
80:     /// e.g. a value of 0.7e18 would mean that CREDIT has been discounted by 30% so far in the system,
81:     /// and that all lending terms will allow 1/0.7=1.42 times more CREDIT to be borrowed per collateral
82:     /// tokens, and all active debts are also affected by this multiplier during the update (e.g. if an
83:     /// address owed 1000 CREDIT in an active loan, they now owe 1428 CREDIT).
84:     /// The CREDIT multiplier can only go down (CREDIT can only lose value over time, when bad debt
85:     /// is created in the system). To make CREDIT a valuable asset to hold, profits generated by the system
86:     /// shall be redistributed to holders through a savings rate or another mechanism.
87:     uint256 public creditMultiplier = 1e18;
88: 
89:     /// @notice minimum size of CREDIT loans.
90:     /// this parameter is here to ensure that the gas costs of liquidation do not
91:     /// outsize minimum overcollateralization (which could result in bad debt
92:     /// on otherwise sound loans).
93:     /// This value is adjusted up when the creditMultiplier goes down.
94:     uint256 internal _minBorrow = 100e18;
95: 
96:     /// @notice tolerance on new borrows regarding gauge weights.
97:     /// For a total supply or 100 credit, and 2 gauges each at 50% weight,
98:     /// the ideal borrow amount for each gauge is 50 credit. To facilitate
99:     /// growth of the protocol, a tolerance is allowed compared to the ideal
100:     /// gauge weights.
101:     /// This tolerance is expressed as a percentage with 18 decimals.
102:     /// A tolerance of 1e18 (100% - or 0% deviation compared to ideal weights)
103:     /// can result in a deadlock situation where no new borrows are allowed.
104:     uint256 public gaugeWeightTolerance = 1.2e18; // 120%
105: 
106:     constructor(address _core) CoreRef(_core) {
107:         emit MinBorrowUpdate(block.timestamp, 100e18);
108:     }
109: 
110:     /// @notice emitted when a profit or loss in a gauge is notified.
111:     event GaugePnL(address indexed gauge, uint256 indexed when, int256 pnl);
112: 
113:     /// @notice emitted when surplus buffer is updated.
114:     event SurplusBufferUpdate(uint256 indexed when, uint256 newValue);
115: 
116:     /// @notice emitted when surplus buffer of a given term is updated.
117:     event TermSurplusBufferUpdate(
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
122: 
123:     /// @notice emitted when CREDIT multiplier is updated.
124:     event CreditMultiplierUpdate(uint256 indexed when, uint256 newValue);
125: 
126:     /// @notice emitted when GUILD profit sharing is updated.
127:     event ProfitSharingConfigUpdate(
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
132:         uint256 otherSplit,
133:         address otherRecipient
134:     );
135: 
136:     /// @notice emitted when a GUILD member claims their CREDIT rewards.
137:     event ClaimRewards(
138:         uint256 indexed when,
139:         address indexed user,
140:         address indexed gauge,
141:         uint256 amount
142:     );
143: 
144:     /// @notice emitted when minBorrow is updated
145:     event MinBorrowUpdate(uint256 indexed when, uint256 newValue);
146: 
147:     /// @notice emitted when gaugeWeightTolerance is updated
148:     event GaugeWeightToleranceUpdate(uint256 indexed when, uint256 newValue);
149: 
150:     /// @notice get the minimum borrow amount
151:     function minBorrow() external view returns (uint256) {
152:         return (_minBorrow * 1e18) / creditMultiplier;
153:     }
154: 
155:     /// @notice initialize references to GUILD & CREDIT tokens.
156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
161:         assert(
162:             credit == address(0) && guild == address(0) && psm == address(0)
163:         );
164:         credit = _credit;
165:         guild = _guild;
166:         psm = _psm;
167:     }
168: 
169:     /// @notice returns the sum of all borrowed CREDIT, not including unpaid interests
170:     /// and creditMultiplier changes that could make debt amounts higher than the initial
171:     /// borrowed CREDIT amounts.
172:     function totalBorrowedCredit() external view returns (uint256) {
173:         return
174:             CreditToken(credit).targetTotalSupply() -
175:             SimplePSM(psm).redeemableCredit();
176:     }
177: 
178:     /// @notice set the minimum borrow amount
179:     function setMinBorrow(
180:         uint256 newValue
181:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
182:         _minBorrow = newValue;
183:         emit MinBorrowUpdate(block.timestamp, newValue);
184:     }
185: 
186:     /// @notice set the gauge weight tolerance
187:     function setGaugeWeightTolerance(
188:         uint256 newValue
189:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
190:         gaugeWeightTolerance = newValue;
191:         emit GaugeWeightToleranceUpdate(block.timestamp, newValue);
192:     }
193: 
194:     /// @notice set the profit sharing config.
195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
202:         if (otherRecipient == address(0)) {
203:             require(otherSplit == 0, "GuildToken: invalid config");
204:         } else {
205:             require(otherSplit != 0, "GuildToken: invalid config");
206:         }
207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         );
211: 
212:         profitSharingConfig = ProfitSharingConfig({
213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9),
214:             guildSplit: uint32(guildSplit / 1e9),
215:             otherSplit: uint32(otherSplit / 1e9),
216:             otherRecipient: otherRecipient
217:         });
218: 
219:         emit ProfitSharingConfigUpdate(
220:             block.timestamp,
221:             surplusBufferSplit,
222:             creditSplit,
223:             guildSplit,
224:             otherSplit,
225:             otherRecipient
226:         );
227:     }
228: 
229:     /// @notice get the profit sharing config.
230:     function getProfitSharingConfig()
231:         external
232:         view
233:         returns (
234:             uint256 surplusBufferSplit,
235:             uint256 creditSplit,
236:             uint256 guildSplit,
237:             uint256 otherSplit,
238:             address otherRecipient
239:         )
240:     {
241:         surplusBufferSplit =
242:             uint256(profitSharingConfig.surplusBufferSplit) *
243:             1e9;
244:         guildSplit = uint256(profitSharingConfig.guildSplit) * 1e9;
245:         otherSplit = uint256(profitSharingConfig.otherSplit) * 1e9;
246:         creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit;
247:         otherRecipient = profitSharingConfig.otherRecipient;
248:     }
249: 
250:     /// @notice donate to surplus buffer
251:     function donateToSurplusBuffer(uint256 amount) external {
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
257: 
258:     /// @notice donate to surplus buffer of a given term
259:     function donateToTermSurplusBuffer(address term, uint256 amount) external {
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
265: 
266:     /// @notice withdraw from surplus buffer
267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; // this would revert due to underflow if withdrawing > surplusBuffer
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount);
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
276: 
277:     /// @notice withdraw from surplus buffer of a given term
278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; // this would revert due to underflow if withdrawing > termSurplusBuffer
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount);
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
288: 
289:     /// @notice notify profit and loss in a given gauge
290:     /// if `amount` is > 0, the same number of CREDIT tokens are expected to be transferred to this contract
291:     /// before `notifyPnL` is called.
292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         // handling loss
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             // save gauge loss
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             // deplete the term surplus buffer, if any, and
308:             // donate its content to the general surplus buffer
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 // deplete the surplus buffer
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 // empty the surplus buffer
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 // update the CREDIT multiplier
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         // handling profit
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             // distribute to surplus buffer
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             // distribute to other
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             // distribute to lenders
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             // distribute to the guild
383:             if (amountForGuild != 0) {
384:                 // update the gauge profit index
385:                 // if the gauge has 0 weight, does not update the profit index, this is unnecessary
386:                 // because the profit index is used to reattribute profit to users voting for the gauge,
387:                 // and if the weigth is 0, there are no users voting for the gauge.
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
406: 
407:     /// @notice claim a user's rewards for a given gauge.
408:     /// @dev This should be called every time the user's weight changes in the gauge.
409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned);
435:         }
436:     }
437: 
438:     /// @notice claim a user's rewards across all their active gauges.
439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) {
442:         address[] memory gauges = GuildToken(guild).userGauges(user);
443:         for (uint256 i = 0; i < gauges.length; ) {
444:             creditEarned += claimGaugeRewards(user, gauges[i]);
445:             unchecked {
446:                 ++i;
447:             }
448:         }
449:     }
450: 
451:     /// @notice read & return pending undistributed rewards for a given user
452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     {
463:         address _guild = guild;
464:         gauges = GuildToken(_guild).userGauges(user);
465:         creditEarned = new uint256[](gauges.length);
466: 
467:         for (uint256 i = 0; i < gauges.length; ) {
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
491:     }
492: }
493: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol";
5: 
6: import {CoreRef} from "@src/core/CoreRef.sol";
7: import {CoreRoles} from "@src/core/CoreRoles.sol";
8: import {GuildToken} from "@src/tokens/GuildToken.sol";
9: import {CreditToken} from "@src/tokens/CreditToken.sol";
10: import {ProfitManager} from "@src/governance/ProfitManager.sol";
11: import {RateLimitedMinter} from "@src/rate-limits/RateLimitedMinter.sol";
12: 
13: /// @notice SurplusGuildMinter allows GUILD to be minted from CREDIT collateral.
14: /// In this contract, CREDIT tokens can be provided as first-loss capital to
15: /// the surplus buffer of chosen terms, and in exchange, users can participate in the
16: /// gauge voting system at a reduced capital cost & without exposure to GUILD
17: /// token's price fluctuations. GUILD minted through this contract can only
18: /// participate in the gauge system to increase debt ceiling and earn fees
19: /// from selected lending terms.
20: /// @dev note that any update to the `rewardRatio` (through `setRewardRatio`) will
21: /// change the rewards of all pending unclaimed rewards. Before a proposal to update
22: /// the reward ratio execute, this contract should be pinged with `getRewards` for
23: /// all users that have pending rewards.
24: contract SurplusGuildMinter is CoreRef {
25:     /// @notice minimum number of CREDIT to stake
26:     uint256 public constant MIN_STAKE = 1e18;
27: 
28:     /// @notice reference number of seconds in 1 year
29:     uint256 public constant YEAR = 31557600;
30: 
31:     /// @notice emitted when a user stakes CREDIT on a target lending term
32:     event Stake(
33:         uint256 indexed timestamp,
34:         address indexed term,
35:         uint256 amount
36:     );
37:     /// @notice emitted when a user unstakes CREDIT on a target lending term
38:     event Unstake(
39:         uint256 indexed timestamp,
40:         address indexed term,
41:         uint256 amount
42:     );
43:     /// @notice emitted when a user is rewarded GUILD from non-zero interest
44:     /// rate and closing their position without loss.
45:     event GuildReward(
46:         uint256 indexed timestamp,
47:         address indexed user,
48:         uint256 amount
49:     );
50:     /// @notice emitted when the mintRatio is updated
51:     event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio);
52:     /// @notice emitted when the rewardRatio is updated
53:     event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio);
54: 
55:     /// @notice reference to the ProfitManager
56:     address public immutable profitManager;
57: 
58:     /// @notice reference to the CREDIT token
59:     address public immutable credit;
60: 
61:     /// @notice reference to the GUILD token
62:     address public immutable guild;
63: 
64:     /// @notice reference to the RateLimitedGuildMinter
65:     address public immutable rlgm;
66: 
67:     /// @notice ratio of GUILD tokens minted per CREDIT tokens staked.
68:     /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18
69:     /// GUILD tokens to a user that stakes 1e18 CREDIT tokens.
70:     uint256 public mintRatio;
71: 
72:     /// @notice ratio of GUILD tokens earned per CREDIT tokens earned.
73:     /// expressed with 18 decimals, e.g. a ratio of 2e18 would provide 2e18
74:     /// GUILD tokens to a user that stakes earned 1e18 CREDIT tokens.
75:     uint256 public rewardRatio;
76: 
77:     struct UserStake {
78:         uint48 stakeTime;
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
84: 
85:     /// @notice list of user stakes (stakes[user][term]=UserStake)
86:     mapping(address => mapping(address => UserStake)) internal _stakes;
87: 
88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager;
98:         credit = _credit;
99:         guild = _guild;
100:         rlgm = _rlgm;
101:         mintRatio = _mintRatio;
102:         rewardRatio = _rewardRatio;
103:     }
104: 
105:     /// @notice get a given user stake
106:     function getUserStake(
107:         address user,
108:         address term
109:     ) external view returns (UserStake memory) {
110:         return _stakes[user][term];
111:     }
112: 
113:     /// @notice stake CREDIT tokens to start voting in a gauge.
114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         // apply pending rewards
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         // pull CREDIT from user & transfer it to surplus buffer
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         // self-mint GUILD tokens
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         // update state
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         // emit event
154:         emit Stake(block.timestamp, term, amount);
155:     }
156: 
157:     /// @notice unstake CREDIT tokens and stop voting in a gauge.
158:     function unstake(address term, uint256 amount) external {
159:         // apply pending rewards
160:         (, UserStake memory userStake, bool slashed) = getRewards(
161:             msg.sender,
162:             term
163:         );
164: 
165:         // if the user has been slashed, there is nothing to do
166:         if (slashed) return;
167: 
168:         // check that the user is at least staking `amount` CREDIT
169:         require(
170:             amount != 0 && userStake.credit >= amount,
171:             "SurplusGuildMinter: invalid amount"
172:         );
173: 
174:         // update stake
175:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /
176:             userStake.credit; /// upcast guild to prevent overflow
177:         uint256 guildAmount = (userMintRatio * amount) / 1e18;
178: 
179:         if (amount == userStake.credit) guildAmount = userStake.guild;
180: 
181:         userStake.credit -= SafeCastLib.safeCastTo128(amount);
182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);
183: 
184:         if (userStake.credit == 0) {
185:             userStake.stakeTime = 0;
186:             userStake.lastGaugeLoss = 0;
187:             userStake.profitIndex = 0;
188:         } else {
189:             // if not unstaking all, make sure the stake remains
190:             // greater than the minimum stake
191:             require(
192:                 userStake.credit >= MIN_STAKE,
193:                 "SurplusGuildMinter: remaining stake below min"
194:             );
195:         }
196:         _stakes[msg.sender][term] = userStake;
197: 
198:         // withdraw & transfer CREDIT
199:         ProfitManager(profitManager).withdrawFromTermSurplusBuffer(
200:             term,
201:             msg.sender,
202:             amount
203:         );
204: 
205:         // burn GUILD
206:         GuildToken(guild).decrementGauge(term, guildAmount);
207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
208:         GuildToken(guild).burn(guildAmount);
209: 
210:         // emit event
211:         emit Unstake(block.timestamp, term, amount);
212:     }
213: 
214:     /// @notice get rewards from a staking position without unstaking.
215:     /// This can be used to slash users that have an outstanding unapplied loss.
216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, // GuildToken.lastGaugeLoss(term)
223:             UserStake memory userStake, // stake state after execution of getRewards()
224:             bool slashed // true if the user has been slashed
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         // if the user is not staking, do nothing
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         // compute CREDIT rewards
239:         ProfitManager(profitManager).claimRewards(address(this)); // this will update profit indexes
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             // forward rewards to user
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward);
264:             }
265: 
266:             // save the updated profitIndex
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         // if a loss occurred while the user was staking, the GuildToken.applyGaugeLoss(address(this))
272:         // can be called by anyone to slash address(this) and decrement gauge weight etc.
273:         // The contribution to the surplus buffer is also forfeited.
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         // store the updated stake, if needed
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
291: 
292:     /// @notice update the mint ratio for a given user.
293:     function updateMintRatio(address user, address term) external {
294:         // apply pending rewards
295:         (, UserStake memory userStake, bool slashed) = getRewards(user, term);
296: 
297:         // if the user has been slashed or isnt staking, there is nothing to do
298:         if (userStake.stakeTime == 0 || slashed) return;
299: 
300:         // update amount of GUILD tokens staked
301:         uint256 guildBefore = uint256(userStake.guild);
302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18;
303:         if (guildAfter > guildBefore) {
304:             uint256 guildAmount = guildAfter - guildBefore;
305:             RateLimitedMinter(rlgm).mint(address(this), guildAmount);
306:             GuildToken(guild).incrementGauge(term, guildAmount);
307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
308:         } else if (guildAfter < guildBefore) {
309:             uint256 guildAmount = guildBefore - guildAfter;
310:             GuildToken(guild).decrementGauge(term, guildAmount);
311:             RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
312:             GuildToken(guild).burn(guildAmount);
313:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
314:         }
315:     }
316: 
317:     /// @notice governor-only function to set the ratio of GUILD tokens minted
318:     /// per CREDIT tokens contributed to the surplus buffer.
319:     function setMintRatio(
320:         uint256 _mintRatio
321:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
322:         mintRatio = _mintRatio;
323:         emit MintRatioUpdate(block.timestamp, _mintRatio);
324:     }
325: 
326:     /// @notice governor-only function to set the ratio of GUILD tokens rewarded
327:     /// per CREDIT tokens earned from GUILD staking.
328:     function setRewardRatio(
329:         uint256 _rewardRatio
330:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
331:         rewardRatio = _rewardRatio;
332:         emit RewardRatioUpdate(block.timestamp, _rewardRatio);
333:     }
334: }
335: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";
5: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
6: import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
7: import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
8: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol";
9: 
10: import {Core} from "@src/core/Core.sol";
11: import {CoreRoles} from "@src/core/CoreRoles.sol";
12: import {GuildToken} from "@src/tokens/GuildToken.sol";
13: import {LendingTerm} from "@src/loan/LendingTerm.sol";
14: import {GuildGovernor} from "@src/governance/GuildGovernor.sol";
15: 
16: /// @notice Utils to onboard a LendingTerm. Also acts as a LendingTerm factory.
17: /// This contract acts as Governor, but users cannot queue arbitrary proposals,
18: /// they can only queue LendingTerm onboarding proposals.
19: /// When a vote is successful, the LendingTerm onboarding is queued in the Timelock,
20: /// where CREDIT holders can veto the onboarding.
21: /// Only terms that have been deployed through this factory can be onboarded.
22: /// A term can be onboarded for the first time, or re-onboarded after it has been offboarded.
23: contract LendingTermOnboarding is GuildGovernor {
24:     /// @notice minimum delay between proposals of onboarding of a given term
25:     uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days;
26:     /// @notice time of last proposal of a given term
27:     mapping(address => uint256) public lastProposal;
28: 
29:     /// @notice mapping of allowed LendingTerm implementations
30:     mapping(address => bool) public implementations;
31:     /// @notice immutable reference to the guild token
32:     address public immutable guildToken;
33:     /// @notice immutable reference to the gauge type to use for the terms onboarded
34:     uint256 public immutable gaugeType;
35: 
36:     /// @notice timestamp of creation of a term
37:     /// (used to check that a term has been created by this factory)
38:     mapping(address => uint256) public created;
39: 
40:     /// @notice reference to profitManager to set in created lending terms
41:     address public immutable profitManager;
42:     /// @notice reference to auctionHouse to set in created lending terms
43:     address public immutable auctionHouse;
44:     /// @notice reference to creditMinter to set in created lending terms
45:     address public immutable creditMinter;
46:     /// @notice reference to creditToken to set in created lending terms
47:     address public immutable creditToken;
48: 
49:     /// @notice emitted when a lending term implementation's "allowed" status changes
50:     event ImplementationAllowChanged(
51:         uint256 indexed when,
52:         address indexed implementation,
53:         bool allowed
54:     );
55:     /// @notice emitted when a term is created
56:     event TermCreated(
57:         uint256 indexed when,
58:         address indexed implementation,
59:         address indexed term,
60:         LendingTerm.LendingTermParams params
61:     );
62: 
63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     {
83:         guildToken = _lendingTermReferences.guildToken;
84:         gaugeType = _gaugeType;
85:         profitManager = _lendingTermReferences.profitManager;
86:         auctionHouse = _lendingTermReferences.auctionHouse;
87:         creditMinter = _lendingTermReferences.creditMinter;
88:         creditToken = _lendingTermReferences.creditToken;
89:     }
90: 
91:     /// @notice Allow or disallow a given implemenation
92:     function allowImplementation(
93:         address implementation,
94:         bool allowed
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
96:         implementations[implementation] = allowed;
97:         emit ImplementationAllowChanged(
98:             block.timestamp,
99:             implementation,
100:             allowed
101:         );
102:     }
103: 
104:     /// @notice Create a new LendingTerm and initialize it.
105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         // must be an ERC20 (maybe, at least it prevents dumb input mistakes)
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, // must be able to mint non-zero debt
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, // interest rate [0, 100[% APR
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             // 31557601 comes from the constant LendingTerm.YEAR() + 1
134:             params.maxDelayBetweenPartialRepay < 31557601, // periodic payment every [0, 1 year]
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, // periodic payment sizes [0, 100[%
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, // open fee expected [0, 10]%
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, // non-zero hardcap
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params);
167:         return term;
168:     }
169: 
170:     /// @dev override to prevent arbitrary calls to be proposed
171:     function propose(
172:         address[] memory /* targets*/,
173:         uint256[] memory /* values*/,
174:         bytes[] memory /* calldatas*/,
175:         string memory /* description*/
176:     ) public pure override(IGovernor, Governor) returns (uint256) {
177:         revert("LendingTermOnboarding: cannot propose arbitrary actions");
178:     }
179: 
180:     /// @notice Propose the onboarding of a term
181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         // Check that the term has been created by this factory
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term");
186: 
187:         // Check that the term was not subject to an onboard vote recently
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp,
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp;
193: 
194:         // Check that the term is not already active
195:         // note that terms that have been offboarded in the past can be re-onboarded
196:         // and won't fail this check. This is intentional, because some terms might be offboarded
197:         // due to specific market conditions, and it might be desirable to re-onboard them
198:         // at a later date.
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term");
201: 
202:         // Generate calldata for the proposal
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         // propose
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
213: 
214:     /// @notice Generate the calldata for the onboarding of a term
215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     {
227:         targets = new address[](3);
228:         values = new uint256[](3);
229:         calldatas = new bytes[](3);
230:         description = string.concat(
231:             "[",
232:             Strings.toString(block.number),
233:             "]",
234:             " Enable term ",
235:             Strings.toHexString(term)
236:         );
237: 
238:         // 1st call: guild.addGauge(term)
239:         targets[0] = guildToken;
240:         calldatas[0] = abi.encodeWithSelector(
241:             GuildToken.addGauge.selector,
242:             gaugeType,
243:             term
244:         );
245: 
246:         // 2nd call: core.grantRole(term, RATE_LIMITED_CREDIT_MINTER)
247:         address _core = address(core());
248:         targets[1] = _core;
249:         calldatas[1] = abi.encodeWithSelector(
250:             AccessControl.grantRole.selector,
251:             CoreRoles.RATE_LIMITED_CREDIT_MINTER,
252:             term
253:         );
254: 
255:         // 3rd call: core.grantRole(term, GAUGE_PNL_NOTIFIER)
256:         targets[2] = _core;
257:         calldatas[2] = abi.encodeWithSelector(
258:             AccessControl.grantRole.selector,
259:             CoreRoles.GAUGE_PNL_NOTIFIER,
260:             term
261:         );
262:     }
263: }
264: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {CoreRef} from "@src/core/CoreRef.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";
7: 
8: /// @title An override of the regular OZ governance/TimelockController to allow uniform
9: /// access control in the ECG system based on roles defined in Core.
10: /// @dev The roles and roles management from OZ access/AccessControl.sol are ignored, we
11: /// chose not to fork TimelockController and just bypass its access control system, to
12: /// introduce as few code changes as possible on top of OpenZeppelin's governance code.
13: /// @author eswak
14: contract GuildTimelockController is TimelockController, CoreRef {
15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     {}
27: 
28:     /// @dev override of OZ access/AccessControl.sol inherited by governance/TimelockController.sol
29:     /// This will check roles with Core, and not with the storage mapping from AccessControl.sol
30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool) {
34:         return core().hasRole(role, account);
35:     }
36: 
37:     /// @dev override of OZ access/AccessControl.sol, noop because role management is handled in Core.
38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {}
39: 
40:     /// @dev override of OZ access/AccessControl.sol, noop because role management is handled in Core.
41:     function _grantRole(bytes32 role, address account) internal override {}
42: 
43:     /// @dev override of OZ access/AccessControl.sol, noop because role management is handled in Core.
44:     function _revokeRole(bytes32 role, address account) internal override {}
45: }
46: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
5: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
6: import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
7: 
8: import {CoreRef} from "@src/core/CoreRef.sol";
9: import {CoreRoles} from "@src/core/CoreRoles.sol";
10: import {ERC20MultiVotes} from "@src/tokens/ERC20MultiVotes.sol";
11: import {ERC20RebaseDistributor} from "@src/tokens/ERC20RebaseDistributor.sol";
12: 
13: /** 
14: @title  CREDIT ERC20 Token
15: @author eswak
16: @notice This is the debt token of the Ethereum Credit Guild.
17: */
18: contract CreditToken is
19:     CoreRef,
20:     ERC20Burnable,
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: {
24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     {}
33: 
34:     /// @notice Mint new tokens to the target address
35:     function mint(
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) {
39:         _mint(to, amount);
40:     }
41: 
42:     /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.
43:     function setMaxDelegates(
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
46:         _setMaxDelegates(newMax);
47:     }
48: 
49:     /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.
50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) {
54:         _setContractExceedMaxDelegates(account, canExceedMax);
55:     }
56: 
57:     /// @notice Force an address to enter rebase.
58:     function forceEnterRebase(
59:         address account
60:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) {
61:         require(
62:             rebasingState[account].isRebasing == 0,
63:             "CreditToken: already rebasing"
64:         );
65:         _enterRebase(account);
66:     }
67: 
68:     /// @notice Force an address to exit rebase.
69:     function forceExitRebase(
70:         address account
71:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) {
72:         require(
73:             rebasingState[account].isRebasing == 1,
74:             "CreditToken: not rebasing"
75:         );
76:         _exitRebase(account);
77:     }
78: 
79:     /*///////////////////////////////////////////////////////////////
80:                         Inheritance reconciliation
81:     //////////////////////////////////////////////////////////////*/
82: 
83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) {
87:         ERC20RebaseDistributor._mint(account, amount);
88:     }
89: 
90:     function _burn(
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) {
94:         _decrementVotesUntilFree(account, amount); // from ERC20MultiVotes
95:         ERC20RebaseDistributor._burn(account, amount);
96:     }
97: 
98:     function balanceOf(
99:         address account
100:     ) public view override(ERC20, ERC20RebaseDistributor) returns (uint256) {
101:         return ERC20RebaseDistributor.balanceOf(account);
102:     }
103: 
104:     function totalSupply()
105:         public
106:         view
107:         override(ERC20, ERC20RebaseDistributor)
108:         returns (uint256)
109:     {
110:         return ERC20RebaseDistributor.totalSupply();
111:     }
112: 
113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     {
121:         _decrementVotesUntilFree(msg.sender, amount); // from ERC20MultiVotes
122:         return ERC20RebaseDistributor.transfer(to, amount);
123:     }
124: 
125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     {
134:         _decrementVotesUntilFree(from, amount); // from ERC20MultiVotes
135:         return ERC20RebaseDistributor.transferFrom(from, to, amount);
136:     }
137: }
138: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol";
5: import {GovernorSettings} from "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
6: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
7: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
8: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
9: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol";
10: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";
11: import {CoreRef} from "@src/core/CoreRef.sol";
12: import {CoreRoles} from "@src/core/CoreRoles.sol";
13: 
14: /// @title Governor for on-chain governance of Ethereum Credit Guild, based on the OZ implementation.
15: /// @author eswak
16: contract GuildGovernor is
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: {
24:     /// @notice Private storage variable for quorum (the minimum number of votes needed for a vote to pass).
25:     uint256 private _quorum;
26: 
27:     /// @notice Emitted when quorum is updated.
28:     event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
29: 
30:     constructor(
31:         address _core,
32:         address _timelock,
33:         address _token,
34:         uint256 initialVotingDelay,
35:         uint256 initialVotingPeriod,
36:         uint256 initialProposalThreshold,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Governor")
41:         GovernorVotes(IVotes(_token))
42:         GovernorTimelockControl(TimelockController(payable(_timelock)))
43:         GovernorSettings(
44:             initialVotingDelay,
45:             initialVotingPeriod,
46:             initialProposalThreshold
47:         )
48:     {
49:         _setQuorum(initialQuorum);
50:     }
51: 
52:     /// ------------------------------------------------------------------------
53:     /// Quorum managment.
54:     /// ------------------------------------------------------------------------
55: 
56:     /// @notice The minimum number of votes needed for a vote to pass.
57:     function quorum(
58:         uint256 /* blockNumber*/
59:     ) public view override returns (uint256) {
60:         return _quorum;
61:     }
62: 
63:     /**
64:      * @dev Internal setter for the proposal quorum.
65:      *
66:      * Emits a {QuorumUpdated} event.
67:      */
68:     function _setQuorum(uint256 newQuorum) internal {
69:         emit QuorumUpdated(_quorum, newQuorum);
70:         _quorum = newQuorum;
71:     }
72: 
73:     /// ------------------------------------------------------------------------
74:     /// Governor-only actions.
75:     /// ------------------------------------------------------------------------
76: 
77:     /// @notice Override of a GovernorSettings function, to restrict to Core GOVERNOR role.
78:     function setVotingDelay(
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
81:         _setVotingDelay(newVotingDelay);
82:     }
83: 
84:     /// @notice Override of a GovernorSettings function, to restrict to Core GOVERNOR role.
85:     function setVotingPeriod(
86:         uint256 newVotingPeriod
87:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
88:         _setVotingPeriod(newVotingPeriod);
89:     }
90: 
91:     /// @notice Override of a GovernorSettings.sol function, to restrict to Core GOVERNOR role.
92:     function setProposalThreshold(
93:         uint256 newProposalThreshold
94:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) {
95:         _setProposalThreshold(newProposalThreshold);
96:     }
97: 
98:     /// @notice Adjust quorum, restricted to Core GOVERNOR role.
99:     function setQuorum(
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) {
102:         _setQuorum(newQuorum);
103:     }
104: 
105:     /// ------------------------------------------------------------------------
106:     /// Guardian-only actions.
107:     /// ------------------------------------------------------------------------
108: 
109:     /// @notice Allow guardian to cancel a proposal in progress.
110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) {
116:         return _cancel(targets, values, calldatas, descriptionHash);
117:     }
118: 
119:     /// ------------------------------------------------------------------------
120:     /// Overrides required by Solidity.
121:     /// ------------------------------------------------------------------------
122: 
123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
129:         return super._cancel(targets, values, calldatas, descriptionHash);
130:     }
131: 
132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) {
139:         super._execute(proposalId, targets, values, calldatas, descriptionHash);
140:     }
141: 
142:     function _executor()
143:         internal
144:         view
145:         override(Governor, GovernorTimelockControl)
146:         returns (address)
147:     {
148:         return super._executor();
149:     }
150: 
151:     function proposalThreshold()
152:         public
153:         view
154:         override(Governor, GovernorSettings)
155:         returns (uint256)
156:     {
157:         return super.proposalThreshold();
158:     }
159: 
160:     function state(
161:         uint256 proposalId
162:     )
163:         public
164:         view
165:         override(Governor, GovernorTimelockControl)
166:         returns (ProposalState)
167:     {
168:         return super.state(proposalId);
169:     }
170: 
171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) {
174:         return super.supportsInterface(interfaceId);
175:     }
176: }
177: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
5: import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
6: 
7: /** 
8: @title  An ERC20 with an embedded "Gauge" style vote with liquid weights
9: @author joeysantoro, eswak
10: @notice This contract is meant to be used to support gauge style votes with weights associated with resource allocation.
11:         Holders can allocate weight in any proportion to supported gauges.
12:         A "gauge" is represented by an address which would receive the resources periodically or continuously.
13:         For example, gauges can be used to direct token emissions, similar to Curve or Tokemak.
14:         Alternatively, gauges can be used to direct another quantity such as relative access to a line of credit.
15:         This contract is abstract, and a parent shall implement public setter with adequate access control to manage
16:         the gauge set and caps.
17:         All gauges are in the set `_gauges` (live + deprecated).  
18:         Users can only add weight to live gauges but can remove weight from live or deprecated gauges.
19:         Gauges can be deprecated and reinstated, and will maintain any non-removed weight from before.
20: @dev    SECURITY NOTES: `maxGauges` is a critical variable to protect against gas DOS attacks upon token transfer. 
21:         This must be low enough to allow complicated transactions to fit in a block.
22:         Weight state is preserved on the gauge and user level even when a gauge is removed, in case it is re-added. 
23:         This maintains state efficiently, and global accounting is managed only on the `_totalWeight`
24: @dev This contract was originally published as part of TribeDAO's flywheel-v2 repo, please see:
25:     https://github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20Gauges.sol
26:     The original version was included in 2 audits :
27:     - https://code4rena.com/reports/2022-04-xtribe/
28:     - https://consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/
29:     ECG made the following changes to the original flywheel-v2 version :
30:     - Does not inherit Solmate's Auth (all requiresAuth functions are now internal, see below)
31:         -> This contract is abstract, and permissioned public functions can be added in parent.
32:         -> permissioned public functions to add in parent:
33:             - function addGauge(address) external returns (uint112)
34:             - function removeGauge(address) external
35:             - function setMaxGauges(uint256) external
36:             - function setCanExceedMaxGauges(address, bool) external
37:     - Remove public addGauge(address) requiresAuth method 
38:     - Remove public removeGauge(address) requiresAuth method
39:     - Remove public replaceGauge(address, address) requiresAuth method
40:     - Remove public setMaxGauges(uint256) requiresAuth method
41:         ... Add internal _setMaxGauges(uint256) method
42:     - Remove public setContractExceedMaxGauges(address, bool) requiresAuth method
43:         ... Add internal _setCanExceedMaxGauges(address, bool) method
44:         ... Remove check of "target address has nonzero code size"
45:         ... Rename to remove "contract" from name because we don't check if target is a contract
46:     - Rename `calculateGaugeAllocation` to `calculateGaugeStoredAllocation` to make clear that it reads from stored weights.
47:     - Add `calculateGaugeAllocation` helper function that reads from current weight.
48:     - Add `isDeprecatedGauge(address)->bool` view function that returns true if gauge is deprecated.
49:     - Consistency: make incrementGauges return a uint112 instead of uint256
50:     - Import OpenZeppelin ERC20 & EnumerableSet instead of Solmate's
51:     - Update error management style (use require + messages instead of Solidity errors)
52:     - Implement C4 audit fixes for [M-03], [M-04], [M-07], [G-02], and [G-04].
53:     - Remove cycle-based logic
54:     - Add gauge types
55:     - Prevent removal of gauges if they were not previously added
56:     - Add liveGauges() and numLiveGauges() getters
57: */
58: abstract contract ERC20Gauges is ERC20 {
59:     using EnumerableSet for EnumerableSet.AddressSet;
60: 
61:     /*///////////////////////////////////////////////////////////////
62:                         GAUGE STATE
63:     //////////////////////////////////////////////////////////////*/
64: 
65:     /// @notice a mapping from users to gauges to a user's allocated weight to that gauge
66:     mapping(address => mapping(address => uint256)) public getUserGaugeWeight;
67: 
68:     /// @notice a mapping from a user to their total allocated weight across all gauges
69:     /// @dev NOTE this may contain weights for deprecated gauges
70:     mapping(address => uint256) public getUserWeight;
71: 
72:     /// @notice a mapping from a gauge to the total weight allocated to it
73:     /// @dev NOTE this may contain weights for deprecated gauges
74:     mapping(address => uint256) public getGaugeWeight;
75: 
76:     /// @notice the total global allocated weight ONLY of live gauges
77:     uint256 public totalWeight;
78: 
79:     /// @notice the total allocated weight to gauges of a given type, ONLY of live gauges.
80:     /// keys : totalTypeWeight[type] = total.
81:     mapping(uint256 => uint256) public totalTypeWeight;
82: 
83:     /// @notice the type of gauges.
84:     mapping(address => uint256) public gaugeType;
85: 
86:     mapping(address => EnumerableSet.AddressSet) internal _userGauges;
87: 
88:     EnumerableSet.AddressSet internal _gauges;
89: 
90:     // Store deprecated gauges in case a user needs to free dead weight
91:     EnumerableSet.AddressSet internal _deprecatedGauges;
92: 
93:     /*///////////////////////////////////////////////////////////////
94:                             VIEW HELPERS
95:     //////////////////////////////////////////////////////////////*/
96: 
97:     /// @notice returns the set of live + deprecated gauges
98:     function gauges() external view returns (address[] memory) {
99:         return _gauges.values();
100:     }
101: 
102:     /// @notice returns true if `gauge` is not in deprecated gauges
103:     function isGauge(address gauge) public view returns (bool) {
104:         return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);
105:     }
106: 
107:     /// @notice returns true if `gauge` is in deprecated gauges
108:     function isDeprecatedGauge(address gauge) public view returns (bool) {
109:         return _deprecatedGauges.contains(gauge);
110:     }
111: 
112:     /// @notice returns the number of live + deprecated gauges
113:     function numGauges() external view returns (uint256) {
114:         return _gauges.length();
115:     }
116: 
117:     /// @notice returns the set of previously live but now deprecated gauges
118:     function deprecatedGauges() external view returns (address[] memory) {
119:         return _deprecatedGauges.values();
120:     }
121: 
122:     /// @notice returns the number of deprecated gauges
123:     function numDeprecatedGauges() external view returns (uint256) {
124:         return _deprecatedGauges.length();
125:     }
126: 
127:     /// @notice returns the set of currently live gauges
128:     function liveGauges() external view returns (address[] memory _liveGauges) {
129:         _liveGauges = new address[](
130:             _gauges.length() - _deprecatedGauges.length()
131:         );
132:         address[] memory allGauges = _gauges.values();
133:         uint256 j;
134:         for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) {
135:             if (!_deprecatedGauges.contains(allGauges[i])) {
136:                 _liveGauges[j] = allGauges[i];
137:                 unchecked {
138:                     ++j;
139:                 }
140:             }
141:             unchecked {
142:                 ++i;
143:             }
144:         }
145:         return _liveGauges;
146:     }
147: 
148:     /// @notice returns the number of currently live gauges
149:     function numLiveGauges() external view returns (uint256) {
150:         return _gauges.length() - _deprecatedGauges.length();
151:     }
152: 
153:     /// @notice returns the set of gauges the user has allocated to, may be live or deprecated.
154:     function userGauges(address user) external view returns (address[] memory) {
155:         return _userGauges[user].values();
156:     }
157: 
158:     /// @notice returns true if `gauge` is in user gauges
159:     function isUserGauge(
160:         address user,
161:         address gauge
162:     ) external view returns (bool) {
163:         return _userGauges[user].contains(gauge);
164:     }
165: 
166:     /// @notice returns the number of user gauges
167:     function numUserGauges(address user) external view returns (uint256) {
168:         return _userGauges[user].length();
169:     }
170: 
171:     /// @notice helper function exposing the amount of weight available to allocate for a user
172:     function userUnusedWeight(address user) external view returns (uint256) {
173:         return balanceOf(user) - getUserWeight[user];
174:     }
175: 
176:     /** 
177:     @notice helper function for calculating the proportion of a `quantity` allocated to a gauge
178:     @param gauge the gauge to calculate allocation of
179:     @param quantity a representation of a resource to be shared among all gauges
180:     @return the proportion of `quantity` allocated to `gauge`. Returns 0 if gauge is not live, even if it has weight.
181:     */
182:     function calculateGaugeAllocation(
183:         address gauge,
184:         uint256 quantity
185:     ) external view returns (uint256) {
186:         if (_deprecatedGauges.contains(gauge)) return 0;
187: 
188:         uint256 total = totalTypeWeight[gaugeType[gauge]];
189:         if (total == 0) return 0;
190:         uint256 weight = getGaugeWeight[gauge];
191: 
192:         return (quantity * weight) / total;
193:     }
194: 
195:     /*///////////////////////////////////////////////////////////////
196:                         USER GAUGE OPERATIONS
197:     //////////////////////////////////////////////////////////////*/
198: 
199:     /// @notice emitted when incrementing a gauge
200:     event IncrementGaugeWeight(
201:         address indexed user,
202:         address indexed gauge,
203:         uint256 weight
204:     );
205: 
206:     /// @notice emitted when decrementing a gauge
207:     event DecrementGaugeWeight(
208:         address indexed user,
209:         address indexed gauge,
210:         uint256 weight
211:     );
212: 
213:     /** 
214:     @notice increment a gauge with some weight for the caller
215:     @param gauge the gauge to increment
216:     @param weight the amount of weight to increment on gauge
217:     @return newUserWeight the new user weight
218:     */
219:     function incrementGauge(
220:         address gauge,
221:         uint256 weight
222:     ) public virtual returns (uint256 newUserWeight) {
223:         require(isGauge(gauge), "ERC20Gauges: invalid gauge");
224:         _incrementGaugeWeight(msg.sender, gauge, weight);
225:         return _incrementUserAndGlobalWeights(msg.sender, weight);
226:     }
227: 
228:     /// @dev this function does not check if the gauge exists, this is performed
229:     /// in the calling function.
230:     function _incrementGaugeWeight(
231:         address user,
232:         address gauge,
233:         uint256 weight
234:     ) internal virtual {
235:         bool added = _userGauges[user].add(gauge); // idempotent add
236:         if (added && _userGauges[user].length() > maxGauges) {
237:             require(canExceedMaxGauges[user], "ERC20Gauges: exceed max gauges");
238:         }
239: 
240:         getUserGaugeWeight[user][gauge] += weight;
241: 
242:         getGaugeWeight[gauge] += weight;
243: 
244:         totalTypeWeight[gaugeType[gauge]] += weight;
245: 
246:         emit IncrementGaugeWeight(user, gauge, weight);
247:     }
248: 
249:     function _incrementUserAndGlobalWeights(
250:         address user,
251:         uint256 weight
252:     ) internal returns (uint256 newUserWeight) {
253:         newUserWeight = getUserWeight[user] + weight;
254:         // Ensure under weight
255:         require(newUserWeight <= balanceOf(user), "ERC20Gauges: overweight");
256: 
257:         // Update gauge state
258:         getUserWeight[user] = newUserWeight;
259: 
260:         totalWeight += weight;
261:     }
262: 
263:     /** 
264:     @notice increment a list of gauges with some weights for the caller
265:     @param gaugeList the gauges to increment
266:     @param weights the weights to increment by
267:     @return newUserWeight the new user weight
268:     */
269:     function incrementGauges(
270:         address[] calldata gaugeList,
271:         uint256[] calldata weights
272:     ) public virtual returns (uint256 newUserWeight) {
273:         uint256 size = gaugeList.length;
274:         require(weights.length == size, "ERC20Gauges: size mismatch");
275: 
276:         // store total in summary for batch update on user/global state
277:         uint256 weightsSum;
278: 
279:         // Update gauge specific state
280:         for (uint256 i = 0; i < size; ) {
281:             address gauge = gaugeList[i];
282:             uint256 weight = weights[i];
283:             weightsSum += weight;
284: 
285:             require(isGauge(gauge), "ERC20Gauges: invalid gauge");
286: 
287:             _incrementGaugeWeight(msg.sender, gauge, weight);
288:             unchecked {
289:                 ++i;
290:             }
291:         }
292:         return _incrementUserAndGlobalWeights(msg.sender, weightsSum);
293:     }
294: 
295:     /** 
296:      @notice decrement a gauge with some weight for the caller
297:      @param gauge the gauge to decrement
298:      @param weight the amount of weight to decrement on gauge
299:      @return newUserWeight the new user weight
300:     */
301:     function decrementGauge(
302:         address gauge,
303:         uint256 weight
304:     ) public virtual returns (uint256 newUserWeight) {
305:         // All operations will revert on underflow, protecting against bad inputs
306:         _decrementGaugeWeight(msg.sender, gauge, weight);
307:         if (!_deprecatedGauges.contains(gauge)) {
308:             totalTypeWeight[gaugeType[gauge]] -= weight;
309:             totalWeight -= weight;
310:         }
311:         return getUserWeight[msg.sender];
312:     }
313: 
314:     function _decrementGaugeWeight(
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual {
319:         uint256 oldWeight = getUserGaugeWeight[user][gauge];
320: 
321:         getUserGaugeWeight[user][gauge] = oldWeight - weight;
322:         if (oldWeight == weight) {
323:             // If removing all weight, remove gauge from user list.
324:             require(_userGauges[user].remove(gauge));
325:         }
326: 
327:         getGaugeWeight[gauge] -= weight;
328: 
329:         getUserWeight[user] -= weight;
330: 
331:         emit DecrementGaugeWeight(user, gauge, weight);
332:     }
333: 
334:     /** 
335:      @notice decrement a list of gauges with some weights for the caller
336:      @param gaugeList the gauges to decrement
337:      @param weights the list of weights to decrement on the gauges
338:      @return newUserWeight the new user weight
339:     */
340:     function decrementGauges(
341:         address[] calldata gaugeList,
342:         uint256[] calldata weights
343:     ) public virtual returns (uint256 newUserWeight) {
344:         uint256 size = gaugeList.length;
345:         require(weights.length == size, "ERC20Gauges: size mismatch");
346: 
347:         // store total in summary for batch update on user/global state
348:         uint256 weightsSum;
349: 
350:         // Update gauge specific state
351:         // All operations will revert on underflow, protecting against bad inputs
352:         for (uint256 i = 0; i < size; ) {
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i];
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight);
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i;
363:             }
364:         }
365:         totalWeight -= weightsSum;
366:         return getUserWeight[msg.sender];
367:     }
368: 
369:     /*///////////////////////////////////////////////////////////////
370:                         ADMIN GAUGE OPERATIONS
371:     //////////////////////////////////////////////////////////////*/
372: 
373:     /// @notice emitted when adding a new gauge to the live set.
374:     event AddGauge(address indexed gauge, uint256 indexed gaugeType);
375: 
376:     /// @notice emitted when removing a gauge from the live set.
377:     event RemoveGauge(address indexed gauge);
378: 
379:     /// @notice emitted when updating the max number of gauges a user can delegate to.
380:     event MaxGaugesUpdate(uint256 oldMaxGauges, uint256 newMaxGauges);
381: 
382:     /// @notice emitted when changing a contract's approval to go over the max gauges.
383:     event CanExceedMaxGaugesUpdate(
384:         address indexed account,
385:         bool canExceedMaxGauges
386:     );
387: 
388:     /// @notice the default maximum amount of gauges a user can allocate to.
389:     /// @dev if this number is ever lowered, or a contract has an override, then existing addresses MAY have more gauges allocated to. Use `numUserGauges` to check this.
390:     uint256 public maxGauges;
391: 
392:     /// @notice an approve list for contracts to go above the max gauge limit.
393:     mapping(address => bool) public canExceedMaxGauges;
394: 
395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) {
399:         bool newAdd = _gauges.add(gauge);
400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge);
401:         // add and fail loud if zero address or already present and not deprecated
402:         require(
403:             gauge != address(0) && (newAdd || previouslyDeprecated),
404:             "ERC20Gauges: invalid gauge"
405:         );
406: 
407:         if (newAdd) {
408:             // save gauge type on first add
409:             gaugeType[gauge] = _type;
410:         } else {
411:             // cannot change gauge type on re-add of a previously deprecated gauge
412:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type");
413:         }
414: 
415:         // Check if some previous weight exists and re-add to total. Gauge and user weights are preserved.
416:         weight = getGaugeWeight[gauge];
417:         if (weight != 0) {
418:             totalTypeWeight[_type] += weight;
419:             totalWeight += weight;
420:         }
421: 
422:         emit AddGauge(gauge, _type);
423:     }
424: 
425:     function _removeGauge(address gauge) internal {
426:         // add to deprecated and fail loud if not present
427:         require(
428:             _gauges.contains(gauge) && _deprecatedGauges.add(gauge),
429:             "ERC20Gauges: invalid gauge"
430:         );
431: 
432:         // Remove weight from total but keep the gauge and user weights in storage in case gauge is re-added.
433:         uint256 weight = getGaugeWeight[gauge];
434:         if (weight != 0) {
435:             totalTypeWeight[gaugeType[gauge]] -= weight;
436:             totalWeight -= weight;
437:         }
438: 
439:         emit RemoveGauge(gauge);
440:     }
441: 
442:     /// @notice set the new max gauges. Requires auth by `authority`.
443:     /// @dev if this is set to a lower number than the current max, users MAY have more gauges active than the max. Use `numUserGauges` to check this.
444:     function _setMaxGauges(uint256 newMax) internal {
445:         uint256 oldMax = maxGauges;
446:         maxGauges = newMax;
447: 
448:         emit MaxGaugesUpdate(oldMax, newMax);
449:     }
450: 
451:     /// @notice set the canExceedMaxGauges flag for an account.
452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0,
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
467: 
468:     /*///////////////////////////////////////////////////////////////
469:                             ERC20 LOGIC
470:     //////////////////////////////////////////////////////////////*/
471: 
472:     /// NOTE: any "removal" of tokens from a user requires userUnusedWeight < amount.
473:     /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.
474:     /// It may be more gas efficient to free weight before burning or transferring tokens.
475: 
476:     function _burn(address from, uint256 amount) internal virtual override {
477:         _decrementWeightUntilFree(from, amount);
478:         super._burn(from, amount);
479:     }
480: 
481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount);
486:         return super.transfer(to, amount);
487:     }
488: 
489:     function transferFrom(
490:         address from,
491:         address to,
492:         uint256 amount
493:     ) public virtual override returns (bool) {
494:         _decrementWeightUntilFree(from, amount);
495:         return super.transferFrom(from, to, amount);
496:     }
497: 
498:     /// a greedy algorithm for freeing weight before a token burn/transfer
499:     /// frees up entire gauges, so likely will free more than `weight`
500:     function _decrementWeightUntilFree(address user, uint256 weight) internal {
501:         uint256 userFreeWeight = balanceOf(user) - getUserWeight[user];
502: 
503:         // early return if already free
504:         if (userFreeWeight >= weight) return;
505: 
506:         // cache totals for batch updates
507:         uint256 userFreed;
508:         uint256 totalFreed;
509: 
510:         // Loop through all user gauges, live and deprecated
511:         address[] memory gaugeList = _userGauges[user].values();
512: 
513:         // Free gauges until through entire list or under weight
514:         uint256 size = gaugeList.length;
515:         for (
516:             uint256 i = 0;
517:             i < size && (userFreeWeight + userFreed) < weight;
518: 
519:         ) {
520:             address gauge = gaugeList[i];
521:             uint256 userGaugeWeight = getUserGaugeWeight[user][gauge];
522:             if (userGaugeWeight != 0) {
523:                 userFreed += userGaugeWeight;
524:                 _decrementGaugeWeight(user, gauge, userGaugeWeight);
525: 
526:                 // If the gauge is live (not deprecated), include its weight in the total to remove
527:                 if (!_deprecatedGauges.contains(gauge)) {
528:                     totalTypeWeight[gaugeType[gauge]] -= userGaugeWeight;
529:                     totalFreed += userGaugeWeight;
530:                 }
531: 
532:                 unchecked {
533:                     ++i;
534:                 }
535:             }
536:         }
537: 
538:         totalWeight -= totalFreed;
539:     }
540: }
541: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
5: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol";
6: 
7: /** 
8: @title  An ERC20 with rebase capabilities. Anyone can sacrifice tokens to rebase up the balance
9:         of all addresses that are currently rebasing.
10: @author eswak
11: @notice This contract is meant to be used to distribute rewards proportionately to all holders of
12:         a token, for instance to distribute buybacks or income generated by a protocol.
13: 
14:         Anyone can subscribe to rebasing by calling `enterRebase()`, and unsubcribe with `exitRebase()`.
15:         Anyone can burn tokens they own to `distribute(uint256)` proportionately to rebasing addresses.
16: 
17:         The following conditions are always met :
18:         ```
19:         totalSupply() == nonRebasingSupply() + rebasingSupply()
20:         sum of balanceOf(x) == totalSupply() [+= rounding down errors of 1 wei for each balanceOf]
21:         ```
22: 
23:         Internally, when a user subscribes to the rebase, their balance is converted to a number of
24:         shares, and the total number of shares is updated. When a user unsubscribes, their shares are
25:         converted back to a balance, and the total number of shares is updated.
26: 
27:         On each distribution, the share price of rebasing tokens is updated to reflect the new value
28:         of rebasing shares. The formula is as follow :
29: 
30:         ```
31:         newSharePrice = oldSharePrice * (rebasingSupply + amount) / rebasingSupply
32:         ```
33: 
34:         If the rebasingSupply is 0 (nobody subscribed to rebasing), the tokens distributed are burnt
35:         but nobody benefits for the share price increase, since the share price cannot be updated.
36: 
37:         /!\ The first user subscribing to rebase should have a meaningful balance in order to avoid
38:         share price manipulation (see hundred finance exploit).
39:         It is advised to keep a minimum balance rebasing at all times, for instance with a small
40:         rebasing balance held by the deployer address or address(0) or the token itself.
41: */
42: abstract contract ERC20RebaseDistributor is ERC20 {
43:     /*///////////////////////////////////////////////////////////////
44:                             EVENTS
45:     ///////////////////////////////////////////////////////////////*/
46: 
47:     /// @notice Emitted when an `account` enters rebasing.
48:     event RebaseEnter(address indexed account, uint256 indexed timestamp);
49:     /// @notice Emitted when an `account` exits rebasing.
50:     event RebaseExit(address indexed account, uint256 indexed timestamp);
51:     /// @notice Emitted when an `amount` of tokens is distributed by `source` to the rebasing accounts.
52:     event RebaseDistribution(
53:         address indexed source,
54:         uint256 indexed timestamp,
55:         uint256 amountDistributed,
56:         uint256 amountRebasing
57:     );
58:     /// @notice Emitted when an `amount` of tokens is realized as rebase rewards for `account`.
59:     /// @dev `totalSupply()`, `rebasingSupply()`, and `balanceOf()` reflect the rebase rewards
60:     /// in real time, but the internal storage only realizes rebase rewards if the user has an
61:     /// interaction with the token contract in one of the following functions:
62:     /// - exitRebase()
63:     /// - burn()
64:     /// - mint()
65:     /// - transfer() received or sent
66:     /// - transferFrom() received or sent
67:     event RebaseReward(
68:         address indexed account,
69:         uint256 indexed timestamp,
70:         uint256 amount
71:     );
72: 
73:     /*///////////////////////////////////////////////////////////////
74:                             INTERNAL STATE
75:     ///////////////////////////////////////////////////////////////*/
76: 
77:     struct RebasingState {
78:         uint8 isRebasing;
79:         uint248 nShares;
80:     }
81: 
82:     /// @notice For internal accounting. Number of rebasing shares for each rebasing accounts. 0 if account is not rebasing.
83:     mapping(address => RebasingState) internal rebasingState;
84: 
85:     /// @notice For internal accounting. Total number of rebasing shares
86:     uint256 internal totalRebasingShares;
87: 
88:     /// @notice The starting share price for rebasing addresses.
89:     /// @dev rounding errors start to appear when balances of users are near `rebasingSharePrice()`,
90:     /// due to rounding down in the number of shares attributed, and rounding down in the number of
91:     /// tokens per share. We use a high base to ensure no crazy rounding errors happen at runtime
92:     /// (balances of users would have to be > START_REBASING_SHARE_PRICE for rounding errors to start to materialize).
93:     uint256 internal constant START_REBASING_SHARE_PRICE = 1e30;
94: 
95:     /// @notice share price increase and pending rebase rewards from distribute() are
96:     /// interpolated linearly over a period of DISTRIBUTION_PERIOD seconds after a distribution.
97:     uint256 public constant DISTRIBUTION_PERIOD = 30 days;
98: 
99:     struct InterpolatedValue {
100:         uint32 lastTimestamp;
101:         uint224 lastValue;
102:         uint32 targetTimestamp;
103:         uint224 targetValue;
104:     }
105: 
106:     /// @notice For internal accounting. Number of tokens per share for the rebasing supply.
107:     /// Starts at START_REBASING_SHARE_PRICE and goes up only.
108:     InterpolatedValue internal __rebasingSharePrice =
109:         InterpolatedValue({
110:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
111:             lastValue: uint224(START_REBASING_SHARE_PRICE), // safe initial value
112:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
113:             targetValue: uint224(START_REBASING_SHARE_PRICE) // safe initial value
114:         });
115: 
116:     /// @notice For internal accounting. Number of tokens distributed to rebasing addresses that have not
117:     /// yet been materialized by a movement in the rebasing addresses.
118:     InterpolatedValue internal __unmintedRebaseRewards =
119:         InterpolatedValue({
120:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
121:             lastValue: 0,
122:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
123:             targetValue: 0
124:         });
125: 
126:     /*///////////////////////////////////////////////////////////////
127:                             INTERNAL UTILS
128:     ///////////////////////////////////////////////////////////////*/
129: 
130:     /// @notice get the current value of an interpolated value
131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) {
134:         // load state
135:         uint256 lastTimestamp = uint256(val.lastTimestamp); // safe upcast
136:         uint256 lastValue = uint256(val.lastValue); // safe upcast
137:         uint256 targetTimestamp = uint256(val.targetTimestamp); // safe upcast
138:         uint256 targetValue = uint256(val.targetValue); // safe upcast
139: 
140:         // interpolate increase over period
141:         if (block.timestamp >= targetTimestamp) {
142:             // if period is passed, return target value
143:             return targetValue;
144:         } else {
145:             // block.timestamp is within [lastTimestamp, targetTimestamp[
146:             uint256 elapsed = block.timestamp - lastTimestamp;
147:             uint256 delta = targetValue - lastValue;
148:             return
149:                 lastValue +
150:                 (delta * elapsed) /
151:                 (targetTimestamp - lastTimestamp);
152:         }
153:     }
154: 
155:     /// @notice called to update the number of rebasing shares.
156:     /// This can happen in multiple situations:
157:     /// - enterRebase()
158:     /// - exitRebase()
159:     /// - burn() from a rebasing address
160:     /// - mint() to a rebasing address
161:     /// - transfer() from a rebasing address
162:     /// - transfer() to a rebasing address
163:     /// - transferFrom() from a rebasing address
164:     /// - transferFrom() to a rebasing address
165:     /// If the number of shares is updated during the interpolation, the target share price
166:     /// of the interpolation should be changed to reflect the reduced or increased number of shares
167:     /// and keep a constant rebasing supply value (current & target).
168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             // else sharesAfter stays 0
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         // reset interpolation & share price if going to 0 rebasing supply
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), // safe initial value
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) // safe initial value
195:             });
196:             __unmintedRebaseRewards = InterpolatedValue({
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             });
202:             return;
203:         }
204: 
205:         // when total shares is multiplied by x, the remaining share price change ("delta" below)
206:         // should be multiplied by 1/x, e.g. going from a share price of 1.0 to 1.5, and current
207:         // value is 1.25, the remaining share price change "delta" is 0.25.
208:         // if the rebasing supply 2x, the share price change should 0.5x to 0.125.
209:         // at the end of the interpolation period, the share price will be 1.375.
210:         InterpolatedValue memory val = __rebasingSharePrice;
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice +
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
218:             __rebasingSharePrice = InterpolatedValue({
219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), // current value
221:                 targetTimestamp: val.targetTimestamp, // unchanged
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) // adjusted target
223:             });
224:         }
225:     }
226: 
227:     /// @notice decrease unminted rebase rewards, when rewards are minted to users
228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal {
229:         InterpolatedValue memory val = __unmintedRebaseRewards;
230:         uint256 _unmintedRebaseRewards = interpolatedValue(val);
231:         __unmintedRebaseRewards = InterpolatedValue({
232:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // now
233:             lastValue: SafeCastLib.safeCastTo224(
234:                 _unmintedRebaseRewards - amount
235:             ), // adjusted current
236:             targetTimestamp: val.targetTimestamp, // unchanged
237:             targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount) // adjusted target
238:         });
239:     }
240: 
241:     /// @notice get the current rebasing share price
242:     function rebasingSharePrice() internal view returns (uint256) {
243:         return interpolatedValue(__rebasingSharePrice);
244:     }
245: 
246:     /// @notice get the current unminted rebase rewards
247:     function unmintedRebaseRewards() internal view returns (uint256) {
248:         return interpolatedValue(__unmintedRebaseRewards);
249:     }
250: 
251:     /// @notice convert a balance to a number of shares
252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) {
256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice;
257:     }
258: 
259:     /// @notice convert a number of shares to a balance
260:     function _shares2balance(
261:         uint256 shares,
262:         uint256 sharePrice,
263:         uint256 deltaBalance,
264:         uint256 minBalance
265:     ) internal pure returns (uint256) {
266:         uint256 rebasedBalance = (shares * sharePrice) /
267:             START_REBASING_SHARE_PRICE +
268:             deltaBalance;
269:         if (rebasedBalance < minBalance) {
270:             rebasedBalance = minBalance;
271:         }
272:         return rebasedBalance;
273:     }
274: 
275:     /*///////////////////////////////////////////////////////////////
276:                             EXTERNAL API
277:     ///////////////////////////////////////////////////////////////*/
278: 
279:     /// @notice Enter rebasing supply. All subsequent distributions will increase the balance
280:     /// of `msg.sender` proportionately.
281:     function enterRebase() external {
282:         require(
283:             rebasingState[msg.sender].isRebasing == 0,
284:             "ERC20RebaseDistributor: already rebasing"
285:         );
286:         _enterRebase(msg.sender);
287:     }
288: 
289:     function _enterRebase(address account) internal {
290:         uint256 balance = ERC20.balanceOf(account);
291:         uint256 currentRebasingSharePrice = rebasingSharePrice();
292:         uint256 shares = _balance2shares(balance, currentRebasingSharePrice);
293:         rebasingState[account] = RebasingState({
294:             isRebasing: 1,
295:             nShares: uint248(shares)
296:         });
297:         updateTotalRebasingShares(currentRebasingSharePrice, int256(shares));
298:         emit RebaseEnter(account, block.timestamp);
299:     }
300: 
301:     /// @notice Exit rebasing supply. All unminted rebasing rewards are physically minted to the user,
302:     /// and they won't be affected by rebases anymore.
303:     function exitRebase() external {
304:         require(
305:             rebasingState[msg.sender].isRebasing == 1,
306:             "ERC20RebaseDistributor: not rebasing"
307:         );
308:         _exitRebase(msg.sender);
309:     }
310: 
311:     function _exitRebase(address account) internal {
312:         uint256 rawBalance = ERC20.balanceOf(account);
313:         RebasingState memory _rebasingState = rebasingState[account];
314:         uint256 shares = uint256(_rebasingState.nShares);
315:         uint256 currentRebasingSharePrice = rebasingSharePrice();
316:         uint256 rebasedBalance = _shares2balance(
317:             shares,
318:             currentRebasingSharePrice,
319:             0,
320:             rawBalance
321:         );
322:         uint256 mintAmount = rebasedBalance - rawBalance;
323:         if (mintAmount != 0) {
324:             ERC20._mint(account, mintAmount);
325:             decreaseUnmintedRebaseRewards(mintAmount);
326:             emit RebaseReward(account, block.timestamp, mintAmount);
327:         }
328: 
329:         rebasingState[account] = RebasingState({isRebasing: 0, nShares: 0});
330:         updateTotalRebasingShares(currentRebasingSharePrice, -int256(shares));
331: 
332:         emit RebaseExit(account, block.timestamp);
333:     }
334: 
335:     /// @notice distribute tokens proportionately to all rebasing accounts.
336:     /// @dev if no addresses are rebasing, calling this function will burn tokens
337:     /// from `msg.sender` and emit an event, but won't rebase up any balances.
338:     function distribute(uint256 amount) external {
339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero");
340: 
341:         // burn the tokens received
342:         _burn(msg.sender, amount);
343: 
344:         // emit event
345:         uint256 _rebasingSharePrice = rebasingSharePrice();
346:         uint256 _totalRebasingShares = totalRebasingShares;
347:         uint256 _rebasingSupply = _shares2balance(
348:             _totalRebasingShares,
349:             _rebasingSharePrice,
350:             0,
351:             0
352:         );
353:         emit RebaseDistribution(
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
359: 
360:         // adjust up the balance of all accounts that are rebasing by increasing
361:         // the share price of rebasing tokens
362:         if (_rebasingSupply != 0) {
363:             // update rebasingSharePrice interpolation
364:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;
365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares;
369:             __rebasingSharePrice = InterpolatedValue({
370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
375: 
376:             // update unmintedRebaseRewards interpolation
377:             uint256 _unmintedRebaseRewards = unmintedRebaseRewards();
378:             __unmintedRebaseRewards = InterpolatedValue({
379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
385:         }
386:     }
387: 
388:     /// @notice True if an address subscribed to rebasing.
389:     function isRebasing(address account) public view returns (bool) {
390:         return rebasingState[account].isRebasing == 1;
391:     }
392: 
393:     /// @notice Total number of the tokens that are rebasing.
394:     function rebasingSupply() public view returns (uint256) {
395:         return _shares2balance(totalRebasingShares, rebasingSharePrice(), 0, 0);
396:     }
397: 
398:     /// @notice Total number of the tokens that are not rebasing.
399:     function nonRebasingSupply() external view virtual returns (uint256) {
400:         uint256 _totalSupply = totalSupply();
401:         uint256 _rebasingSupply = rebasingSupply();
402: 
403:         // compare rebasing supply to total supply :
404:         // rounding errors due to share price & number of shares could otherwise
405:         // make this function revert due to an underflow
406:         if (_rebasingSupply > _totalSupply) {
407:             return 0;
408:         } else {
409:             return _totalSupply - _rebasingSupply;
410:         }
411:     }
412: 
413:     /// @notice get the number of distributed tokens that have not yet entered
414:     /// circulation through rebase due to the interpolation of rewards over time.
415:     function pendingDistributedSupply() external view returns (uint256) {
416:         InterpolatedValue memory val = __unmintedRebaseRewards;
417:         uint256 _unmintedRebaseRewards = interpolatedValue(val);
418:         return __unmintedRebaseRewards.targetValue - _unmintedRebaseRewards;
419:     }
420: 
421:     /*///////////////////////////////////////////////////////////////
422:                             ERC20 OVERRIDE
423:     ///////////////////////////////////////////////////////////////*/
424: 
425:     /// @notice Override of balanceOf() that takes into account the unminted rebase rewards.
426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256) {
429:         RebasingState memory _rebasingState = rebasingState[account];
430:         if (_rebasingState.isRebasing == 0) {
431:             return ERC20.balanceOf(account);
432:         } else {
433:             return
434:                 _shares2balance(
435:                     _rebasingState.nShares,
436:                     rebasingSharePrice(),
437:                     0,
438:                     ERC20.balanceOf(account)
439:                 );
440:         }
441:     }
442: 
443:     /// @notice Total number of the tokens in existence.
444:     function totalSupply() public view virtual override returns (uint256) {
445:         return ERC20.totalSupply() + unmintedRebaseRewards();
446:     }
447: 
448:     /// @notice Target total number of the tokens in existence after interpolations
449:     /// of rebase rewards will have completed.
450:     /// @dev Equal to totalSupply() + pendingDistributedSupply().
451:     function targetTotalSupply() external view returns (uint256) {
452:         return ERC20.totalSupply() + __unmintedRebaseRewards.targetValue;
453:     }
454: 
455:     /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
456:     /// and re-enter rebasing after movement (if rebasing).
457:     /// @dev for _burn(), _mint(), transfer(), and transferFrom() overrides, a naive
458:     /// and concise implementation would be to just _exitRebase(), call the default ERC20 behavior,
459:     /// and then _enterRebase(), on the 2 addresses affected by the movement, but this is highly gas
460:     /// inefficient and the more complex implementations below are saving up to 40% gas costs.
461:     function _burn(address account, uint256 amount) internal virtual override {
462:         // if `account` is rebasing, materialize the tokens from rebase first, to ensure
463:         // proper behavior in `ERC20._burn()`.
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) {
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares,
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount;
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         // do ERC20._burn()
486:         ERC20._burn(account, amount);
487: 
488:         // if `account` is rebasing, update its number of shares
489:         if (_rebasingState.isRebasing == 1) {
490:             uint256 balanceAfter = balanceBefore - amount;
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;
496:             rebasingState[account] = RebasingState({
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
506: 
507:     /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
508:     /// and re-enter rebasing after movement (if rebasing).
509:     function _mint(address account, uint256 amount) internal virtual override {
510:         // do ERC20._mint()
511:         ERC20._mint(account, amount);
512: 
513:         // if `account` is rebasing, update its number of shares
514:         RebasingState memory _rebasingState = rebasingState[account];
515:         if (_rebasingState.isRebasing == 1) {
516:             // compute rebased balance
517:             uint256 _rebasingSharePrice = rebasingSharePrice();
518:             uint256 rawBalance = ERC20.balanceOf(account);
519:             uint256 rebasedBalance = _shares2balance(
520:                 _rebasingState.nShares,
521:                 _rebasingSharePrice,
522:                 amount,
523:                 rawBalance
524:             );
525: 
526:             // update number of shares
527:             uint256 sharesAfter = _balance2shares(
528:                 rebasedBalance,
529:                 _rebasingSharePrice
530:             );
531:             uint256 sharesReceived = sharesAfter - _rebasingState.nShares;
532:             rebasingState[account] = RebasingState({
533:                 isRebasing: 1,
534:                 nShares: uint248(sharesAfter)
535:             });
536:             updateTotalRebasingShares(
537:                 _rebasingSharePrice,
538:                 int256(sharesReceived)
539:             );
540: 
541:             // "realize" unminted rebase rewards
542:             uint256 mintAmount = rebasedBalance - rawBalance;
543:             if (mintAmount != 0) {
544:                 ERC20._mint(account, mintAmount);
545:                 decreaseUnmintedRebaseRewards(mintAmount);
546:                 emit RebaseReward(account, block.timestamp, mintAmount);
547:             }
548:         }
549:     }
550: 
551:     /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
552:     /// and re-enter rebasing after movement (if rebasing).
553:     function transfer(
554:         address to,
555:         uint256 amount
556:     ) public virtual override returns (bool) {
557:         // if `from` is rebasing, materialize the tokens from rebase to ensure
558:         // proper behavior in `ERC20.transfer()`.
559:         RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
560:         RebasingState memory rebasingStateTo = rebasingState[to];
561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
562:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
563:             rebasingStateTo.isRebasing == 1)
564:             ? rebasingSharePrice()
565:             : 0; // only SLOAD if at least one address is rebasing
566:         if (rebasingStateFrom.isRebasing == 1) {
567:             uint256 shares = uint256(rebasingStateFrom.nShares);
568:             uint256 rebasedBalance = _shares2balance(
569:                 shares,
570:                 _rebasingSharePrice,
571:                 0,
572:                 fromBalanceBefore
573:             );
574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
575:             if (mintAmount != 0) {
576:                 ERC20._mint(msg.sender, mintAmount);
577:                 fromBalanceBefore += mintAmount;
578:                 decreaseUnmintedRebaseRewards(mintAmount);
579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount);
580:             }
581:         }
582: 
583:         // do ERC20.transfer()
584:         bool success = ERC20.transfer(to, amount);
585: 
586:         // if `from` is rebasing, update its number of shares
587:         int256 sharesDelta;
588:         if (rebasingStateFrom.isRebasing == 1) {
589:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
590:             uint256 fromSharesAfter = _balance2shares(
591:                 fromBalanceAfter,
592:                 _rebasingSharePrice
593:             );
594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
595:             sharesDelta -= int256(sharesSpent);
596:             rebasingState[msg.sender] = RebasingState({
597:                 isRebasing: 1,
598:                 nShares: uint248(fromSharesAfter)
599:             });
600:         }
601: 
602:         // if `to` is rebasing, update its number of shares
603:         if (rebasingStateTo.isRebasing == 1) {
604:             // compute rebased balance
605:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
606:             uint256 toBalanceAfter = _shares2balance(
607:                 rebasingStateTo.nShares,
608:                 _rebasingSharePrice,
609:                 amount,
610:                 rawToBalanceAfter
611:             );
612: 
613:             // update number of shares
614:             uint256 toSharesAfter = _balance2shares(
615:                 toBalanceAfter,
616:                 _rebasingSharePrice
617:             );
618:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
619:             sharesDelta += int256(sharesReceived);
620:             rebasingState[to] = RebasingState({
621:                 isRebasing: 1,
622:                 nShares: uint248(toSharesAfter)
623:             });
624: 
625:             // "realize" unminted rebase rewards
626:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
627:             if (mintAmount != 0) {
628:                 ERC20._mint(to, mintAmount);
629:                 decreaseUnmintedRebaseRewards(mintAmount);
630:                 emit RebaseReward(to, block.timestamp, mintAmount);
631:             }
632:         }
633: 
634:         // if `from` or `to` was rebasing, update the total number of shares
635:         if (
636:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1
637:         ) {
638:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
639:         }
640: 
641:         return success;
642:     }
643: 
644:     /// @notice Override of default ERC20 behavior: exit rebase before movement (if rebasing),
645:     /// and re-enter rebasing after movement (if rebasing).
646:     function transferFrom(
647:         address from,
648:         address to,
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         // if `from` is rebasing, materialize the tokens from rebase to ensure
652:         // proper behavior in `ERC20.transfer()`.
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
657:             rebasingStateTo.isRebasing == 1)
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) {
661:             uint256 shares = uint256(rebasingStateFrom.nShares);
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount;
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         // do ERC20.transferFrom()
678:         bool success = ERC20.transferFrom(from, to, amount);
679: 
680:         // if `from` is rebasing, update its number of shares
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) {
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
689:             sharesDelta -= int256(sharesSpent);
690:             rebasingState[from] = RebasingState({
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
696:         // if `to` is rebasing, update its number of shares
697:         if (rebasingStateTo.isRebasing == 1) {
698:             // compute rebased balance
699:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
700:             uint256 toBalanceAfter = _shares2balance(
701:                 rebasingStateTo.nShares,
702:                 _rebasingSharePrice,
703:                 amount,
704:                 rawToBalanceAfter
705:             );
706: 
707:             // update number of shares
708:             uint256 toSharesAfter = _balance2shares(
709:                 toBalanceAfter,
710:                 _rebasingSharePrice
711:             );
712:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
713:             sharesDelta += int256(sharesReceived);
714:             rebasingState[to] = RebasingState({
715:                 isRebasing: 1,
716:                 nShares: uint248(toSharesAfter)
717:             });
718: 
719:             // "realize" unminted rebase rewards
720:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
721:             if (mintAmount != 0) {
722:                 ERC20._mint(to, mintAmount);
723:                 decreaseUnmintedRebaseRewards(mintAmount);
724:                 emit RebaseReward(to, block.timestamp, mintAmount);
725:             }
726:         }
727: 
728:         // if `from` or `to` was rebasing, update the total number of shares
729:         if (
730:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1
731:         ) {
732:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
733:         }
734: 
735:         return success;
736:     }
737: }
738: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {CoreRef} from "@src/core/CoreRef.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: import {SimplePSM} from "@src/loan/SimplePSM.sol";
7: import {GuildToken} from "@src/tokens/GuildToken.sol";
8: import {LendingTerm} from "@src/loan/LendingTerm.sol";
9: 
10: /// @notice Utils to offboard a LendingTerm.
11: /// This contract works somewhat similarly to a Veto governor: any GUILD holder can poll for the removal
12: /// of a lending term, and if enough GUILD holders vote for a removal poll, the term can be offboarded
13: /// without delay.
14: /// When a term is offboarded, no new loans can be issued, and GUILD holders cannot vote for the term anymore.
15: /// After a term is offboarded, all the loans have to be called, then the term can be cleaned up (roles).
16: contract LendingTermOffboarding is CoreRef {
17:     /// @notice emitted when a user supports the removal of a lending term
18:     event OffboardSupport(
19:         uint256 indexed timestamp,
20:         address indexed term,
21:         uint256 indexed snapshotBlock,
22:         address user,
23:         uint256 userWeight
24:     );
25:     /// @notice emitted when a lending term is offboarded
26:     event Offboard(uint256 indexed timestamp, address indexed term);
27:     /// @notice emitted when a lending term is cleaned up
28:     event Cleanup(uint256 indexed timestamp, address indexed term);
29: 
30:     /// @notice Emitted when quorum is updated.
31:     event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
32: 
33:     /// @notice maximum age of polls for them to be considered valid.
34:     /// This offboarding mechanism is meant to be used in a reactive fashion, and
35:     /// polls should not stay open for a long time.
36:     uint256 public constant POLL_DURATION_BLOCKS = 46523; // ~7 days @ 13s/block
37: 
38:     /// @notice quorum for offboarding a lending term
39:     uint256 public quorum;
40: 
41:     /// @notice reference to the GUILD token
42:     address public immutable guildToken;
43: 
44:     /// @notice reference to the PSM
45:     address public immutable psm;
46: 
47:     /// @notice list of removal polls created.
48:     /// keys = [snapshotBlock][termAddress] -> quorum supporting the removal.
49:     mapping(uint256 => mapping(address => uint256)) public polls;
50: 
51:     /// @notice list of user votes in removal polls
52:     /// keys = [userAddress][snapshotBlock][termAddress] -> user vote weight.
53:     mapping(address => mapping(uint256 => mapping(address => uint256)))
54:         public userPollVotes;
55: 
56:     /// @notice block number of last removal polls created for each term.
57:     /// key = [termAddress] -> block number.
58:     mapping(address => uint256) public lastPollBlock;
59: 
60:     /// @notice mapping of terms that can be offboarded.
61:     mapping(address => bool) public canOffboard;
62: 
63:     /// @notice number of offboardings in progress.
64:     uint256 public nOffboardingsInProgress;
65: 
66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken;
73:         psm = _psm;
74:         quorum = _quorum;
75:     }
76: 
77:     /// @notice set the quorum for offboard votes
78:     function setQuorum(
79:         uint256 _quorum
80:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
81:         emit QuorumUpdated(quorum, _quorum);
82:         quorum = _quorum;
83:     }
84: 
85:     /// @notice Propose to offboard a given LendingTerm.
86:     /// @dev the poll starts with 1 wei of voting power, to initialize the storage slot
87:     /// that counts the number of user supports (a value of 0 is used as the existence
88:     /// check to know if a poll has been created).
89:     function proposeOffboard(address term) external whenNotPaused {
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         // Check that the term is an active gauge
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; // voting power
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
114: 
115:     /// @notice Support a poll to offboard a given LendingTerm.
116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term];
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0,
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight;
137:         polls[snapshotBlock][term] = _weight + userWeight;
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true;
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
149: 
150:     /// @notice Offboard a LendingTerm.
151:     /// This will prevent new loans from being open, and will prevent GUILD holders to vote for the term.
152:     /// @param term LendingTerm to offboard from the system.
153:     function offboard(address term) external whenNotPaused {
154:         require(canOffboard[term], "LendingTermOffboarding: quorum not met");
155: 
156:         // update protocol config
157:         // this will revert if the term has already been offboarded
158:         // through another mean.
159:         GuildToken(guildToken).removeGauge(term);
160: 
161:         // pause psm redemptions
162:         if (
163:             nOffboardingsInProgress++ == 0 &&
164:             !SimplePSM(psm).redemptionsPaused()
165:         ) {
166:             SimplePSM(psm).setRedemptionsPaused(true);
167:         }
168: 
169:         emit Offboard(block.timestamp, term);
170:     }
171: 
172:     /// @notice Cleanup roles of a LendingTerm.
173:     /// This is only callable after a term has been offboarded and all its loans have been closed.
174:     /// @param term LendingTerm to cleanup.
175:     function cleanup(address term) external whenNotPaused {
176:         require(canOffboard[term], "LendingTermOffboarding: quorum not met");
177:         require(
178:             LendingTerm(term).issuance() == 0,
179:             "LendingTermOffboarding: not all loans closed"
180:         );
181:         require(
182:             GuildToken(guildToken).isDeprecatedGauge(term),
183:             "LendingTermOffboarding: re-onboarded"
184:         );
185: 
186:         // update protocol config
187:         core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);
188:         core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);
189: 
190:         // unpause psm redemptions
191:         if (
192:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()
193:         ) {
194:             SimplePSM(psm).setRedemptionsPaused(false);
195:         }
196: 
197:         canOffboard[term] = false;
198:         emit Cleanup(block.timestamp, term);
199:     }
200: }
201: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {CoreRef} from "@src/core/CoreRef.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: import {RateLimitedV2} from "@src/utils/RateLimitedV2.sol";
7: 
8: import {CreditToken} from "@src/tokens/CreditToken.sol";
9: 
10: interface IERC20Mintable {
11:     function mint(address to, uint256 amount) external;
12: }
13: 
14: /// @notice contract to mint tokens on a rate limit.
15: /// All minting should flow through this smart contract, as it should be the only one with
16: /// minting capabilities.
17: contract RateLimitedMinter is RateLimitedV2 {
18:     /// @notice the reference to token
19:     address public immutable token;
20: 
21:     /// @notice role used to access control on mint/replenishBuffer
22:     bytes32 public immutable role;
23: 
24:     /// @param _core reference to the core smart contract
25:     /// @param _token reference to the token to mint
26:     /// @param _role role used to check access control
27:     /// @param _maxRateLimitPerSecond maximum rate limit per second that governance can set
28:     /// @param _rateLimitPerSecond starting rate limit per second for minting
29:     /// @param _bufferCap cap on buffer size for this rate limited instance
30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     {
41:         token = _token;
42:         role = _role;
43:     }
44: 
45:     /// @notice Mint new tokens.
46:     /// Pausable and depletes the buffer, reverts if buffer is used.
47:     /// @param to the recipient address of the minted tokens.
48:     /// @param amount the amount of tokens to mint.
49:     function mint(
50:         address to,
51:         uint256 amount
52:     ) external onlyCoreRole(role) whenNotPaused {
53:         _depleteBuffer(amount); /// check and effects
54:         IERC20Mintable(token).mint(to, amount); /// interactions
55:     }
56: 
57:     /// @notice replenish the buffer.
58:     /// This can be used when tokens are burnt, for instance.
59:     /// @param amount of tokens to replenish buffer by
60:     function replenishBuffer(uint256 amount) external onlyCoreRole(role) {
61:         _replenishBuffer(amount); /// effects
62:     }
63: }
64: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {Core} from "@src/core/Core.sol";
5: import {CoreRoles} from "@src/core/CoreRoles.sol";
6: 
7: import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol";
8: 
9: /// @title A Reference to Core
10: /// @author eswak
11: /// @notice defines some modifiers and utilities around interacting with Core
12: abstract contract CoreRef is Pausable {
13:     /// @notice emitted when the reference to core is updated
14:     event CoreUpdate(address indexed oldCore, address indexed newCore);
15: 
16:     /// @notice reference to Core
17:     Core private _core;
18: 
19:     constructor(address coreAddress) {
20:         _core = Core(coreAddress);
21:     }
22: 
23:     /// @notice named onlyCoreRole to prevent collision with OZ onlyRole modifier
24:     modifier onlyCoreRole(bytes32 role) {
25:         require(_core.hasRole(role, msg.sender), "UNAUTHORIZED");
26:         _;
27:     }
28: 
29:     /// @notice address of the Core contract referenced
30:     function core() public view returns (Core) {
31:         return _core;
32:     }
33: 
34:     /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY
35:     /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY
36:     /// @notice set new reference to core
37:     /// only callable by governor
38:     /// @param newCore to reference
39:     function setCore(
40:         address newCore
41:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
42:         _setCore(newCore);
43:     }
44: 
45:     /// @notice WARNING CALLING THIS FUNCTION CAN POTENTIALLY
46:     /// BRICK A CONTRACT IF CORE IS SET INCORRECTLY
47:     /// @notice set new reference to core
48:     /// @param newCore to reference
49:     function _setCore(address newCore) internal {
50:         address oldCore = address(_core);
51:         _core = Core(newCore);
52: 
53:         emit CoreUpdate(oldCore, newCore);
54:     }
55: 
56:     /// @notice set pausable methods to paused
57:     function pause() public onlyCoreRole(CoreRoles.GUARDIAN) {
58:         _pause();
59:     }
60: 
61:     /// @notice set pausable methods to unpaused
62:     function unpause() public onlyCoreRole(CoreRoles.GUARDIAN) {
63:         _unpause();
64:     }
65: 
66:     /// ------------------------------------------
67:     /// ------------ Emergency Action ------------
68:     /// ------------------------------------------
69: 
70:     /// inspired by MakerDAO Multicall:
71:     /// https://github.com/makerdao/multicall/blob/master/src/Multicall.sol
72: 
73:     /// @notice struct to pack calldata and targets for an emergency action
74:     struct Call {
75:         /// @notice target address to call
76:         address target;
77:         /// @notice amount of eth to send with the call
78:         uint256 value;
79:         /// @notice payload to send to target
80:         bytes callData;
81:     }
82: 
83:     /// @notice due to inflexibility of current smart contracts,
84:     /// add this ability to be able to execute arbitrary calldata
85:     /// against arbitrary addresses.
86:     /// callable only by governor
87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
108: }
109: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
5: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol";
6: 
7: import {CoreRef} from "@src/core/CoreRef.sol";
8: import {CoreRoles} from "@src/core/CoreRoles.sol";
9: import {IRateLimitedV2} from "@src/utils/IRateLimitedV2.sol";
10: 
11: /// @title abstract contract for putting a rate limit on how fast a contract
12: /// can perform an action e.g. Minting
13: /// @author Elliot Friedman
14: abstract contract RateLimitedV2 is IRateLimitedV2, CoreRef {
15:     using SafeCastLib for *;
16: 
17:     /// @notice maximum rate limit per second governance can set for this contract
18:     uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;
19: 
20:     /// ------------- First Storage Slot -------------
21: 
22:     /// @notice the rate per second for this contract
23:     uint128 public rateLimitPerSecond;
24: 
25:     /// @notice the cap of the buffer that can be used at once
26:     uint128 public bufferCap;
27: 
28:     /// ------------- Second Storage Slot -------------
29: 
30:     /// @notice the last time the buffer was used by the contract
31:     uint32 public lastBufferUsedTime;
32: 
33:     /// @notice the buffer at the timestamp of lastBufferUsedTime
34:     uint224 public bufferStored;
35: 
36:     /// @notice RateLimitedV2 constructor
37:     /// @param _maxRateLimitPerSecond maximum rate limit per second that governance can set
38:     /// @param _rateLimitPerSecond starting rate limit per second
39:     /// @param _bufferCap cap on buffer size for this rate limited instance
40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) {
45:         lastBufferUsedTime = block.timestamp.safeCastTo32();
46: 
47:         _setBufferCap(_bufferCap);
48:         bufferStored = _bufferCap;
49: 
50:         require(
51:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
52:             "RateLimited: rateLimitPerSecond too high"
53:         );
54:         _setRateLimitPerSecond(_rateLimitPerSecond);
55: 
56:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
57:     }
58: 
59:     /// @notice set the rate limit per second
60:     /// @param newRateLimitPerSecond the new rate limit per second of the contract
61:     function setRateLimitPerSecond(
62:         uint128 newRateLimitPerSecond
63:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
64:         require(
65:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
66:             "RateLimited: rateLimitPerSecond too high"
67:         );
68:         _updateBufferStored(bufferCap);
69: 
70:         _setRateLimitPerSecond(newRateLimitPerSecond);
71:     }
72: 
73:     /// @notice set the buffer cap
74:     /// @param newBufferCap new buffer cap to set
75:     function setBufferCap(
76:         uint128 newBufferCap
77:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
78:         _setBufferCap(newBufferCap);
79:     }
80: 
81:     /// @notice the amount of action used before hitting limit
82:     /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
83:     function buffer() public view returns (uint256) {
84:         uint256 elapsed = block.timestamp.safeCastTo32() - lastBufferUsedTime;
85:         return
86:             Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);
87:     }
88: 
89:     /// @notice the method that enforces the rate limit.
90:     /// Decreases buffer by "amount".
91:     /// If buffer is <= amount, revert
92:     /// @param amount to decrease buffer by
93:     function _depleteBuffer(uint256 amount) internal {
94:         uint256 newBuffer = buffer();
95: 
96:         require(newBuffer != 0, "RateLimited: no rate limit buffer");
97:         require(amount <= newBuffer, "RateLimited: rate limit hit");
98: 
99:         uint32 blockTimestamp = block.timestamp.safeCastTo32();
100:         uint224 newBufferStored = (newBuffer - amount).safeCastTo224();
101: 
102:         /// gas optimization to only use a single SSTORE
103:         lastBufferUsedTime = blockTimestamp;
104:         bufferStored = newBufferStored;
105: 
106:         emit BufferUsed(amount, bufferStored);
107:     }
108: 
109:     /// @notice function to replenish buffer
110:     /// @param amount to increase buffer by if under buffer cap
111:     function _replenishBuffer(uint256 amount) internal {
112:         uint256 newBuffer = buffer();
113: 
114:         uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD
115: 
116:         /// cannot replenish any further if already at buffer cap
117:         if (newBuffer == _bufferCap) {
118:             /// save an SSTORE + some stack operations if buffer cannot be increased.
119:             /// last buffer used time doesn't need to be updated as buffer cannot
120:             /// increase past the buffer cap
121:             return;
122:         }
123: 
124:         uint32 blockTimestamp = block.timestamp.safeCastTo32();
125:         /// ensure that bufferStored cannot be gt buffer cap
126:         uint224 newBufferStored = Math
127:             .min(newBuffer + amount, _bufferCap)
128:             .safeCastTo224();
129: 
130:         /// gas optimization to only use a single SSTORE
131:         lastBufferUsedTime = blockTimestamp;
132:         bufferStored = newBufferStored;
133: 
134:         emit BufferReplenished(amount, bufferStored);
135:     }
136: 
137:     /// @param newRateLimitPerSecond the new rate limit per second of the contract
138:     function _setRateLimitPerSecond(uint128 newRateLimitPerSecond) internal {
139:         uint256 oldRateLimitPerSecond = rateLimitPerSecond;
140:         rateLimitPerSecond = newRateLimitPerSecond;
141: 
142:         emit RateLimitPerSecondUpdate(
143:             oldRateLimitPerSecond,
144:             newRateLimitPerSecond
145:         );
146:     }
147: 
148:     /// @param newBufferCap new buffer cap to set
149:     function _setBufferCap(uint128 newBufferCap) internal {
150:         _updateBufferStored(newBufferCap);
151: 
152:         uint256 oldBufferCap = bufferCap;
153:         bufferCap = newBufferCap;
154: 
155:         emit BufferCapUpdate(oldBufferCap, newBufferCap);
156:     }
157: 
158:     function _updateBufferStored(uint128 newBufferCap) internal {
159:         uint224 newBufferStored = buffer().safeCastTo224();
160:         uint32 newBlockTimestamp = block.timestamp.safeCastTo32();
161: 
162:         if (newBufferStored > newBufferCap) {
163:             bufferStored = uint224(newBufferCap); /// safe upcast as no precision can be lost when going from 128 -> 224
164:             lastBufferUsedTime = newBlockTimestamp;
165:         } else {
166:             bufferStored = newBufferStored;
167:             lastBufferUsedTime = newBlockTimestamp;
168:         }
169:     }
170: }
171: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
5: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
6: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
7: 
8: import {CoreRef} from "@src/core/CoreRef.sol";
9: import {CoreRoles} from "@src/core/CoreRoles.sol";
10: import {GuildToken} from "@src/tokens/GuildToken.sol";
11: import {CreditToken} from "@src/tokens/CreditToken.sol";
12: import {AuctionHouse} from "@src/loan/AuctionHouse.sol";
13: import {ProfitManager} from "@src/governance/ProfitManager.sol";
14: import {RateLimitedMinter} from "@src/rate-limits/RateLimitedMinter.sol";
15: 
16: /// @notice Lending Term contract of the Ethereum Credit Guild, a base implementation of
17: /// smart contract issuing CREDIT debt and escrowing collateral assets.
18: /// Note that interest rate is non-compounding and the percentage is expressed per
19: /// period of `YEAR` seconds.
20: contract LendingTerm is CoreRef {
21:     using SafeERC20 for IERC20;
22: 
23:     // events for the lifecycle of loans that happen in the lending term
24:     /// @notice emitted when new loans are opened (mint debt to borrower, pull collateral from borrower).
25:     event LoanOpen(
26:         uint256 indexed when,
27:         bytes32 indexed loanId,
28:         address indexed borrower,
29:         uint256 collateralAmount,
30:         uint256 borrowAmount
31:     );
32:     /// @notice emitted when a loan is called.
33:     event LoanCall(uint256 indexed when, bytes32 indexed loanId);
34:     /// @notice emitted when a loan is closed (repay, onBid after a call, forgive).
35:     enum LoanCloseType {
36:         Repay,
37:         Call,
38:         Forgive
39:     }
40:     event LoanClose(
41:         uint256 indexed when,
42:         bytes32 indexed loanId,
43:         LoanCloseType indexed closeType,
44:         uint256 debtRepaid
45:     );
46:     /// @notice emitted when someone adds collateral to a loan
47:     event LoanAddCollateral(
48:         uint256 indexed when,
49:         bytes32 indexed loanId,
50:         address indexed borrower,
51:         uint256 collateralAmount
52:     );
53:     /// @notice emitted when someone partially repays a loan
54:     event LoanPartialRepay(
55:         uint256 indexed when,
56:         bytes32 indexed loanId,
57:         address indexed repayer,
58:         uint256 repayAmount
59:     );
60: 
61:     struct Signature {
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
66: 
67:     /// @notice reference number of seconds in 1 year
68:     uint256 public constant YEAR = 31557600;
69: 
70:     /// @notice timestamp of last partial repayment for a given loanId.
71:     /// during borrow(), this is initialized to the borrow timestamp, if
72:     /// maxDelayBetweenPartialRepay is != 0
73:     mapping(bytes32 => uint256) public lastPartialRepay;
74: 
75:     struct Loan {
76:         address borrower; // address of a loan's borrower
77:         uint256 borrowTime; // the time the loan was initiated
78:         uint256 borrowAmount; // initial CREDIT debt of a loan
79:         uint256 borrowCreditMultiplier; // creditMultiplier when loan was opened
80:         uint256 collateralAmount; // balance of collateral token provided by the borrower
81:         address caller; // a caller of 0 indicates that the loan has not been called
82:         uint256 callTime; // a call time of 0 indicates that the loan has not been called
83:         uint256 callDebt; // the CREDIT debt when the loan was called
84:         uint256 closeTime; // the time the loan was closed (repaid or call+bid or forgive)
85:     }
86: 
87:     /// @notice the list of all loans that existed or are still active.
88:     /// @dev see public getLoan(loanId) getter.
89:     mapping(bytes32 => Loan) internal loans;
90: 
91:     /// @notice current number of CREDIT issued in active loans on this term
92:     /// @dev this can be lower than the sum of all loan's CREDIT debts because
93:     /// interests accrue and some loans might have been opened before the creditMultiplier
94:     /// was last updated, resulting in higher CREDIT debt than what was originally borrowed.
95:     uint256 public issuance;
96: 
97:     struct LendingTermReferences {
98:         /// @notice reference to the ProfitManager
99:         address profitManager;
100:         /// @notice reference to the GUILD token
101:         address guildToken;
102:         /// @notice reference to the auction house contract used to
103:         /// sell loan collateral for CREDIT if loans are called.
104:         address auctionHouse;
105:         /// @notice reference to the credit minter contract
106:         address creditMinter;
107:         /// @notice reference to the CREDIT token
108:         address creditToken;
109:     }
110: 
111:     /// @notice References to other protocol contracts (see struct for more details)
112:     LendingTermReferences internal refs;
113: 
114:     struct LendingTermParams {
115:         /// @notice reference to the collateral token
116:         address collateralToken;
117:         /// @notice max number of debt tokens issued per collateral token.
118:         /// @dev be mindful of the decimals here, because if collateral
119:         /// token doesn't have 18 decimals, this variable is used to scale
120:         /// the decimals.
121:         /// For example, for USDC collateral, this variable should be around
122:         /// ~1e30, to allow 1e6 * 1e30 / 1e18 ~= 1e18 CREDIT to be borrowed for
123:         /// each 1e6 units (1 USDC) of collateral, if CREDIT is targeted to be
124:         /// worth around 1 USDC.
125:         uint256 maxDebtPerCollateralToken;
126:         /// @notice interest rate paid by the borrower, expressed as an APR
127:         /// with 18 decimals (0.01e18 = 1% APR). The base for 1 year is the YEAR constant.
128:         uint256 interestRate;
129:         /// @notice maximum delay, in seconds, between partial debt repayments.
130:         /// if set to 0, no periodic partial repayments are expected.
131:         /// if a partial repayment is missed (delay has passed), the loan
132:         /// can be called.
133:         uint256 maxDelayBetweenPartialRepay;
134:         /// @notice minimum percent of the total debt (principal + interests) to
135:         /// repay during partial debt repayments.
136:         /// percentage is expressed with 18 decimals, e.g. 0.05e18 = 5% debt.
137:         uint256 minPartialRepayPercent;
138:         /// @notice the opening fee is a percent of interest that instantly accrues
139:         /// when the loan is opened.
140:         /// The opening fee is expressed as a percentage of the borrowAmount, with 18
141:         /// decimals, e.g. 0.05e18 = 5% of the borrowed amount.
142:         /// A loan with 2% openingFee and 3% interestRate will owe 102% of the borrowed
143:         /// amount just after being open, and after 1 year will owe 105%.
144:         uint256 openingFee;
145:         /// @notice the absolute maximum amount of debt this lending term can issue
146:         /// at any given time, regardless of the gauge allocations.
147:         uint256 hardCap;
148:     }
149: 
150:     /// @notice Params of the LendingTerm (see struct for more details)
151:     LendingTermParams internal params;
152: 
153:     constructor() CoreRef(address(1)) {
154:         // core is set to address(1) to prevent implementation from being initialized,
155:         // only proxies on the implementation can be initialized.
156:     }
157: 
158:     /// @notice initialize storage with references to other protocol contracts
159:     /// and the lending term parameters for this instance.
160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         // can initialize only once
166:         assert(address(core()) == address(0));
167:         assert(_core != address(0));
168: 
169:         // initialize storage
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
174: 
175:     /// @notice get references of this term to other protocol contracts
176:     function getReferences()
177:         external
178:         view
179:         returns (LendingTermReferences memory)
180:     {
181:         return refs;
182:     }
183: 
184:     /// @notice get parameters of this term
185:     function getParameters() external view returns (LendingTermParams memory) {
186:         return params;
187:     }
188: 
189:     /// @notice get parameter 'collateralToken' of this term
190:     function collateralToken() external view returns (address) {
191:         return params.collateralToken;
192:     }
193: 
194:     /// @notice get a loan
195:     function getLoan(bytes32 loanId) external view returns (Loan memory) {
196:         return loans[loanId];
197:     }
198: 
199:     /// @notice outstanding borrowed amount of a loan, including interests
200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) {
201:         Loan storage loan = loans[loanId];
202:         uint256 borrowTime = loan.borrowTime;
203: 
204:         if (borrowTime == 0) {
205:             return 0;
206:         }
207: 
208:         if (loan.closeTime != 0) {
209:             return 0;
210:         }
211: 
212:         if (loan.callTime != 0) {
213:             return loan.callDebt;
214:         }
215: 
216:         // compute interest owed
217:         uint256 borrowAmount = loan.borrowAmount;
218:         uint256 interest = (borrowAmount *
219:             params.interestRate *
220:             (block.timestamp - borrowTime)) /
221:             YEAR /
222:             1e18;
223:         uint256 loanDebt = borrowAmount + interest;
224:         uint256 _openingFee = params.openingFee;
225:         if (_openingFee != 0) {
226:             loanDebt += (borrowAmount * _openingFee) / 1e18;
227:         }
228:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
229:             .creditMultiplier();
230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;
231: 
232:         return loanDebt;
233:     }
234: 
235:     /// @notice returns true if the term has a maximum delay between partial repays
236:     /// and the loan has passed the delay for partial repayments.
237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) {
240:         // if no periodic partial repays are expected, always return false
241:         if (params.maxDelayBetweenPartialRepay == 0) return false;
242: 
243:         // if loan doesn't exist, return false
244:         if (loans[loanId].borrowTime == 0) return false;
245: 
246:         // if loan is closed, return false
247:         if (loans[loanId].closeTime != 0) return false;
248: 
249:         // return true if delay is passed
250:         return
251:             lastPartialRepay[loanId] <
252:             block.timestamp - params.maxDelayBetweenPartialRepay;
253:     }
254: 
255:     /// @notice returns the maximum amount of debt that can be issued by this term
256:     /// according to the current gauge allocations.
257:     /// Note that the debt ceiling can be lower than the current issuance under 4 conditions :
258:     /// - params.hardCap is lower than since last borrow happened
259:     /// - gauge votes are fewer than when last borrow happened
260:     /// - profitManager.totalBorrowedCredit() decreased since last borrow
261:     /// - creditMinter.buffer() is close to being depleted
262:     /// @dev this solves the following equation :
263:     /// borrowAmount + issuance <=
264:     /// (totalBorrowedCredit + borrowAmount) * gaugeWeight * gaugeWeightTolerance / totalWeight / 1e18
265:     /// which is the formula to check debt ceiling in the borrow function.
266:     /// This gives the maximum borrowable amount to achieve 100% utilization of the debt
267:     /// ceiling, and if we add the current issuance to it, we get the current debt ceiling.
268:     /// @param gaugeWeightDelta an hypothetical change in gauge weight
269:     /// @return the maximum amount of debt that can be issued by this term
270:     function debtCeiling(
271:         int256 gaugeWeightDelta
272:     ) public view returns (uint256) {
273:         address _guildToken = refs.guildToken; // cached SLOAD
274:         uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(
275:             address(this)
276:         );
277:         gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);
278:         uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this));
279:         uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(
280:             gaugeType
281:         );
282:         uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)
283:             .buffer();
284:         uint256 _hardCap = params.hardCap; // cached SLOAD
285:         if (gaugeWeight == 0) {
286:             return 0; // no gauge vote, 0 debt ceiling
287:         } else if (gaugeWeight == totalWeight) {
288:             // one gauge, unlimited debt ceiling
289:             // returns min(hardCap, creditMinterBuffer)
290:             return
291:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
292:         }
293:         uint256 _issuance = issuance; // cached SLOAD
294:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
295:             .totalBorrowedCredit();
296:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
297:             .gaugeWeightTolerance();
298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) {
299:             // first-ever CREDIT mint on a non-zero gauge weight term
300:             // does not check the relative debt ceilings
301:             // returns min(hardCap, creditMinterBuffer)
302:             return
303:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
304:         }
305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /
306:             1e18;
307:         uint256 debtCeilingBefore = (totalBorrowedCredit *
308:             toleratedGaugeWeight) / totalWeight;
309:         if (_issuance >= debtCeilingBefore) {
310:             return debtCeilingBefore; // no more borrows allowed
311:         }
312:         uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; // always >0
313:         if (toleratedGaugeWeight >= totalWeight) {
314:             // if the gauge weight is above 100% when we include tolerance,
315:             // the gauge relative debt ceilings are not constraining.
316:             return
317:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
318:         }
319:         uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; // always >0
320:         uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /
321:             otherGaugesWeight;
322:         uint256 _debtCeiling = _issuance + maxBorrow;
323:         // return min(creditMinterBuffer, hardCap, debtCeiling)
324:         if (creditMinterBuffer < _debtCeiling) {
325:             return creditMinterBuffer;
326:         }
327:         if (_hardCap < _debtCeiling) {
328:             return _hardCap;
329:         }
330:         return _debtCeiling;
331:     }
332: 
333:     /// @notice returns the debt ceiling without change to gauge weight
334:     function debtCeiling() external view returns (uint256) {
335:         return debtCeiling(0);
336:     }
337: 
338:     /// @notice initiate a new loan
339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         // check that the loan doesn't already exist
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         // check that enough collateral is provided
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         // check that enough CREDIT is borrowed
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         // check the hardcap
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         // check the debt ceiling
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             // if the lending term is deprecated, `calculateGaugeAllocation` will return 0, and the borrow
390:             // should revert because the debt ceiling is reached (no borrows should be allowed anymore).
391:             // first borrow in the system does not check proportions of issuance, just that the term is not deprecated.
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         // save loan in state
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         // mint debt to the borrower
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         // pull the collateral from the borrower
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         // emit event
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
436: 
437:     /// @notice initiate a new loan
438:     function borrow(
439:         uint256 borrowAmount,
440:         uint256 collateralAmount
441:     ) external whenNotPaused returns (bytes32 loanId) {
442:         loanId = _borrow(msg.sender, borrowAmount, collateralAmount);
443:     }
444: 
445:     /// @notice add collateral on an open loan.
446:     /// a borrower might want to add collateral so that his position does not go underwater due to
447:     /// interests growing up over time.
448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal {
453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0");
454: 
455:         Loan storage loan = loans[loanId];
456: 
457:         // check the loan is open
458:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
459:         require(loan.closeTime == 0, "LendingTerm: loan closed");
460:         require(loan.callTime == 0, "LendingTerm: loan called");
461: 
462:         // update loan in state
463:         loans[loanId].collateralAmount += collateralToAdd;
464: 
465:         // pull the collateral from the borrower
466:         IERC20(params.collateralToken).safeTransferFrom(
467:             borrower,
468:             address(this),
469:             collateralToAdd
470:         );
471: 
472:         // emit event
473:         emit LoanAddCollateral(
474:             block.timestamp,
475:             loanId,
476:             borrower,
477:             collateralToAdd
478:         );
479:     }
480: 
481:     /// @notice add collateral on an open loan.
482:     function addCollateral(bytes32 loanId, uint256 collateralToAdd) external {
483:         _addCollateral(msg.sender, loanId, collateralToAdd);
484:     }
485: 
486:     /// @notice partially repay an open loan.
487:     /// a borrower might want to partially repay debt so that his position does not go underwater
488:     /// due to interests building up.
489:     /// some lending terms might also impose periodic partial repayments.
490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         // check the loan is open
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         // compute partial repayment
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; // [0, 1e18[
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         // update loan in state
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         // pull the debt from the borrower
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         // forward profit portion to the ProfitManager, burn the rest
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         // emit event
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
560: 
561:     /// @notice partially repay an open loan.
562:     function partialRepay(bytes32 loanId, uint256 debtToRepay) external {
563:         _partialRepay(msg.sender, loanId, debtToRepay);
564:     }
565: 
566:     /// @notice repay an open loan
567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         // check the loan is open
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         // compute interest owed
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         /// pull debt from the borrower and replenish the buffer of available debt that can be minted.
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             // forward profit portion to the ProfitManager
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             // report profit
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         // burn loan principal
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         // close the loan
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         // return the collateral to the borrower
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         // emit event
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
626: 
627:     /// @notice repay an open loan
628:     function repay(bytes32 loanId) external {
629:         _repay(msg.sender, loanId);
630:     }
631: 
632:     /// @notice call a loan, the collateral will be auctioned to repay outstanding debt.
633:     /// Loans can be called only if the term has been offboarded or if a loan missed a periodic partialRepay.
634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal {
639:         Loan storage loan = loans[loanId];
640: 
641:         // check that the loan exists
642:         uint256 borrowTime = loan.borrowTime;
643:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
644: 
645:         // check that the loan is not already closed
646:         require(loan.closeTime == 0, "LendingTerm: loan closed");
647: 
648:         // check that the loan is not already called
649:         require(loan.callTime == 0, "LendingTerm: loan called");
650: 
651:         // check that the loan can be called
652:         require(
653:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||
654:                 partialRepayDelayPassed(loanId),
655:             "LendingTerm: cannot call"
656:         );
657: 
658:         // check that the loan has been running for at least 1 block
659:         require(
660:             borrowTime < block.timestamp,
661:             "LendingTerm: loan opened in same block"
662:         );
663: 
664:         // update loan in state
665:         uint256 loanDebt = getLoanDebt(loanId);
666:         loans[loanId].callTime = block.timestamp;
667:         loans[loanId].callDebt = loanDebt;
668:         loans[loanId].caller = caller;
669: 
670:         // auction the loan collateral
671:         AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);
672: 
673:         // emit event
674:         emit LoanCall(block.timestamp, loanId);
675:     }
676: 
677:     /// @notice call a single loan
678:     function call(bytes32 loanId) external {
679:         _call(msg.sender, loanId, refs.auctionHouse);
680:     }
681: 
682:     /// @notice call a list of loans
683:     function callMany(bytes32[] memory loanIds) public {
684:         address _auctionHouse = refs.auctionHouse;
685:         for (uint256 i = 0; i < loanIds.length; i++) {
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
688:     }
689: 
690:     /// @notice forgive a loan, marking its debt as a total loss to the system.
691:     /// The loan is closed (borrower keeps the CREDIT), and the collateral stays on the LendingTerm.
692:     /// Governance can later unstuck the collateral through `emergencyAction`.
693:     /// This function is made for emergencies where collateral is frozen or other reverting
694:     /// conditions on collateral transfers that prevent regular repay() or call() loan closing.
695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {
696:         Loan storage loan = loans[loanId];
697: 
698:         // check that the loan exists
699:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
700: 
701:         // check that the loan is not already closed
702:         require(loan.closeTime == 0, "LendingTerm: loan closed");
703: 
704:         // close the loan
705:         loans[loanId].closeTime = block.timestamp;
706:         issuance -= loan.borrowAmount;
707: 
708:         // mark loan as a total loss
709:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
710:             .creditMultiplier();
711:         uint256 borrowAmount = loans[loanId].borrowAmount;
712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
714:         int256 pnl = -int256(principal);
715:         ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
716: 
717:         // set hardcap to 0 to prevent new borrows
718:         params.hardCap = 0;
719: 
720:         // emit event
721:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);
722:     }
723: 
724:     /// @notice callback from the auctionHouse when au auction concludes
725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         // preliminary checks
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         // sanity check on collateral movement
741:         // these should never fail for a properly implemented AuctionHouse contract
742:         // collateralOut == 0 if forgive() while in auctionHouse
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         // compute pnl
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         // save loan state
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         // pull credit from bidder
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         // burn credit principal, replenish buffer
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         // handle profit & losses
789:         if (pnl != 0) {
790:             // forward profit, if any
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         // decrease issuance
801:         issuance -= borrowAmount;
802: 
803:         // send collateral to borrower
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         // send collateral to bidder
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
826: 
827:     /// @notice set the address of the auction house.
828:     /// governor-only, to allow full governance to update the auction mechanisms.
829:     function setAuctionHouse(
830:         address _newValue
831:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
832:         // allow configuration changes only when there are no auctions in progress.
833:         // updating the auction house while auctions are in progress could break the loan
834:         // lifecycle, as it would prevent the former auctionHouse (that have active auctions)
835:         // from reporting the result to the lending term.
836:         require(
837:             AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,
838:             "LendingTerm: auctions in progress"
839:         );
840: 
841:         refs.auctionHouse = _newValue;
842:     }
843: 
844:     /// @notice set the hardcap of CREDIT mintable in this term.
845:     /// allows to update a term's arbitrary hardcap without doing a gauge & loans migration.
846:     function setHardCap(
847:         uint256 _newValue
848:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
849:         params.hardCap = _newValue;
850:     }
851: }
852: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L1-L1)

```1: // SPDX-License-Identifier: GPL-3.0-or-later
2: pragma solidity 0.8.13;
3: 
4: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol";
5: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
6: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
7: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
8: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol";
9: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";
10: import {CoreRef} from "@src/core/CoreRef.sol";
11: import {CoreRoles} from "@src/core/CoreRoles.sol";
12: 
13: /// @title Governor for on-chain governance of Ethereum Credit Guild, based on the OZ implementation.
14: /// This governor is specifically designed for adding veto capabilities :
15: /// Token holders cannot propose() arbitrary actions, they have to create the proposals
16: /// through the createVeto() function, and this governor will only be able to execute the
17: /// action of cancelling an action in the linked TimelockController if the veto vote passes.
18: /// Token holders can only vote against an action that is queued in the linked TimelockController.
19: /// When enough against votes (above veto quorum) are cast, the veto vote is considered successful,
20: /// and this governor can early-execute the proposal of cancelling the action in the linked
21: /// TimelockController, without having to wait the end of a voting period.
22: /// After the action has been queued in the linked TimelockController for enough time to be
23: /// executed, the veto vote is considered failed and the action cannot be cancelled anymore.
24: /// @author eswak
25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes {
26:     /// @notice Private storage variable for quorum (the minimum number of votes needed for a vote to pass).
27:     uint256 private _quorum;
28: 
29:     /// @notice Emitted when quorum is updated.
30:     event QuorumUpdated(uint256 oldQuorum, uint256 newQuorum);
31: 
32:     constructor(
33:         address _core,
34:         address initialTimelock,
35:         address _token,
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     {
42:         _setQuorum(initialQuorum);
43:         _updateTimelock(initialTimelock);
44:     }
45: 
46:     /// ------------------------------------------------------------------------
47:     /// Quorum Management
48:     /// ------------------------------------------------------------------------
49: 
50:     /**
51:      * @dev Public accessor to check the minimum number of votes needed for a vote to pass.
52:      */
53:     function quorum(
54:         uint256 /* blockNumber*/
55:     ) public view override returns (uint256) {
56:         return _quorum;
57:     }
58: 
59:     /// @notice Adjust quorum, restricted to Core GOVERNOR role.
60:     function setQuorum(
61:         uint256 newQuorum
62:     ) public onlyCoreRole(CoreRoles.GOVERNOR) {
63:         _setQuorum(newQuorum);
64:     }
65: 
66:     /**
67:      * @dev Internal setter for the proposal quorum.
68:      *
69:      * Emits a {QuorumUpdated} event.
70:      */
71:     function _setQuorum(uint256 newQuorum) internal virtual {
72:         emit QuorumUpdated(_quorum, newQuorum);
73:         _quorum = newQuorum;
74:     }
75: 
76:     /// ------------------------------------------------------------------------
77:     /// Timelock Management
78:     /// ------------------------------------------------------------------------
79: 
80:     /**
81:      * @dev Emitted when the timelock controller used for proposal execution is modified.
82:      */
83:     event TimelockChange(address oldTimelock, address newTimelock);
84: 
85:     /// @notice the timelock linked to this veto governor
86:     address public timelock;
87: 
88:     /// @notice mapping of proposalId (in this Governor) to timelockId (action ID in
89:     /// the timelock linked to this governor).
90:     mapping(uint256 => bytes32) private _timelockIds;
91: 
92:     /// @notice Set the timelock this veto governor can cancel from.
93:     function updateTimelock(
94:         address newTimelock
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
96:         _updateTimelock(newTimelock);
97:     }
98: 
99:     function _updateTimelock(address newTimelock) private {
100:         emit TimelockChange(timelock, newTimelock);
101:         timelock = newTimelock;
102:     }
103: 
104:     /// ------------------------------------------------------------------------
105:     /// Vote counting
106:     /// ------------------------------------------------------------------------
107: 
108:     /**
109:      * @dev Supported vote types. Matches Governor Bravo ordering.
110:      */
111:     enum VoteType {
112:         Against,
113:         For,
114:         Abstain
115:     }
116: 
117:     struct ProposalVote {
118:         uint256 againstVotes;
119:         uint256 forVotes;
120:         uint256 abstainVotes;
121:         mapping(address => bool) hasVoted;
122:     }
123: 
124:     mapping(uint256 => ProposalVote) private _proposalVotes;
125: 
126:     /**
127:      * @dev See {IGovernor-COUNTING_MODE}.
128:      */
129:     // solhint-disable-next-line func-name-mixedcase
130:     function COUNTING_MODE()
131:         public
132:         pure
133:         virtual
134:         override
135:         returns (string memory)
136:     {
137:         return "support=bravo&quorum=against";
138:     }
139: 
140:     /**
141:      * @dev See {IGovernor-hasVoted}.
142:      */
143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool) {
147:         return _proposalVotes[proposalId].hasVoted[account];
148:     }
149: 
150:     /**
151:      * @dev Accessor to the internal vote counts.
152:      */
153:     function proposalVotes(
154:         uint256 proposalId
155:     )
156:         public
157:         view
158:         virtual
159:         returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)
160:     {
161:         // againstVotes are supporting the execution of Veto
162:         againstVotes = _proposalVotes[proposalId].againstVotes;
163:         // no forVotes can be cast in the Veto module, keep 0 value
164:         forVotes = 0;
165:         // no abstainVotes can be cast in the Veto module, keep 0 value
166:         abstainVotes = 0;
167:     }
168: 
169:     /**
170:      * @dev See {Governor-_quorumReached}.
171:      */
172:     function _quorumReached(
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool) {
175:         ProposalVote storage proposalvote = _proposalVotes[proposalId];
176: 
177:         return
178:             quorum(proposalSnapshot(proposalId)) <= proposalvote.againstVotes;
179:     }
180: 
181:     /**
182:      * @dev Veto votes are always considered "successful" in this part of the logic, as there is no opposition
183:      * between 'for' and 'against' votes, since people cannot vote 'for'. For a veto to be considered successful,
184:      * it only needs to reach quorum.
185:      */
186:     function _voteSucceeded(
187:         uint256 /* proposalId*/
188:     ) internal pure virtual override returns (bool) {
189:         return true;
190:     }
191: 
192:     /**
193:      * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).
194:      */
195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory // params
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId];
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true;
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
216: 
217:     /// ------------------------------------------------------------------------
218:     /// Public functions override
219:     /// ------------------------------------------------------------------------
220: 
221:     /// @dev no voting delay between veto proposal and veto voting period.
222:     function votingDelay() public pure override returns (uint256) {
223:         return 0;
224:     }
225: 
226:     /// @dev voting period is unused, it is a duration in blocks for the vote
227:     /// but the timestamp of the action in the timelock is used to know if the
228:     /// vote period is over (after action is ready in the timelock, the veto
229:     /// vote failed).
230:     function votingPeriod() public pure override returns (uint256) {
231:         return 2425847; // ~1 year with 1 block every 13s
232:     }
233: 
234:     /// @notice State of a given proposal
235:     /// The state can be one of:
236:     /// - ProposalState.Pending   (0) Lasts only during the block where the veto proposal has been created.
237:     /// - ProposalState.Active    (1) If action is pending in the timelock and veto quorum has not been reached yet.
238:     /// - ProposalState.Canceled  (2) If a veto was created but the timelock action has been cancelled through another
239:     ///   mean before the veto vote succeeded. The internal _cancel() function is not reachable by another mean (no
240:     ///   public cancel() function), so this is the only case where a proposal will have Canceled status.
241:     /// - ProposalState.Defeated  (3) If proposal already executed or is ready to execute in the timelock.
242:     /// - ProposalState.Succeeded (4) If action is pending in the timelock and veto quorum has been reached. Veto can be executed instantly.
243:     /// - ProposalState.Executed  (7) If a veto successfully executed.
244:     /// note that veto proposals have a quorum that works with 'against' votes, and that only 'against' votes can be
245:     /// cast in this veto governor.
246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) {
249:         ProposalState status = super.state(proposalId);
250:         bytes32 queueid = _timelockIds[proposalId];
251: 
252:         // @dev all proposals that are in this Governor's state should have been created
253:         // by the createVeto() method, and therefore should have _timelockIds set, so this
254:         // condition check is an invalid state that should never be reached.
255:         assert(queueid != bytes32(0));
256: 
257:         // Proposal already executed and stored in state
258:         if (status == ProposalState.Executed) {
259:             return ProposalState.Executed;
260:         }
261:         // Proposal cannot be Canceled because there is no public cancel() function.
262:         // Vote has just been created, still in waiting period
263:         if (status == ProposalState.Pending) {
264:             return ProposalState.Pending;
265:         }
266: 
267:         // at this stage, status from super can be one of: Active, Succeeded, Defeated
268:         // Read timestamp in the timelock to determine the state of the proposal
269:         uint256 timelockOperationTimestamp = TimelockController(
270:             payable(timelock)
271:         ).getTimestamp(queueid);
272: 
273:         // proposal already cleared from the timelock by something else
274:         if (timelockOperationTimestamp == 0) {
275:             return ProposalState.Canceled;
276:         }
277:         // proposal already executed in the timelock
278:         if (timelockOperationTimestamp == 1) {
279:             return ProposalState.Defeated;
280:         }
281: 
282:         // proposal still in waiting period in the timelock
283:         if (timelockOperationTimestamp > block.timestamp) {
284:             // ready to veto
285:             // no need for "&& _voteSucceeded(proposalId)" in condition because
286:             // veto votes are always succeeded (there is no tallying for 'for'
287:             // votes against 'against' votes), the only condition is the quorum.
288:             if (_quorumReached(proposalId)) {
289:                 return ProposalState.Succeeded;
290:             }
291:             // need more votes to veto
292:             else {
293:                 return ProposalState.Active;
294:             }
295:         }
296:         // proposal is ready to execute in the timelock, the veto
297:         // vote did not reach quorum in time.
298:         else {
299:             return ProposalState.Defeated;
300:         }
301:     }
302: 
303:     /// @dev override to prevent arbitrary calls to be proposed
304:     function propose(
305:         address[] memory /* targets*/,
306:         uint256[] memory /* values*/,
307:         bytes[] memory /* calldatas*/,
308:         string memory /* description*/
309:     ) public pure override returns (uint256) {
310:         revert("GuildVetoGovernor: cannot propose arbitrary actions");
311:     }
312: 
313:     /// @notice Propose a governance action to veto (cancel) a target action ID in the
314:     /// governor's linked timelock.
315:     function createVeto(bytes32 timelockId) external returns (uint256) {
316:         // Check that the operation is pending in the timelock
317:         uint256 timelockExecutionTime = TimelockController(payable(timelock))
318:             .getTimestamp(timelockId);
319:         require(
320:             timelockExecutionTime > 1,
321:             "GuildVetoGovernor: action must be pending"
322:         );
323: 
324:         // Build proposal data
325:         (
326:             address[] memory targets,
327:             uint256[] memory values,
328:             bytes[] memory calldatas,
329:             string memory description
330:         ) = _getVetoCalls(timelockId);
331: 
332:         uint256 proposalId = super.propose(
333:             targets,
334:             values,
335:             calldatas,
336:             description
337:         );
338: 
339:         // Save mapping between proposalId and timelockId
340:         _timelockIds[proposalId] = timelockId;
341: 
342:         return proposalId;
343:     }
344: 
345:     /// @notice Execute a governance action to veto (cancel) a target action ID in the
346:     /// governor's linked timelock.
347:     /// @dev the standard execute() function can also be used for this, and the function
348:     /// is only added for convenience.
349:     function executeVeto(bytes32 timelockId) external returns (uint256) {
350:         // Build proposal data
351:         (
352:             address[] memory targets,
353:             uint256[] memory values,
354:             bytes[] memory calldatas,
355:             string memory description
356:         ) = _getVetoCalls(timelockId);
357:         // Execute
358:         return
359:             super.execute(
360:                 targets,
361:                 values,
362:                 calldatas,
363:                 keccak256(bytes(description))
364:             );
365:     }
366: 
367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); // 0 eth
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId))
390:         );
391:     }
392: }
393: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L1-L1)

```1: // SPDX-License-Identifier: MIT
2: pragma solidity 0.8.13;
3: 
4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
5: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
6: 
7: import {CoreRef} from "@src/core/CoreRef.sol";
8: import {CoreRoles} from "@src/core/CoreRoles.sol";
9: import {LendingTerm} from "@src/loan/LendingTerm.sol";
10: import {CreditToken} from "@src/tokens/CreditToken.sol";
11: import {ProfitManager} from "@src/governance/ProfitManager.sol";
12: import {RateLimitedMinter} from "@src/rate-limits/RateLimitedMinter.sol";
13: 
14: /// @notice Simple PSM contract of the Ethereum Credit Guild, that allows mint/redeem
15: /// of CREDIT token outside of lending terms & guarantee a stable peg of the CREDIT token
16: /// around the value targeted by the protocol.
17: /// The SimplePSM targets a value equal to ProfitManager.creditMultiplier(), so when bad
18: /// debt is created and all loans are marked up, they stay the same in terms of peg token,
19: /// because new CREDIT can be minted with fewer peg tokens from the PSM. Conversely, when
20: /// new loans are issued, if there are funds available in the SimplePSM, borrowers know
21: /// the amount of peg tokens they'll be able to redeem their borrowed CREDIT for.
22: /// @dev inspired by the SimpleFeiDaiPSM used in the TribeDAO shutdown, see:
23: /// - https://github.com/code-423n4/2022-09-tribe/blob/main/contracts/peg/SimpleFeiDaiPSM.sol
24: /// - https://code4rena.com/reports/2022-09-tribe
25: contract SimplePSM is CoreRef {
26:     using SafeERC20 for ERC20;
27: 
28:     /// @notice reference to the ProfitManager contract
29:     address public immutable profitManager;
30: 
31:     /// @notice reference to the CreditToken contract
32:     address public immutable credit;
33: 
34:     /// @notice reference to the peg token contract
35:     address public immutable pegToken;
36: 
37:     /// @notice peg token balance, used to track sum of i/o and exclude donations.
38:     /// invariant: pegToken.balanceOf(this) >= pegTokenBalance
39:     uint256 public pegTokenBalance;
40: 
41:     /// @notice multiplier for decimals correction, e.g. 1e12 for a pegToken
42:     /// with 6 decimals (because CREDIT has 18 decimals)
43:     uint256 public immutable decimalCorrection;
44: 
45:     /// @notice true if the redemptions are currently paused
46:     bool public redemptionsPaused;
47: 
48:     /// @notice event emitted upon a redemption
49:     event Redeem(
50:         uint256 indexed when,
51:         address indexed to,
52:         uint256 amountIn,
53:         uint256 amountOut
54:     );
55:     /// @notice event emitted when credit gets minted
56:     event Mint(
57:         uint256 indexed when,
58:         address indexed to,
59:         uint256 amountIn,
60:         uint256 amountOut
61:     );
62:     /// @notice event emitted when redemption pausability status changes
63:     event RedemptionsPaused(uint256 indexed when, bool status);
64: 
65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager;
72:         credit = _credit;
73:         pegToken = _pegToken;
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
78: 
79:     /// @notice calculate the amount of CREDIT out for a given `amountIn` of underlying
80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) {
81:         uint256 creditMultiplier = ProfitManager(profitManager)
82:             .creditMultiplier();
83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier;
84:     }
85: 
86:     /// @notice calculate the amount of underlying out for a given `amountIn` of CREDIT
87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) {
90:         uint256 creditMultiplier = ProfitManager(profitManager)
91:             .creditMultiplier();
92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection;
93:     }
94: 
95:     /// @notice calculate the total number of CREDIT that can be redeemed
96:     /// at the moment, based on the pegTokenBalance.
97:     function redeemableCredit() public view returns (uint256) {
98:         return getMintAmountOut(pegTokenBalance);
99:     }
100: 
101:     /// @notice mint `amountOut` CREDIT to address `to` for `amountIn` underlying tokens
102:     /// @dev see getMintAmountOut() to pre-calculate amount out
103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
113: 
114:     /// @notice mint `amountOut` CREDIT to `msg.sender` for `amountIn` underlying tokens
115:     /// and enter rebase to earn the savings rate.
116:     /// @dev see getMintAmountOut() to pre-calculate amount out
117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn;
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
131: 
132:     /// @notice redeem `amountIn` CREDIT for `amountOut` underlying tokens and send to address `to`
133:     /// @dev see getRedeemAmountOut() to pre-calculate amount out
134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut);
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
145: 
146:     /// @notice set `redemptionsPaused`
147:     /// governor-only, to allow full governance to update the psm mechanisms,
148:     /// or automated processes to pause redemptions under certain conditions.
149:     function setRedemptionsPaused(
150:         bool paused
151:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
152:         redemptionsPaused = paused;
153:         emit RedemptionsPaused(block.timestamp, paused);
154:     }
155: }
156: 
```

*GitHub* : [1](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L1-L1)
### [NC-64]<a name="nc-64"></a> Top level declarations should be separated by two blank lines

*There are 10 instance(s) of this issue:*

```361:     } // <= FOUND
362: 
363:     function _writeCheckpoint( // <= FOUND
```

*GitHub* : [361](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L361-L363)

```385:     } // <= FOUND
386: 
387:     function _add(uint256 a, uint256 b) private pure returns (uint256) { // <= FOUND
```

*GitHub* : [385](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L385-L387)

```406:     } // <= FOUND
407: 
408:     function transfer( // <= FOUND
```

*GitHub* : [406](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L406-L408)

```88:     } // <= FOUND
89: 
90:     function _burn( // <= FOUND
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L88-L90)

```130:     } // <= FOUND
131: 
132:     function _execute( // <= FOUND
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L130-L132)

```169:     } // <= FOUND
170: 
171:     function supportsInterface( // <= FOUND
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L169-L171)

```247:     } // <= FOUND
248: 
249:     function _incrementUserAndGlobalWeights( // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L247-L249)

```414:     } // <= FOUND
415: 
416:     function transferFrom( // <= FOUND
```

*GitHub* : [414](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L414-L416)

```309:     } // <= FOUND
310: 
311:     function _exitRebase(address account) internal { // <= FOUND
```

*GitHub* : [309](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L309-L311)

```97:     } // <= FOUND
98: 
99:     function _updateTimelock(address newTimelock) private { // <= FOUND
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L97-L99)
### [NC-65]<a name="nc-65"></a> Contracts should have full test coverage
Attaining 100% code coverage is not an assurance of a bug-free codebase, but it significantly improves the likelihood of identifying simple bugs and aids in maintaining a stable codebase by preventing regressions during code modifications. Additionally, to achieve complete coverage, code writers usually have to structure their code more modularly, which implies testing each component independently. This reduces the complex interdependencies between modules and layers, creating a more understandable and auditable codebase. Consequently, this practice aids in enhancing code maintainability and reduces the risk of introducing bugs during future changes.

*There are 14 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is // <= FOUND
17:     CoreRef, // <= FOUND
18:     Governor, // <= FOUND
19:     GovernorVotes, // <= FOUND
20:     GovernorTimelockControl, // <= FOUND
21:     GovernorSettings, // <= FOUND
22:     GovernorCountingSimple // <= FOUND
23:  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L23)

```14: contract GuildTimelockController is TimelockController, CoreRef  // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```16: contract LendingTermOffboarding is CoreRef  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor  // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is // <= FOUND
19:     CoreRef, // <= FOUND
20:     ERC20Burnable, // <= FOUND
21:     ERC20MultiVotes, // <= FOUND
22:     ERC20RebaseDistributor // <= FOUND
23:  // <= FOUND
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L23)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef  // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef  // <= FOUND
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2  // <= FOUND
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-66]<a name="nc-66"></a> Consider using SafeTransferLib.safeTransferETH() or Address.sendValue() for clearer semantic meaning
For improved code readability and better semantic understanding, it's recommended to use OpenZeppelin's SafeTransferLib.safeTransferETH() or Address.sendValue(). These functions explicitly describe their operation with their naming convention, increasing the comprehensibility of the code. Their usage over lower-level calls enhances the maintainability of your smart contract code by clearly indicating the purpose of the function.

*There are 1 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L87)
### [NC-67]<a name="nc-67"></a> Whitespace in expressions
Avoid unnecessary whitespace in contract lines such as ' ;' and ', )'

*There are 1 instance(s) of this issue:*

```116:         
117:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards( // <= FOUND
118:             msg.sender,
119:             term
120:         );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L117-L117)
### [NC-68]<a name="nc-68"></a> Consider using named function calls
Named function calls in Solidity greatly improve code readability by explicitly mapping arguments to their respective parameter names. This clarity becomes critical when dealing with functions that have numerous or complex parameters, reducing potential errors due to misordered arguments. Therefore, adopting named function calls contributes to more maintainable and less error-prone code.

*There are 43 instance(s) of this issue:*

```116:         return _cancel(targets, values, calldatas, descriptionHash); // <= FOUND
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L116-L116)

```54:         _setRoleAdmin(role, adminRole); // <= FOUND
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L54-L54)

```203: 
204:         
205:         (
206:             address[] memory targets, // <= FOUND
207:             uint256[] memory values, // <= FOUND
208:             bytes[] memory calldatas, // <= FOUND
209:             string memory description
210:         ) = getOnboardProposeArgs(term); // <= FOUND
```

*GitHub* : [203](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L203-L210)

```444:             creditEarned += claimGaugeRewards(user, gauges[i]); // <= FOUND
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L444-L444)

```325: 
326:         
327:         (
328:             address[] memory targets, // <= FOUND
329:             uint256[] memory values, // <= FOUND
330:             bytes[] memory calldatas, // <= FOUND
331:             string memory description
332:         ) = _getVetoCalls(timelockId); // <= FOUND
```

*GitHub* : [325](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L325-L332)

```325:         
326:         (
327:             address[] memory targets, // <= FOUND
328:             uint256[] memory values, // <= FOUND
329:             bytes[] memory calldatas, // <= FOUND
330:             string memory description
331:         ) = _getVetoCalls(timelockId); // <= FOUND
```

*GitHub* : [325](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L325-L331)

```524:                 _decrementGaugeWeight(user, gauge, userGaugeWeight); // <= FOUND
```

*GitHub* : [524](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L524-L524)

```147:         _decrementGaugeWeight(who, gauge, _userGaugeWeight); // <= FOUND
```

*GitHub* : [147](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L147-L147)

```80:         return _addGauge(_type, gauge); // <= FOUND
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L80-L80)

```99:         _setCanExceedMaxGauges(who, can); // <= FOUND
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L99-L99)

```154: 
155:         
156:         _burn(who, uint256(_userGaugeWeight)); // <= FOUND
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L154-L156)

```283:         _decrementWeightUntilFree(from, amount); // <= FOUND
```

*GitHub* : [283](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L283-L283)

```312:             _incrementDelegation(delegator, newDelegatee, freeVotes(delegator)); // <= FOUND
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L312-L312)

```99:         return _checkpointsLookup(_checkpoints[account], blockNumber); // <= FOUND
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L99-L99)

```111:             uint256 mid = average(low, high); // <= FOUND
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L111-L111)

```70:         _setContractExceedMaxDelegates(account, canExceedMax); // <= FOUND
```

*GitHub* : [70](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L70-L70)

```303:             _undelegate( // <= FOUND
304:                 delegator, // <= FOUND
305:                 oldDelegatee, // <= FOUND
306:                 _delegatesVotesCount[delegator][oldDelegatee]
307:             );
```

*GitHub* : [303](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L303-L305)

```504:         _delegate(signer, delegatee); // <= FOUND
```

*GitHub* : [504](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L504-L504)

```341:         _writeCheckpoint(delegatee, _add, amount); // <= FOUND
```

*GitHub* : [341](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L341-L341)

```360:         _writeCheckpoint(delegatee, _subtract, amount); // <= FOUND
```

*GitHub* : [360](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L360-L360)

```455: 
456:                 _writeCheckpoint(delegatee, _subtract, delegateVotes); // <= FOUND
```

*GitHub* : [455](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L455-L456)

```404:         _decrementVotesUntilFree(from, amount); // <= FOUND
```

*GitHub* : [404](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L404-L404)

```94:         _decrementVotesUntilFree(account, amount);  // <= FOUND
```

*GitHub* : [94](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L94-L94)

```134:         _decrementVotesUntilFree(from, amount);  // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L134-L134)

```297:         updateTotalRebasingShares(currentRebasingSharePrice, int256(shares)); // <= FOUND
```

*GitHub* : [297](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L297-L297)

```330:         updateTotalRebasingShares(currentRebasingSharePrice, -int256(shares)); // <= FOUND
```

*GitHub* : [330](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L330-L330)

```500:             updateTotalRebasingShares( // <= FOUND
501:                 _rebasingSharePrice, // <= FOUND
502:                 -int256(sharesBurnt)
503:             );
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L500-L501)

```536:             updateTotalRebasingShares( // <= FOUND
537:                 _rebasingSharePrice, // <= FOUND
538:                 int256(sharesReceived)
539:             );
```

*GitHub* : [536](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L536-L537)

```638:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta); // <= FOUND
```

*GitHub* : [638](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L638-L638)

```395:         return _shares2balance(totalRebasingShares, rebasingSharePrice(), 0, 0); // <= FOUND
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L395-L395)

```292:         uint256 shares = _balance2shares(balance, currentRebasingSharePrice); // <= FOUND
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L292-L292)

```491:             uint256 sharesAfter = _balance2shares( // <= FOUND
492:                 balanceAfter, // <= FOUND
493:                 _rebasingSharePrice
494:             );
```

*GitHub* : [491](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L491-L492)

```527: 
528:             
529:             uint256 sharesAfter = _balance2shares( // <= FOUND
530:                 rebasedBalance, // <= FOUND
531:                 _rebasingSharePrice
532:             );
```

*GitHub* : [527](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L527-L530)

```590:             uint256 fromSharesAfter = _balance2shares( // <= FOUND
591:                 fromBalanceAfter, // <= FOUND
592:                 _rebasingSharePrice
593:             );
```

*GitHub* : [590](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L590-L591)

```614: 
615:             
616:             uint256 toSharesAfter = _balance2shares( // <= FOUND
617:                 toBalanceAfter, // <= FOUND
618:                 _rebasingSharePrice
619:             );
```

*GitHub* : [614](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L614-L617)

```316:         uint256 rebasedBalance = _shares2balance( // <= FOUND
317:             shares, // <= FOUND
318:             currentRebasingSharePrice, // <= FOUND
319:             0, // <= FOUND
320:             rawBalance
321:         );
```

*GitHub* : [316](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L316-L319)

```347:         uint256 _rebasingSupply = _shares2balance( // <= FOUND
348:             _totalRebasingShares, // <= FOUND
349:             _rebasingSharePrice, // <= FOUND
350:             0, // <= FOUND
351:             0
352:         );
```

*GitHub* : [347](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L347-L350)

```568:             uint256 rebasedBalance = _shares2balance( // <= FOUND
569:                 shares, // <= FOUND
570:                 _rebasingSharePrice, // <= FOUND
571:                 0, // <= FOUND
572:                 fromBalanceBefore
573:             );
```

*GitHub* : [568](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L568-L571)

```272:         _mint(to, amount); // <= FOUND
```

*GitHub* : [272](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L272-L272)

```169:         
170:         
171:         (uint256 collateralReceived, uint256 creditAsked) = getBidDetail( // <= FOUND
172:             loanId
173:         );
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L169-L171)

```205:         
206:         
207:         (, uint256 creditAsked) = getBidDetail(loanId); // <= FOUND
```

*GitHub* : [205](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L205-L207)

```38:     
39:     event Unstake( // <= FOUND
40:         uint256 indexed timestamp, // <= FOUND
41:         address indexed term, // <= FOUND
42:         uint256 amount
43:     );
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L38-L41)

```295:         
296:         (, UserStake memory userStake, bool slashed) = getRewards(user, term); // <= FOUND
```

*GitHub* : [295](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L295-L296)
### [NC-69]<a name="nc-69"></a> Using XOR (^) and AND (&) bitwise equivalents
XOR (^) and AND (&) are bitwise operators that can be more efficient for specific operations in Solidity. XOR returns true if the bits being compared are different, and AND returns true if both bits are true. Using these operators can lead to more concise and efficient code for tasks such as toggling bits or checking specific bit conditions. By applying bitwise logic, you can reduce computational complexity and enhance code performance. Consider using XOR and AND where appropriate, understanding the specific requirements and ensuring that the use of these operators aligns with the intended logic of the application.

*There are 1 instance(s) of this issue:*

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) {
399:         bool newAdd = _gauges.add(gauge);
400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge);
401:         
402:         require(
403:             gauge != address(0) && (newAdd || previouslyDeprecated),
404:             "ERC20Gauges: invalid gauge"
405:         );
406: 
407:         if (newAdd) {
408:             
409:             gaugeType[gauge] = _type;
410:         } else {
411:             
412:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type");
413:         }
414: 
415:         
416:         weight = getGaugeWeight[gauge];
417:         if (weight != 0) {
418:             totalTypeWeight[_type] += weight;
419:             totalWeight += weight;
420:         }
421: 
422:         emit AddGauge(gauge, _type);
423:     }
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)
### [NC-70]<a name="nc-70"></a> Public state variables should include natspec comments
State variables in Solidity contracts are essential for defining the state of the contract. Including comments for these variables improves code readability and maintainability by providing context and explaining their purpose. This practice aids future developers or auditors in understanding the code, thus reducing the likelihood of misinterpretation or errors.

*There are 3 instance(s) of this issue:*

```    /// shall be redistributed to holders through a savings rate or another mechanism.
uint256 public creditMultiplier = 1e18; // <= FOUND
```

  *GitHub* :

```    uint256 public gaugeWeightTolerance = 1.2e18; // 120% // <= FOUND
constructor(address _core) CoreRef(_core) {
```

  *GitHub* :

```    /// interpolated linearly over a period of DISTRIBUTION_PERIOD seconds after a distribution.
uint256 public constant DISTRIBUTION_PERIOD = 30 days; // <= FOUND
```

  *GitHub* :
### [NC-71]<a name="nc-71"></a> Lack of space near the operator
Lack of space near operators in code can lead to reduced readability, making it more challenging to distinguish between different elements and understand the logic quickly. As a resolution, always include spaces around operators to ensure a clear visual separation, which promotes better maintainability and comprehension of the code.

*There are 22 instance(s) of this issue:*

```241:         surplusBufferSplit =
242:             uint256(profitSharingConfig.surplusBufferSplit) * // <= FOUND
243:             1e9; // <= FOUND
```

*GitHub* : [241](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L241-L243)

```332:                 uint256 newCreditMultiplier = (creditMultiplier * // <= FOUND
333:                     (creditTotalSupply - loss)) / creditTotalSupply; // <= FOUND
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L332-L333)

```346: 
347:             uint256 amountForSurplusBuffer = (uint256(amount) * // <= FOUND
348:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9; // <= FOUND
```

*GitHub* : [346](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L346-L348)

```349: 
350:             uint256 amountForGuild = (uint256(amount) * // <= FOUND
351:                 uint256(_profitSharingConfig.guildSplit)) / 1e9; // <= FOUND
```

*GitHub* : [349](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L349-L351)

```352: 
353:             uint256 amountForOther = (uint256(amount) * // <= FOUND
354:                 uint256(_profitSharingConfig.otherSplit)) / 1e9; // <= FOUND
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L352-L354)

```37:     using SafeCastLib for *; // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L37-L37)

```365:             uint256 newTargetSharePrice = (amount * // <= FOUND
366:                 START_REBASING_SHARE_PRICE + // <= FOUND
367:                 __rebasingSharePrice.targetValue * // <= FOUND
368:                 _totalRebasingShares) / _totalRebasingShares; // <= FOUND
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L365-L368)

```218:         uint256 interest = (borrowAmount * // <= FOUND
219:             params.interestRate * // <= FOUND
220:             (block.timestamp - borrowTime)) / // <= FOUND
221:             YEAR / // <= FOUND
222:             1e18; // <= FOUND
```

*GitHub* : [218](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L218-L222)

```307:         uint256 debtCeilingBefore = (totalBorrowedCredit * // <= FOUND
308:             toleratedGaugeWeight) / totalWeight; // <= FOUND
```

*GitHub* : [307](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L307-L308)

```357:         uint256 maxBorrow = (collateralAmount * // <= FOUND
358:             params.maxDebtPerCollateralToken) / creditMultiplier; // <= FOUND
```

*GitHub* : [357](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L357-L358)

```712:         uint256 principal = (borrowAmount * // <= FOUND
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [712](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L712-L713)

```396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex + // <= FOUND
398:                         (amountForGuild * 1e18) / // <= FOUND
399:                         _gaugeWeight; // <= FOUND
```

*GitHub* : [396](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L396-L399)

```148:             return
149:                 lastValue + // <= FOUND
150:                 (delta * elapsed) / // <= FOUND
151:                 (targetTimestamp - lastTimestamp); // <= FOUND
```

*GitHub* : [148](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L148-L151)

```215:             uint256 targetNewSharePrice = currentRebasingSharePrice + // <= FOUND
216:                 (delta * START_REBASING_SHARE_PRICE) / // <= FOUND
217:                 percentChange; // <= FOUND
```

*GitHub* : [215](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L215-L217)

```266:         uint256 rebasedBalance = (shares * sharePrice) / // <= FOUND
267:             START_REBASING_SHARE_PRICE + // <= FOUND
268:             deltaBalance; // <= FOUND
```

*GitHub* : [266](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L266-L268)

```379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue + // <= FOUND
383:                     SafeCastLib.safeCastTo224(amount)
384:             }); // <= FOUND
```

*GitHub* : [379](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L379-L384)

```213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) / // <= FOUND
214:                 sharesBefore; // <= FOUND
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L213-L214)

```305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) / // <= FOUND
306:             1e18; // <= FOUND
```

*GitHub* : [305](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L305-L306)

```320:         uint256 maxBorrow = (remainingDebtCeiling * totalWeight) / // <= FOUND
321:             otherGaugesWeight; // <= FOUND
```

*GitHub* : [320](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L320-L321)

```514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) / // <= FOUND
515:             creditMultiplier; // <= FOUND
```

*GitHub* : [514](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L514-L515)

```175: 
176:         
177:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) / // <= FOUND
178:             userStake.credit;  // <= FOUND
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L175-L178)

```250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) / // <= FOUND
251:                 1e18; // <= FOUND
```

*GitHub* : [250](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L250-L251)
### [NC-72]<a name="nc-72"></a> Lack Of Brace Spacing
Lack of brace spacing in coding refers to the absence of spaces around braces, which can hinder code readability. In Solidity, as in many programming languages, spacing can enhance the visual distinction between different parts of the code, making it easier to follow. A lack of spacing can lead to a dense, confusing appearance. The resolution to this issue is to follow a consistent style guide that defines rules for brace spacing. By including spaces around braces, such as `{ statement }` instead of `{statement}`, developers can ensure that the code is more legible and maintainable, especially in larger codebases.

*There are 45 instance(s) of this issue:*

```4: 
5: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L4-L5)

```5: import {AccessControlEnumerable} from "@openzeppelin/contracts/access/AccessControlEnumerable.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L5-L5)

```10: 
11: import {Core} from "@src/core/Core.sol"; // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L10-L11)

```4: import {CoreRoles} from "@src/core/CoreRoles.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L4-L4)

```7: 
8: import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L7-L8)

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L101-L102)

```8: 
9: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L8-L9)

```5: import {GovernorSettings} from "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L5-L5)

```6: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L6-L6)

```7: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L7-L7)

```8: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L8-L8)

```9: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol"; // <= FOUND
```

*GitHub* : [9](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L9-L9)

```6: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L6-L6)

```4: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L4-L4)

```4: 
5: import {CoreRef} from "@src/core/CoreRef.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L4-L5)

```6: import {SimplePSM} from "@src/loan/SimplePSM.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L6-L6)

```7: import {GuildToken} from "@src/tokens/GuildToken.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L7-L7)

```6: import {LendingTerm} from "@src/loan/LendingTerm.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L6-L6)

```4: 
5: import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L4-L5)

```5: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L5-L5)

```6: import {Strings} from "@openzeppelin/contracts/utils/Strings.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L6-L6)

```7: import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L7-L7)

```8: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L8-L8)

```14: import {GuildGovernor} from "@src/governance/GuildGovernor.sol"; // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L14-L14)

```8: import {CreditToken} from "@src/tokens/CreditToken.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L8-L8)

```4: 
5: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L4-L5)

```7: import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L7-L7)

```6: 
7: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L6-L7)

```9: 
10: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol"; // <= FOUND
```

*GitHub* : [9](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L9-L10)

```9: import {SafeCastLib} from "@src/external/solmate/SafeCastLib.sol"; // <= FOUND
```

*GitHub* : [9](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L9-L9)

```6: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L6-L6)

```6: import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L6-L6)

```14: import {ERC20MultiVotes} from "@src/tokens/ERC20MultiVotes.sol"; // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L14-L14)

```11: import {ERC20RebaseDistributor} from "@src/tokens/ERC20RebaseDistributor.sol"; // <= FOUND
```

*GitHub* : [11](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L11-L11)

```12: import {ERC20Gauges} from "@src/tokens/ERC20Gauges.sol"; // <= FOUND
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L12-L12)

```13: import {ProfitManager} from "@src/governance/ProfitManager.sol"; // <= FOUND
```

*GitHub* : [13](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L13-L13)

```5: 
6: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L5-L6)

```5: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L5-L5)

```6: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L6-L6)

```12: import {AuctionHouse} from "@src/loan/AuctionHouse.sol"; // <= FOUND
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L12-L12)

```11: import {RateLimitedMinter} from "@src/rate-limits/RateLimitedMinter.sol"; // <= FOUND
```

*GitHub* : [11](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L11-L11)

```6: import {RateLimitedV2} from "@src/utils/RateLimitedV2.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L6-L6)

```8: 
9: import {CreditToken} from "@src/tokens/CreditToken.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L8-L9)

```4: 
5: import {Math} from "@openzeppelin/contracts/utils/math/Math.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L4-L5)

```9: import {IRateLimitedV2} from "@src/utils/IRateLimitedV2.sol"; // <= FOUND
```

*GitHub* : [9](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L9-L9)
### [NC-73]<a name="nc-73"></a> Using while for unbounded loops isn’t recommended
Utilizing a `while` loop for unbounded iterations in Solidity isn't advisable as it can lead to unintended infinite loops. Such loops could consume all the available gas, causing transactions to fail and losing the gas spent. This can lead to a denial-of-service vulnerability if used maliciously. It's generally better to impose an upper limit on iterations or apply a pattern that ensures termination. If an unbounded loop is necessary, implementing safeguards, careful logic, and possibly an emergency stop mechanism can mitigate the risks. Using tools to analyze loop conditions and behavior can also help avoid potential issues.

*There are 1 instance(s) of this issue:*

```110:         while (low < high)  // <= FOUND
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L110-L110)
### [NC-74]<a name="nc-74"></a> Revert should be used on some functions instead of return
Using the `revert` statement instead of `return` in certain functions is essential for contract integrity in Solidity. While `return` merely exits the function and returns a value, `revert` undoes all changes made in the current function and throughout all its subsequent calls. In scenarios where a failure condition is met, such as incorrect inputs or an unauthorized access attempt, using `revert` ensures that the contract's state is not altered in an unintended way. This preserves consistency and helps prevent logical errors. It also makes the code's intention clear, simplifying debugging and maintenance.

*There are 1 instance(s) of this issue:*

```237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) {
240:         
241:         if (params.maxDelayBetweenPartialRepay == 0) return false;
242: 
243:         
244:         if (loans[loanId].borrowTime == 0) return false;
245: 
246:         
247:         if (loans[loanId].closeTime != 0) return false;
248: 
249:         
250:         return
251:             lastPartialRepay[loanId] <
252:             block.timestamp - params.maxDelayBetweenPartialRepay;
253:     }
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L237-L237)
### [NC-75]<a name="nc-75"></a> Common functions should be refactored to a common base contract
In Solidity development, it's advisable to refactor common functions into a shared base contract to enhance code reusability and maintainability. This approach not only promotes clean and organized code but also saves on gas costs when deploying multiple contracts that utilize the same functions. By placing shared logic in a common base contract, it becomes easier to manage updates to those functions, reducing the likelihood of errors across multiple dependent contracts. The resolution is to identify the functions that are used across different contracts, encapsulate them in a base contract, and then inherit from that base contract wherever those functions are needed.

*There are 2 instance(s) of this issue:*

```57:     function quorum(
58:         uint256 
59:     ) public view override returns (uint256) {
60:         return _quorum;
61:     }
```

*GitHub* :

```99:     function setQuorum(
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) {
102:         _setQuorum(newQuorum);
103:     }
```

*GitHub* :
### [NC-76]<a name="nc-76"></a> Use of override is unnecessary
Starting with Solidity version 0.8.8, the use of the `override` keyword is simplified. If a function solely overrides an interface function and does not exist in multiple base contracts, specifying `override` becomes unnecessary. This change streamlines the code and makes it less verbose. Removing unnecessary use of `override` in these situations can make the code cleaner and more maintainable, aligning with the newer Solidity guidelines. It's a good practice to adapt to this updated behavior to stay consistent with the language's evolution and current best practices.

*There are 8 instance(s) of this issue:*

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override  // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```222:     function votingDelay() public pure override returns (uint256)  // <= FOUND
```

*GitHub* : [222](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L222-L222)

```230:     function votingPeriod() public pure override returns (uint256)  // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L230-L230)

```444:     function totalSupply() public view virtual override returns (uint256)  // <= FOUND
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L444-L444)

```461:     function _burn(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```509:     function _mint(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)
### [NC-77]<a name="nc-77"></a> Unsafe uint to int conversion
Unsafe conversion from `uint` to `int` in Solidity can lead to unexpected overflows if the unsigned integer value exceeds the positive limit of the corresponding signed integer type. This is due to the fact that signed integers use one bit for the sign, effectively halving the positive range. An example is converting a `uint256` number greater than `type(uint128).max` to an `int256`, which can result in an overflow. To mitigate this risk, consider using libraries like SafeCast, which include functions specifically designed to safely cast between different numerical types. They perform necessary checks and revert the transaction if an unsafe cast is attempted, thereby enhancing the security and robustness of the code.

*There are 8 instance(s) of this issue:*

```297:         updateTotalRebasingShares(currentRebasingSharePrice, int256(shares)); // <= FOUND
```

*GitHub* : [297](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L297-L297)

```536:             updateTotalRebasingShares(
537:                 _rebasingSharePrice,
538:                 int256(sharesReceived) // <= FOUND
539:             );
```

*GitHub* : [536](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L536-L538)

```595:             sharesDelta -= int256(sharesSpent); // <= FOUND
```

*GitHub* : [595](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L595-L595)

```619:             sharesDelta += int256(sharesReceived); // <= FOUND
```

*GitHub* : [619](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L619-L619)

```550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid) // <= FOUND
553:         );
```

*GitHub* : [550](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L550-L552)

```603: 
604:             
605:             ProfitManager(refs.profitManager).notifyPnL(
606:                 address(this),
607:                 int256(interest) // <= FOUND
608:             );
```

*GitHub* : [603](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L603-L607)

```760:             pnl = int256(interest); // <= FOUND
```

*GitHub* : [760](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L760-L760)

```762:             pnl = int256(creditFromBidder) - int256(principal); // <= FOUND
```

*GitHub* : [762](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L762-L762)
### [NC-78]<a name="nc-78"></a> If statement control structures do not comply with best practices
If statements which include a single line do not need to have curly brackets, however according to the Solidiity style guide the line of code executed upon the if statement condition being met should still be on the next line, not on the same line as the if statement declaration.

*There are 14 instance(s) of this issue:*

```186:         if (_deprecatedGauges.contains(gauge)) return 0; // <= FOUND
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L186-L186)

```189:         if (total == 0) return 0; // <= FOUND
```

*GitHub* : [189](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L189-L189)

```504: 
505:         
506:         if (userFreeWeight >= weight) return; // <= FOUND
```

*GitHub* : [504](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L504-L506)

```431: 
432:         
433:         if (userFreeVotes >= votes) return; // <= FOUND
```

*GitHub* : [431](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L431-L433)

```172:         if (sharesDelta == 0) return; // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L172-L172)

```241:         
242:         if (params.maxDelayBetweenPartialRepay == 0) return false; // <= FOUND
```

*GitHub* : [241](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L241-L242)

```244: 
245:         
246:         if (loans[loanId].borrowTime == 0) return false; // <= FOUND
```

*GitHub* : [244](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L244-L246)

```247: 
248:         
249:         if (loans[loanId].closeTime != 0) return false; // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L247-L249)

```166: 
167:         
168:         if (slashed) return; // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L166-L168)

```179: 
180:         if (amount == userStake.credit) guildAmount = userStake.guild; // <= FOUND
```

*GitHub* : [179](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L179-L180)

```235:         if (userStake.stakeTime == 0) // <= FOUND
236:             return (lastGaugeLoss, userStake, slashed); // <= FOUND
```

*GitHub* : [235](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L235-L236)

```244: 
245:         if (_profitIndex == 0) _profitIndex = 1e18; // <= FOUND
```

*GitHub* : [244](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L244-L245)

```245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [245](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L245-L245)

```298: 
299:         
300:         if (userStake.stakeTime == 0 || slashed) return; // <= FOUND
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L298-L300)
### [NC-79]<a name="nc-79"></a> Contract does not follow the Solidity style guide's suggested layout ordering

*There are 1 instance(s) of this issue:*

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)
### [NC-80]<a name="nc-80"></a> Consider adding formal verification proofs

*There are 14 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is // <= FOUND
17:     CoreRef, // <= FOUND
18:     Governor, // <= FOUND
19:     GovernorVotes, // <= FOUND
20:     GovernorTimelockControl, // <= FOUND
21:     GovernorSettings, // <= FOUND
22:     GovernorCountingSimple // <= FOUND
23:  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L23)

```14: contract GuildTimelockController is TimelockController, CoreRef  // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```16: contract LendingTermOffboarding is CoreRef  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor  // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is // <= FOUND
19:     CoreRef, // <= FOUND
20:     ERC20Burnable, // <= FOUND
21:     ERC20MultiVotes, // <= FOUND
22:     ERC20RebaseDistributor // <= FOUND
23:  // <= FOUND
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L23)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef  // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef  // <= FOUND
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2  // <= FOUND
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-81]<a name="nc-81"></a> Unused import
If these serve no purpose, they should be safely removed

*There are 2 instance(s) of this issue:*

```7: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L7-L7)

```6: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L6-L6)
### [NC-82]<a name="nc-82"></a> Use string.concat() on strings instead of abi.encodePacked() for clearer semantic meaning
From Solidity 0.8.12 onwards, developers can utilize `string.concat()` to concatenate strings without additional padding. Opting for `string.concat()` over `abi.encodePacked()` offers clearer semantic interpretation of the code's intent, enhancing readability. This shift minimizes ambiguity, reducing the potential for misinterpretation by reviewers or future developers. Thus, for string concatenation tasks, it's recommended to transition to `string.concat()` for transparent, straightforward code that communicates its purpose distinctly.

*There are 2 instance(s) of this issue:*

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); 
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId))
390:         );
391:     }
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L367)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)
### [NC-83]<a name="nc-83"></a> function names should be lowerCamelCase

*There are 1 instance(s) of this issue:*

```130:     function COUNTING_MODE()
131:         public
132:         pure
133:         virtual
134:         override
135:         returns (string memory)
136:     
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L130-L130)
### [NC-84]<a name="nc-84"></a> Consider bounding input array length
Unbounded array inputs in functions can lead to unintentional excessive gas consumption, potentially causing a transaction to revert after expending substantial gas. To enhance user experience and prevent such scenarios, consider implementing a `require()` statement that limits the array length to a defined maximum. This constraint ensures that transactions won't proceed if they're likely to hit gas limits due to array size, saving users from unnecessary gas costs and offering a more predictable interaction with the contract.

*There are 5 instance(s) of this issue:*

```96:        for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```443:        for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
444:             creditEarned += claimGaugeRewards(user, gauges[i]);
445:             unchecked {
446:                 ++i;
447:             }
448:         }
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L443)

```467:        for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L467-L467)

```134:        for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) { // <= FOUND
135:             if (!_deprecatedGauges.contains(allGauges[i])) {
136:                 _liveGauges[j] = allGauges[i];
137:                 unchecked {
138:                     ++j;
139:                 }
140:             }
141:             unchecked {
142:                 ++i;
143:             }
144:         }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L134-L134)

```685:        for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [NC-85]<a name="nc-85"></a> Duplicated require() checks should be refactored to a modifier or function

*There are 8 instance(s) of this issue:*

```154: require(canOffboard[term], "LendingTermOffboarding: quorum not met"); // <= FOUND
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L154-L154)

```223: require(isGauge(gauge), "ERC20Gauges: invalid gauge"); // <= FOUND
```

*GitHub* : [223](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L223-L223)

```274: require(weights.length == size, "ERC20Gauges: size mismatch"); // <= FOUND
```

*GitHub* : [274](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L274-L274)

```458: require(loan.borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [458](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L458-L458)

```459: require(loan.closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [459](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L459-L459)

```460: require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L460)

```499: require(borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [499](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L499-L499)

```500: require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
```

*GitHub* :
### [NC-86]<a name="nc-86"></a> safeApprove()/approve() may revert if the current approval is not zero
The `approve()` and `safeApprove()` functions in ERC20 token contracts are designed to set an allowance for a spender. However, there's a known issue where calling `approve()` to set a new allowance before the current one is zero can be a potential race condition. Attackers might spend the old allowance and the new one before the owner has a chance to change it. To mitigate this, many token contracts require the current allowance to be zero before setting a new one. As a resolution, always set the allowance to zero with an additional transaction before assigning a new value, or utilize patterns like `increaseAllowance()` and `decreaseAllowance()`.

*There are 1 instance(s) of this issue:*

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount); // <= FOUND
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L129)
### [NC-87]<a name="nc-87"></a> Consider disallowing transfers to `address(this)`
Disallowing transfers to `address(this)` prevents accidental token lockup within the contract. Transferring tokens to the contract's own address might render them irretrievable. Implement a check in the transfer function to reject transactions with the contract's address as the recipient, ensuring tokens aren't unintentionally trapped.

*There are 5 instance(s) of this issue:*

```481:     function transfer( // <= FOUND
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount);
486:         return super.transfer(to, amount);
487:     }
```

*GitHub* : [481](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L481-L481)

```408:     function transfer( // <= FOUND
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) {
412:         _decrementVotesUntilFree(msg.sender, amount);
413:         return super.transfer(to, amount);
414:     }
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L408)

```553:     function transfer( // <= FOUND
554:         address to,
555:         uint256 amount
556:     ) public virtual override returns (bool) {
557:         
558:         
559:         RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
560:         RebasingState memory rebasingStateTo = rebasingState[to];
561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
562:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
563:             rebasingStateTo.isRebasing == 1)
564:             ? rebasingSharePrice()
565:             : 0; 
566:         if (rebasingStateFrom.isRebasing == 1) {
567:             uint256 shares = uint256(rebasingStateFrom.nShares);
568:             uint256 rebasedBalance = _shares2balance(
569:                 shares,
570:                 _rebasingSharePrice,
571:                 0,
572:                 fromBalanceBefore
573:             );
574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
575:             if (mintAmount != 0) {
576:                 ERC20._mint(msg.sender, mintAmount);
577:                 fromBalanceBefore += mintAmount;
578:                 decreaseUnmintedRebaseRewards(mintAmount);
579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount);
580:             }
581:         }
582: 
583:         
584:         bool success = ERC20.transfer(to, amount);
585: 
586:         
587:         int256 sharesDelta;
588:         if (rebasingStateFrom.isRebasing == 1) {
589:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
590:             uint256 fromSharesAfter = _balance2shares(
591:                 fromBalanceAfter,
592:                 _rebasingSharePrice
593:             );
594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
595:             sharesDelta -= int256(sharesSpent);
596:             rebasingState[msg.sender] = RebasingState({
597:                 isRebasing: 1,
598:                 nShares: uint248(fromSharesAfter)
599:             });
600:         }
601: 
602:         
```

*GitHub* : [553](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L553-L553)

```113:     function transfer( // <= FOUND
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     {
121:         _decrementVotesUntilFree(msg.sender, amount); 
122:         return ERC20RebaseDistributor.transfer(to, amount);
123:     }
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L113)

```288:     function transfer( // <= FOUND
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     {
297:         _decrementWeightUntilFree(msg.sender, amount);
298:         _decrementVotesUntilFree(msg.sender, amount);
299:         return ERC20.transfer(to, amount);
300:     }
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L288)
### [NC-88]<a name="nc-88"></a> Add inline comments for unnamed variables in function declarations
Unnamed variables in function declarations can confuse developers. To enhance clarity, add inline comments next to each unnamed variable. E.g address, -> address /* to */,

*There are 1 instance(s) of this issue:*

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op, // <= FOUND
366:         uint256 delta
367:     ) private 
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L365-L365)
### [NC-89]<a name="nc-89"></a> Ensure block.timestamp is only used in long time intervals
`block.timestamp` represents the current block's timestamp and can be influenced, within limits, by miners. For short time intervals, this malleability can be exploited, potentially allowing miners to manipulate contract behavior. For instance, they might fast-forward an expiration or delay an event. When designing smart contracts, if precise time checks are needed for short intervals, alternatives like block numbers can be considered. However, for longer durations where a few seconds of deviation is inconsequential, `block.timestamp` is generally safe and efficient. Always assess the implications of time manipulations for the specific use-case before utilizing `block.timestamp`. In practice, if you're using block.timestamp to measure intervals that are a matter of days, weeks, or longer, the potential manipulation by miners becomes less significant. Always prioritize the security and integrity of your smart contract operations when making these decisions.

*There are 1 instance(s) of this issue:*

```364:             
365:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD; // <= FOUND
```

*GitHub* : [364](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L364-L365)
### [NC-90]<a name="nc-90"></a> It is best practice to use linear inheritance
In Solidity, complex inheritance structures can obfuscate code understanding, introducing potential security risks. Multiple inheritance, especially with overlapping function names or state variables, can cause unintentional overrides or ambiguous behavior. Resolution: Strive for linear and simple inheritance chains. Avoid diamond or circular inheritance patterns. Clearly document the purpose and relationships of base contracts, ensuring that overrides are intentional. Tools like Remix or Hardhat can visualize inheritance chains, assisting in verification. Keeping inheritance streamlined aids in better code readability, reduces potential errors, and ensures smoother audits and upgrades.

*There are 5 instance(s) of this issue:*

```16: contract GuildGovernor is
17:     CoreRef, // <= FOUND
18:     Governor, // <= FOUND
19:     GovernorVotes, // <= FOUND
20:     GovernorTimelockControl, // <= FOUND
21:     GovernorSettings, // <= FOUND
22:     GovernorCountingSimple
23: 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L17-L21)

```14: contract GuildTimelockController is TimelockController, CoreRef  // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is
19:     CoreRef, // <= FOUND
20:     ERC20Burnable, // <= FOUND
21:     ERC20MultiVotes, // <= FOUND
22:     ERC20RebaseDistributor
23: 
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L19-L21)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)
### [NC-91]<a name="nc-91"></a> A event should be emitted if a non immutable state variable is set in a constructor

*There are 7 instance(s) of this issue:*

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken;
73:         psm = _psm; // <= FOUND
74:         quorum = _quorum; // <= FOUND
75:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L74)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager; // <= FOUND
98:         credit = _credit; // <= FOUND
99:         guild = _guild; // <= FOUND
100:         rlgm = _rlgm;
101:         mintRatio = _mintRatio; // <= FOUND
102:         rewardRatio = _rewardRatio; // <= FOUND
103:     }
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L102)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager; // <= FOUND
72:         credit = _credit; // <= FOUND
73:         pegToken = _pegToken;
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L72)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     {
83:         guildToken = _lendingTermReferences.guildToken;
84:         gaugeType = _gaugeType;
85:         profitManager = _lendingTermReferences.profitManager; // <= FOUND
86:         auctionHouse = _lendingTermReferences.auctionHouse;
87:         creditMinter = _lendingTermReferences.creditMinter;
88:         creditToken = _lendingTermReferences.creditToken;
89:     }
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L85)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager; // <= FOUND
52:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L51)

```19:     constructor(address coreAddress) {
20:         _core = Core(coreAddress); // <= FOUND
21:     }
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L20)

```40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) {
45:         lastBufferUsedTime = block.timestamp.safeCastTo32(); // <= FOUND
46: 
47:         _setBufferCap(_bufferCap);
48:         bufferStored = _bufferCap; // <= FOUND
49: 
50:         require(
51:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
52:             "RateLimited: rateLimitPerSecond too high"
53:         );
54:         _setRateLimitPerSecond(_rateLimitPerSecond);
55: 
56:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
57:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L40-L48)
### [NC-92]<a name="nc-92"></a> Funds can be trapped due to unreverting local payable call
Ensuring failsafe mechanisms in smart contracts is pivotal to prevent trapped funds, particularly when dealing with local payable calls (calling local payable functions which cannot revert). If a contract sends funds (e.g., Ether) using a local payable call and doesn’t revert the transaction under failure conditions, funds could become irretrievable if the called contract fails to execute as intended. To circumvent this, always implement a check, leveraging the “transfer” or “require” with “call” pattern to ensure that if the payable call fails, the entire transaction reverts, preventing fund trapping. Additionally, establishing a clear, executable pathway for fund recovery and meticulously testing the contract, especially in edge cases or failure scenarios, ensures robustness against lost fund incidents. Employ mechanisms like "pull over push" payments for additional safety. Utilizing tried-and-true patterns and avoiding anti-patterns wherever possible also enhances contract reliability and user trust.

*There are 1 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L87)
### [NC-93]<a name="nc-93"></a> Superfluous parameter can only be one value
Using redundant parameters in smart contracts can lead to unnecessary complexity and potential vulnerabilities. When a function parameter is always constrained to a specific value due to an `if` or `require` statement, it renders the parameter superfluous. Including such parameters can be misleading to developers or users, suggesting a flexibility that doesn't exist in reality. Additionally, unnecessary parameters increase the gas cost for transactions. Resolution: Analyze the contract to identify parameters that are rendered static by conditional checks. Remove these parameters from the function signature and update the function logic accordingly. This simplifies the code, reduces gas costs, and enhances clarity and security.

*There are 5 instance(s) of this issue:*

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
202:         if (otherRecipient == address(0)) {
203:             require(otherSplit == 0, "GuildToken: invalid config"); // <= FOUND
204:         } else {
205:             require(otherSplit != 0, "GuildToken: invalid config");
206:         }
207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         );
211: 
212:         profitSharingConfig = ProfitSharingConfig({
213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9),
214:             guildSplit: uint32(guildSplit / 1e9),
215:             otherSplit: uint32(otherSplit / 1e9),
216:             otherRecipient: otherRecipient
217:         });
218: 
219:         emit ProfitSharingConfigUpdate(
220:             block.timestamp,
221:             surplusBufferSplit,
222:             creditSplit,
223:             guildSplit,
224:             otherSplit,
225:             otherRecipient
226:         );
227:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L203)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce"); // <= FOUND
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L502)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override {
187:         require(
188:             transferable || from == address(0) || to == address(0),
189:             "GuildToken: transfers disabled"
190:         );
191:     }
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L182)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) {
399:         bool newAdd = _gauges.add(gauge);
400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge);
401:         
402:         require(
403:             gauge != address(0) && (newAdd || previouslyDeprecated),
404:             "ERC20Gauges: invalid gauge"
405:         );
406: 
407:         if (newAdd) {
408:             
409:             gaugeType[gauge] = _type;
410:         } else {
411:             
412:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type");
413:         }
414: 
415:         
416:         weight = getGaugeWeight[gauge];
417:         if (weight != 0) {
418:             totalTypeWeight[_type] += weight;
419:             totalWeight += weight;
420:         }
421: 
422:         emit AddGauge(gauge, _type);
423:     }
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)
### [NC-94]<a name="nc-94"></a> Mint functions should be accompanied by a burn function and vice versa
When a contract provides a mint function to increase token supply, it's prudent to also include a burn function to decrease supply, and vice versa. This ensures a balanced mechanism to manage token supply. Without a corresponding burn, continuous minting can lead to inflation, devaluing the token. Conversely, without minting, excessive burning can deflate supply excessively. Both scenarios may disrupt the intended economic model. Resolution: Always pair mint and burn functions in token contracts. Implement appropriate access controls to ensure only authorized entities can trigger these functions, preserving the token's integrity and value proposition.

*There are 3 instance(s) of this issue:*

```25: contract SimplePSM is CoreRef 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)

```30: contract ProfitManager is CoreRef 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)
### [NC-95]<a name="nc-95"></a> Use the Modern Upgradeable Contract Paradigm
Modern smart contract development often employs upgradeable contract structures, utilizing proxy patterns like OpenZeppelin’s Upgradeable Contracts. This paradigm separates logic and state, allowing developers to amend and enhance the contract's functionality without altering its state or the deployed contract address. Transitioning to this approach enhances long-term maintainability.

**Resolution**: Adopt a well-established proxy pattern for upgradeability, ensuring proper initialization and employing transparent proxies to mitigate potential risks. Embrace comprehensive testing and audit practices, particularly when updating contract logic, to ensure state consistency and security are preserved across upgrades. This ensures your contract remains robust and adaptable to future requirements.

*There are 14 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L16)

```14: contract GuildTimelockController is TimelockController, CoreRef 
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```16: contract LendingTermOffboarding is CoreRef 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor 
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is
19:     CoreRef,
20:     ERC20Burnable,
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: 
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L18)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes 
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef 
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-96]<a name="nc-96"></a> Upgrade openzeppelin to the Latest Version - 5.0.0

*There are 20 instance(s) of this issue:*

```5: import {AccessControlEnumerable} from "@openzeppelin/contracts/access/AccessControlEnumerable.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L5-L5)

```7: import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L7-L7)

```8: import {Governor, IGovernor} from "@openzeppelin/contracts/governance/Governor.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L8-L8)

```5: import {GovernorSettings} from "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L5-L5)

```6: import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L6-L6)

```7: import {GovernorVotes, IERC165} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L7-L7)

```8: import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol"; // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L8-L8)

```9: import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol"; // <= FOUND
```

*GitHub* : [9](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L9-L9)

```6: import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L6-L6)

```4: import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L4-L4)

```5: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L5-L5)

```6: import {Strings} from "@openzeppelin/contracts/utils/Strings.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L6-L6)

```7: import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L7-L7)

```4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L4-L4)

```7: import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; // <= FOUND
```

*GitHub* : [7](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L7-L7)

```6: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L6-L6)

```6: import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L6-L6)

```5: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L5-L5)

```6: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L6-L6)

```4: import {Math} from "@openzeppelin/contracts/utils/math/Math.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L4-L4)
### [NC-97]<a name="nc-97"></a> Use a struct to encapsulate multiple function parameters
Using a struct to encapsulate multiple parameters in Solidity functions can significantly enhance code readability and maintainability. Instead of passing a long list of arguments, which can be error-prone and hard to manage, a struct allows grouping related data into a single, coherent entity. This approach simplifies function signatures and makes the code more organized. It also enhances code clarity, as developers can easily understand the relationship between the parameters. Moreover, it aids in future code modifications and expansions, as adding or modifying a parameter only requires changes in the struct definition, rather than in every function that uses these parameters.

*There are 5 instance(s) of this issue:*

```132:     function _execute(
133:         uint256 proposalId, // <= FOUND
134:         address[] memory targets, // <= FOUND
135:         uint256[] memory values, // <= FOUND
136:         bytes[] memory calldatas, // <= FOUND
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl)  // <= FOUND
```

*GitHub* : [133](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L133-L138)

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit, // <= FOUND
197:         uint256 creditSplit, // <= FOUND
198:         uint256 guildSplit, // <= FOUND
199:         uint256 otherSplit, // <= FOUND
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L196-L199)

```195:     function _countVote(
196:         uint256 proposalId, // <= FOUND
197:         address account, // <= FOUND
198:         uint8 support, // <= FOUND
199:         uint256 weight, // <= FOUND
200:         bytes memory 
201:     ) internal virtual override 
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L196-L199)

```471:     function delegateBySig(
472:         address delegatee, // <= FOUND
473:         uint256 nonce, // <= FOUND
474:         uint256 expiry, // <= FOUND
475:         uint8 v, // <= FOUND
476:         bytes32 r, // <= FOUND
477:         bytes32 s
478:     ) public 
```

*GitHub* : [472](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L472-L476)

```725:     function onBid(
726:         bytes32 loanId, // <= FOUND
727:         address bidder, // <= FOUND
728:         uint256 collateralToBorrower, // <= FOUND
729:         uint256 collateralToBidder, // <= FOUND
730:         uint256 creditFromBidder
731:     ) external 
```

*GitHub* : [726](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L726-L729)
### [NC-98]<a name="nc-98"></a> Returning a struct instead of returning many variables is better
Returning a struct from a Solidity function instead of multiple variables offers several benefits, enhancing code clarity and efficiency. Structs allow for the grouping of related data into a single entity, making the function's return values more organized and easier to manage. This approach significantly improves readability, as it encapsulates the data logically, helping developers quickly understand the returned information's structure. Additionally, it simplifies function interfaces, reducing the potential for errors when handling multiple return values. By using structs, you can also easily extend or modify the returned data without altering the function signature, facilitating smoother updates and maintenance of your smart contract code.

*There are 1 instance(s) of this issue:*

```230:     function getProfitSharingConfig()
231:         external
232:         view
233:         returns (
234:             uint256 surplusBufferSplit, // <= FOUND
235:             uint256 creditSplit, // <= FOUND
236:             uint256 guildSplit, // <= FOUND
237:             uint256 otherSplit, // <= FOUND
238:             address otherRecipient
239:         )
240:     
```

*GitHub* : [234](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L234-L237)
### [NC-99]<a name="nc-99"></a> Using delete instead of setting mapping to 0 saves gas

*There are 1 instance(s) of this issue:*

```310:                 termSurplusBuffer[gauge] = 0; // <= FOUND
```

*GitHub* : [310](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L310-L310)
### [NC-100]<a name="nc-100"></a> Long numbers should include underscores to improve readability and prevent typos
A large number such as 2000000 is far more readable as 2_000_000, this will help prevent unintended bugs in the code

*There are 4 instance(s) of this issue:*

```36: 
40:     uint256 public constant POLL_DURATION_BLOCKS = 46523;  // <= FOUND
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L40-L40)

```132: 
133:         require(
134:             
135:             params.maxDelayBetweenPartialRepay < 31557601,  // <= FOUND
136:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
137:         );
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L135-L135)

```231:         return 2425847;  // <= FOUND
```

*GitHub* : [231](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L231-L231)

```29: 
31:     uint256 public constant YEAR = 31557600; // <= FOUND
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L31-L31)
### [NC-101]<a name="nc-101"></a> Consider using ERC20Capped

*There are 6 instance(s) of this issue:*

```509:     function _mint(address account, uint256 amount) internal virtual override { // <= FOUND
510:         
511:         ERC20._mint(account, amount); // <= FOUND
512: 
513:         
514:         RebasingState memory _rebasingState = rebasingState[account];
515:         if (_rebasingState.isRebasing == 1) {
516:             
517:             uint256 _rebasingSharePrice = rebasingSharePrice();
518:             uint256 rawBalance = ERC20.balanceOf(account);
519:             uint256 rebasedBalance = _shares2balance(
520:                 _rebasingState.nShares,
521:                 _rebasingSharePrice,
522:                 amount,
523:                 rawBalance
524:             );
525: 
526:             
527:             uint256 sharesAfter = _balance2shares(
528:                 rebasedBalance,
529:                 _rebasingSharePrice
530:             );
531:             uint256 sharesReceived = sharesAfter - _rebasingState.nShares;
532:             rebasingState[account] = RebasingState({
533:                 isRebasing: 1,
534:                 nShares: uint248(sharesAfter)
535:             });
536:             updateTotalRebasingShares(
537:                 _rebasingSharePrice,
538:                 int256(sharesReceived)
539:             );
540: 
541:             
542:             uint256 mintAmount = rebasedBalance - rawBalance;
543:             if (mintAmount != 0) {
544:                 ERC20._mint(account, mintAmount); // <= FOUND
545:                 decreaseUnmintedRebaseRewards(mintAmount);
546:                 emit RebaseReward(account, block.timestamp, mintAmount);
547:             }
548:         }
549:     }
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L544)

```35:     function mint( // <= FOUND
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) {
39:         _mint(to, amount); // <= FOUND
40:     }
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L39)

```83:     function _mint( // <= FOUND
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) {
87:         ERC20RebaseDistributor._mint(account, amount); // <= FOUND
88:     }
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L87)

```268:     function mint( // <= FOUND
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {
272:         _mint(to, amount); // <= FOUND
273:     }
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L272)

```103:     function mint( // <= FOUND
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L110)

```49:     function mint( // <= FOUND
50:         address to,
51:         uint256 amount
52:     ) external onlyCoreRole(role) whenNotPaused {
53:         _depleteBuffer(amount); 
54:         IERC20Mintable(token).mint(to, amount);  // <= FOUND
55:     }
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L49-L54)
### [NC-102]<a name="nc-102"></a> Consider using a format prettier or forge fmt
Some comments use // X and others //X Amend comments to use only use // X or //X consistently such style inconsistencies can be resolved by running the project through a format prettier or by using forge fmt.

*There are 4 instance(s) of this issue:*

```25: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20Gauges.sol
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L25-L25)

```19: //code4rena.com/reports/2022-04-xtribe/
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L19-L19)

```20: //consensys.net/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L20-L20)

```17: //github.com/fei-protocol/flywheel-v2/blob/main/src/token/ERC20MultiVotes.sol
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L17-L17)
### [NC-103]<a name="nc-103"></a> Avoid defining a function in a single line including it's contents

*There are 1 instance(s) of this issue:*

```11:     function mint(address to, uint256 amount) external; // <= FOUND
```

*GitHub* : [11](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L11-L11)
### [NC-104]<a name="nc-104"></a> Use 'using' keyword when using specific imports rather than calling the specific import directly
In Solidity, the `using` keyword can streamline the use of library functions for specific types. Instead of calling library functions directly with their full import paths, you can declare a library once with `using` for a specific type. This approach makes your code more readable and concise. For example, instead of `LibraryName.functionName(variable)`, you would first declare `using LibraryName for TypeName;` at the contract level. After this, you can call library functions directly on variables of `TypeName` like `variable.functionName()`. This method not only enhances code clarity but also promotes cleaner and more organized code, especially when multiple functions from the same library are used frequently.

*There are 124 instance(s) of this issue:*

```15:         
16:         
17:         _grantRole(CoreRoles.GOVERNOR, msg.sender); // <= FOUND 'CoreRoles.'
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L15-L17)

```18: 
19:         
20:         _setRoleAdmin(CoreRoles.GOVERNOR, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L18-L20)

```19:         _setRoleAdmin(CoreRoles.GUARDIAN, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L19-L19)

```20:         _setRoleAdmin(CoreRoles.CREDIT_MINTER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L20-L20)

```21:         _setRoleAdmin(CoreRoles.RATE_LIMITED_CREDIT_MINTER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [21](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L21-L21)

```22:         _setRoleAdmin(CoreRoles.GUILD_MINTER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [22](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L22-L22)

```23:         _setRoleAdmin(CoreRoles.RATE_LIMITED_GUILD_MINTER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L23-L23)

```24:         _setRoleAdmin(CoreRoles.GAUGE_ADD, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L24-L24)

```25:         _setRoleAdmin(CoreRoles.GAUGE_REMOVE, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L25-L25)

```26:         _setRoleAdmin(CoreRoles.GAUGE_PARAMETERS, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L26-L26)

```27:         _setRoleAdmin(CoreRoles.GAUGE_PNL_NOTIFIER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [27](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L27-L27)

```28:         _setRoleAdmin(
29:             CoreRoles.GUILD_GOVERNANCE_PARAMETERS, // <= FOUND 'CoreRoles.'
30:             CoreRoles.GOVERNOR // <= FOUND 'CoreRoles.'
31:         );
```

*GitHub* : [28](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L28-L30)

```32:         _setRoleAdmin(
33:             CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW, // <= FOUND 'CoreRoles.'
34:             CoreRoles.GOVERNOR // <= FOUND 'CoreRoles.'
35:         );
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L32-L34)

```36:         _setRoleAdmin(
37:             CoreRoles.CREDIT_GOVERNANCE_PARAMETERS, // <= FOUND 'CoreRoles.'
38:             CoreRoles.GOVERNOR // <= FOUND 'CoreRoles.'
39:         );
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L36-L38)

```40:         _setRoleAdmin(CoreRoles.CREDIT_REBASE_PARAMETERS, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L40-L40)

```41:         _setRoleAdmin(CoreRoles.TIMELOCK_PROPOSER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L41-L41)

```42:         _setRoleAdmin(CoreRoles.TIMELOCK_EXECUTOR, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [42](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L42-L42)

```43:         _setRoleAdmin(CoreRoles.TIMELOCK_CANCELLER, CoreRoles.GOVERNOR); // <= FOUND 'CoreRoles.'
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L43-L43)

```50: 
55:     function createRole(
56:         bytes32 role,
57:         bytes32 adminRole
58:     ) external onlyRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L50-L58)

```39: 
45:     function setCore(
46:         address newCore
47:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L39-L47)

```57: 
59:     function pause() public onlyCoreRole(CoreRoles.GUARDIAN) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L57-L59)

```62: 
64:     function unpause() public onlyCoreRole(CoreRoles.GUARDIAN) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [62](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L62-L64)

```87: 
92:     function emergencyAction(
93:         Call[] calldata calls
94:     )
95:         external
96:         payable
97:         onlyCoreRole(CoreRoles.GOVERNOR) // <= FOUND 'CoreRoles.'
98:         returns (bytes[] memory returnData)
99:     {
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L97)

```78: 
84:     function setVotingDelay(
85:         uint256 newVotingDelay
86:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L86)

```85: 
87:     function setVotingPeriod(
88:         uint256 newVotingPeriod
89:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L85-L89)

```92: 
94:     function setProposalThreshold(
95:         uint256 newProposalThreshold
96:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L92-L96)

```99: 
101:     function setQuorum(
102:         uint256 newQuorum
103:     ) public onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L99-L103)

```110: 
116:     function guardianCancel(
117:         address[] memory targets,
118:         uint256[] memory values,
119:         bytes[] memory calldatas,
120:         bytes32 descriptionHash
121:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L121)

```78: 
80:     function setQuorum(
81:         uint256 _quorum
82:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L78-L82)

```187: 
188:         
189:         core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term); // <= FOUND 'CoreRoles.'
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L187-L189)

```188:         core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term); // <= FOUND 'CoreRoles.'
```

*GitHub* : [188](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L188-L188)

```92: 
94:     function allowImplementation(
95:         address implementation,
96:         bool allowed
97:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L92-L97)

```249:         calldatas[1] = abi.encodeWithSelector(
250:             AccessControl.grantRole.selector, // <= FOUND 'AccessControl.'
251:             CoreRoles.RATE_LIMITED_CREDIT_MINTER, // <= FOUND 'CoreRoles.'
252:             term
253:         );
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L249-L251)

```257:         calldatas[2] = abi.encodeWithSelector(
258:             AccessControl.grantRole.selector, // <= FOUND 'AccessControl.'
259:             CoreRoles.GAUGE_PNL_NOTIFIER, // <= FOUND 'CoreRoles.'
260:             term
261:         );
```

*GitHub* : [257](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L257-L259)

```156: 
158:     function initializeReferences(
159:         address _credit,
160:         address _guild,
161:         address _psm
162:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L162)

```179: 
181:     function setMinBorrow(
182:         uint256 newValue
183:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [179](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L179-L183)

```187: 
189:     function setGaugeWeightTolerance(
190:         uint256 newValue
191:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L187-L191)

```195: 
197:     function setProfitSharingConfig(
198:         uint256 surplusBufferSplit,
199:         uint256 creditSplit,
200:         uint256 guildSplit,
201:         uint256 otherSplit,
202:         address otherRecipient
203:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L203)

```267: 
269:     function withdrawFromSurplusBuffer(
270:         address to,
271:         uint256 amount
272:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L272)

```278: 
280:     function withdrawFromTermSurplusBuffer(
281:         address term,
282:         address to,
283:         uint256 amount
284:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L284)

```292: 
296:     function notifyPnL(
297:         address gauge,
298:         int256 amount
299:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L299)

```93: 
95:     function updateTimelock(
96:         address newTimelock
97:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L93-L97)

```35: 
37:     function mint(
38:         address to,
39:         uint256 amount
40:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L40)

```43: 
45:     function setMaxDelegates(
46:         uint256 newMax
47:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L47)

```50: 
52:     function setContractExceedMaxDelegates(
53:         address account,
54:         bool canExceedMax
55:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L55)

```58: 
60:     function forceEnterRebase(
61:         address account
62:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [58](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L58-L62)

```69: 
71:     function forceExitRebase(
72:         address account
73:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L69-L73)

```59: 
65:     function setMaxDelegates(
66:         uint256 newMax
67:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L67)

```66: 
68:     function setContractExceedMaxDelegates(
69:         address account,
70:         bool canExceedMax
71:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L71)

```76: 
80:     function addGauge(
81:         uint256 _type,
82:         address gauge
83:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L83)

```83: 
84:     function removeGauge(
85:         address gauge
86:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L83-L86)

```89: 
90:     function setMaxGauges(
91:         uint256 max
92:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L92)

```95: 
96:     function setCanExceedMaxGauges(
97:         address who,
98:         bool can
99:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L99)

```175: 
177:     function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L175-L177)

```197: 
199:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L197-L199)

```268: 
274:     function mint(
275:         address to,
276:         uint256 amount
277:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L277)

```77:         
78:         require(
79:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender), // <= FOUND 'CoreRoles.'
80:             "AuctionHouse: invalid caller"
81:         );
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L77-L79)

```695: 
701:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [695](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L695-L701)

```829: 
832:     function setAuctionHouse(
833:         address _newValue
834:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [829](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L829-L834)

```846: 
849:     function setHardCap(
850:         uint256 _newValue
851:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [846](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L846-L851)

```149: 
153:     function setRedemptionsPaused(
154:         bool paused
155:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L149-L155)

```319: 
322:     function setMintRatio(
323:         uint256 _mintRatio
324:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L319-L324)

```328: 
331:     function setRewardRatio(
332:         uint256 _rewardRatio
333:     ) external onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [328](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L328-L333)

```61: 
64:     function setRateLimitPerSecond(
65:         uint128 newRateLimitPerSecond
66:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L61-L66)

```75: 
78:     function setBufferCap(
79:         uint128 newBufferCap
80:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) { // <= FOUND 'CoreRoles.'
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L75-L80)

```211: 
212:         
213:         return Governor.propose(targets, values, calldatas, description); // <= FOUND 'Governor.'
```

*GitHub* : [211](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L211-L213)

```383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector, // <= FOUND 'TimelockController.'
385:             timelockId
386:         );
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L383-L384)

```240:         calldatas[0] = abi.encodeWithSelector(
241:             GuildToken.addGauge.selector, // <= FOUND 'GuildToken.'
242:             gaugeType,
243:             term
244:         );
```

*GitHub* : [240](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L240-L241)

```56:     
57:     event TermCreated(
58:         uint256 indexed when,
59:         address indexed implementation,
60:         address indexed term,
61:         LendingTerm.LendingTermParams params // <= FOUND 'LendingTerm.'
62:     );
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L56-L61)

```63: 
64:     constructor(
65:         LendingTerm.LendingTermReferences memory _lendingTermReferences, // <= FOUND 'LendingTerm.'
66:         uint256 _gaugeType,
67:         address _core,
68:         address _timelock,
69:         uint256 initialVotingDelay,
70:         uint256 initialVotingPeriod,
71:         uint256 initialProposalThreshold,
72:         uint256 initialQuorum
73:     )
74:         GuildGovernor(
75:             _core,
76:             _timelock,
77:             _lendingTermReferences.guildToken,
78:             initialVotingDelay,
79:             initialVotingPeriod,
80:             initialProposalThreshold,
81:             initialQuorum
82:         )
83:     {
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L65)

```105: 
107:     function createTerm(
108:         address implementation,
109:         LendingTerm.LendingTermParams calldata params // <= FOUND 'LendingTerm.'
110:     ) external returns (address) {
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L109)

```154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({ // <= FOUND 'LendingTerm.'
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L154-L156)

```83: 
84:         
85:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId); // <= FOUND 'LendingTerm.'
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L83-L85)

```153: 
154:         address term = Clones.clone(implementation); // <= FOUND 'Clones.'
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L153-L154)

```114:         
115:         (bool success, bytes memory returned) = params.collateralToken.call(
116:             abi.encodeWithSelector(IERC20.totalSupply.selector) // <= FOUND 'IERC20.'
117:         );
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L114-L116)

```230:         description = string.concat(
231:             "[",
232:             Strings.toString(block.number), // <= FOUND 'Strings.'
233:             "]",
234:             " Enable term ",
235:             Strings.toHexString(term) // <= FOUND 'Strings.'
236:         );
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L230-L235)

```290:         uint256 balance = ERC20.balanceOf(account); // <= FOUND 'ERC20.'
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L290-L290)

```312:         uint256 rawBalance = ERC20.balanceOf(account); // <= FOUND 'ERC20.'
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L312-L312)

```324:             ERC20._mint(account, mintAmount); // <= FOUND 'ERC20.'
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L324-L324)

```431:             return ERC20.balanceOf(account); // <= FOUND 'ERC20.'
```

*GitHub* : [431](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L431-L431)

```433:             return
434:                 _shares2balance(
435:                     _rebasingState.nShares,
436:                     rebasingSharePrice(),
437:                     0,
438:                     ERC20.balanceOf(account) // <= FOUND 'ERC20.'
439:                 );
```

*GitHub* : [433](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L433-L438)

```445:         return ERC20.totalSupply() + unmintedRebaseRewards(); // <= FOUND 'ERC20.'
```

*GitHub* : [445](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L445-L445)

```452:         return ERC20.totalSupply() + __unmintedRebaseRewards.targetValue; // <= FOUND 'ERC20.'
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L452-L452)

```468:             balanceBefore = ERC20.balanceOf(account); // <= FOUND 'ERC20.'
```

*GitHub* : [468](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L468-L468)

```478:                 ERC20._mint(account, mintAmount); // <= FOUND 'ERC20.'
```

*GitHub* : [478](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L478-L478)

```486: 
487:         
488:         ERC20._burn(account, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [486](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L486-L488)

```511:         
512:         ERC20._mint(account, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [511](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L511-L512)

```518:             uint256 rawBalance = ERC20.balanceOf(account); // <= FOUND 'ERC20.'
```

*GitHub* : [518](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L518-L518)

```561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender); // <= FOUND 'ERC20.'
```

*GitHub* : [561](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L561-L561)

```576:                 ERC20._mint(msg.sender, mintAmount); // <= FOUND 'ERC20.'
```

*GitHub* : [576](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L576-L576)

```584: 
585:         
586:         bool success = ERC20.transfer(to, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [584](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L584-L586)

```605:             
606:             uint256 rawToBalanceAfter = ERC20.balanceOf(to); // <= FOUND 'ERC20.'
```

*GitHub* : [605](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L605-L606)

```628:                 ERC20._mint(to, mintAmount); // <= FOUND 'ERC20.'
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L628-L628)

```655:         uint256 fromBalanceBefore = ERC20.balanceOf(from); // <= FOUND 'ERC20.'
```

*GitHub* : [655](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L655-L655)

```670:                 ERC20._mint(from, mintAmount); // <= FOUND 'ERC20.'
```

*GitHub* : [670](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L670-L670)

```678: 
679:         
680:         bool success = ERC20.transferFrom(from, to, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [678](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L678-L680)

```285:         ERC20._burn(from, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [285](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L285-L285)

```299:         return ERC20.transfer(to, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [299](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L299-L299)

```314:         return ERC20.transferFrom(from, to, amount); // <= FOUND 'ERC20.'
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L314-L314)

```36:     using EnumerableSet for EnumerableSet.AddressSet; // <= FOUND 'EnumerableSet.'
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L36-L36)

```86: 
87:     mapping(address => EnumerableSet.AddressSet) internal _userGauges; // <= FOUND 'EnumerableSet.'
```

*GitHub* : [86](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L86-L87)

```88: 
89:     EnumerableSet.AddressSet internal _gauges; // <= FOUND 'EnumerableSet.'
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L88-L89)

```91: 
93:     EnumerableSet.AddressSet internal _deprecatedGauges; // <= FOUND 'EnumerableSet.'
```

*GitHub* : [91](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L91-L93)

```210: 
212:     mapping(address => EnumerableSet.AddressSet) private _delegates; // <= FOUND 'EnumerableSet.'
```

*GitHub* : [210](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L210-L212)

```110:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
111:             lastValue: uint224(START_REBASING_SHARE_PRICE), 
112:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
113:             targetValue: uint224(START_REBASING_SHARE_PRICE) 
114:         });
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L110-L112)

```120:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
121:             lastValue: 0,
122:             targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
123:             targetValue: 0
124:         });
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L120-L122)

```191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),  // <= FOUND 'SafeCastLib.'
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),  // <= FOUND 'SafeCastLib.'
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
```

*GitHub* : [191](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L191-L193)

```197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
200:                 targetValue: 0
201:             });
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L197-L199)

```219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),  // <= FOUND 'SafeCastLib.'
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice),  // <= FOUND 'SafeCastLib.'
221:                 targetTimestamp: val.targetTimestamp, 
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice)  // <= FOUND 'SafeCastLib.'
223:             });
```

*GitHub* : [219](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L219-L222)

```232:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),  // <= FOUND 'SafeCastLib.'
233:             lastValue: SafeCastLib.safeCastTo224( // <= FOUND 'SafeCastLib.'
234:                 _unmintedRebaseRewards - amount
235:             ), 
236:             targetTimestamp: val.targetTimestamp, 
237:             targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount)  // <= FOUND 'SafeCastLib.'
238:         });
```

*GitHub* : [232](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L232-L237)

```370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice), // <= FOUND 'SafeCastLib.'
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp), // <= FOUND 'SafeCastLib.'
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice) // <= FOUND 'SafeCastLib.'
374:             });
```

*GitHub* : [370](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L370-L373)

```379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), // <= FOUND 'SafeCastLib.'
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards), // <= FOUND 'SafeCastLib.'
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp), // <= FOUND 'SafeCastLib.'
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount) // <= FOUND 'SafeCastLib.'
384:             });
```

*GitHub* : [379](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L379-L383)

```140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp), // <= FOUND 'SafeCastLib.'
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss), // <= FOUND 'SafeCastLib.'
142:             profitIndex: SafeCastLib.safeCastTo160( // <= FOUND 'SafeCastLib.'
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount), // <= FOUND 'SafeCastLib.'
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount) // <= FOUND 'SafeCastLib.'
150:         });
```

*GitHub* : [140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L140-L149)

```181: 
182:         userStake.credit -= SafeCastLib.safeCastTo128(amount); // <= FOUND 'SafeCastLib.'
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L181-L182)

```182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount); // <= FOUND 'SafeCastLib.'
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L182-L182)

```267: 
268:             
269:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex); // <= FOUND 'SafeCastLib.'
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L267-L269)

```307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter); // <= FOUND 'SafeCastLib.'
```

*GitHub* : [307](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L307-L307)

```87:         ERC20RebaseDistributor._mint(account, amount); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L87-L87)

```95:         ERC20RebaseDistributor._burn(account, amount); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L95-L95)

```101:         return ERC20RebaseDistributor.balanceOf(account); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L101-L101)

```110:         return ERC20RebaseDistributor.totalSupply(); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L110-L110)

```122:         return ERC20RebaseDistributor.transfer(to, amount); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L122-L122)

```135:         return ERC20RebaseDistributor.transferFrom(from, to, amount); // <= FOUND 'ERC20RebaseDistributor.'
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L135-L135)

```85:         return
86:             Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap); // <= FOUND 'Math.'
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L85-L86)
### [NC-105]<a name="nc-105"></a> package.json name variable should only consist of lowercase letters and underscores

*There are 1 instance(s) of this issue:*

```{
"name": "@src/ethereum-credit-guild", // <= FOUND
"version": "1.0.0",
"private": true,
"description": "",
"files": [],
"scripts": {
"prepare": "husky install",
"setup": "curl -L https://foundry.paradigm.xyz | bash && foundryup",
"compile": "forge build",
"clean": "forge clean",
"slither": "slither .",
"test": "npm run test:unit",
"test:unit": "forge test --match-path './test/unit/**' -vvv",
"test:proposals": "forge test --match-path './test/proposals/**' --fork-url $ETH_RPC_URL -vvv",
"test:integration": "forge test --match-path './test/integration/**' --fork-url $ETH_RPC_URL -vvv",
"coverage": "forge coverage --fork-url $ETH_RPC_URL --match-path './test/**' --report lcov --report summary",
"coverage:unit": "forge coverage --match-path './test/unit/**' --report lcov --report summary",
"coverage:integration": "forge coverage --match-path './test/integration/**' --fork-url $ETH_RPC_URL --report lcov --report summary",
"fork": "anvil --fork-url $ETH_RPC_URL --block-time 10 --chain-id 1337",
"deploy:local": "ETH_PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 forge script scripts/DeployProposal.s.sol:DeployProposal -vvvv --rpc-url http://127.0.0.1:8545 --broadcast",
"prettier": "npx prettier --check 'src/**/*.sol'",
"prettier:fix": "npx prettier --write 'src/**/*.sol'"
},
"authors": "elliotfriedman,eswak,joeysantoro,onetruekirk",
"dependencies": {
"@openzeppelin/contracts": "4.9.3"
},
"devDependencies": {
"husky": "7.0.4",
"lint-staged": "12.2.0",
"prettier": "2.5.1",
"prettier-plugin-solidity": "1.0.0",
"solhint": "2.0.0",
"solhint-plugin-prettier": "0.0.5"
},
"lint-staged": {
"*.{sol}": [
  "npx prettier --config .prettierrc 'src/**/*.sol' --write"
]
}
}
```

    *GitHub* :
### [NC-106]<a name="nc-106"></a> package.json missing/empty description

*There are 1 instance(s) of this issue:*

```{
"name": "@src/ethereum-credit-guild",
"version": "1.0.0",
"private": true,
"description": "", // <= FOUND
"files": [],
"scripts": {
"prepare": "husky install",
"setup": "curl -L https://foundry.paradigm.xyz | bash && foundryup",
"compile": "forge build",
"clean": "forge clean",
"slither": "slither .",
"test": "npm run test:unit",
"test:unit": "forge test --match-path './test/unit/**' -vvv",
"test:proposals": "forge test --match-path './test/proposals/**' --fork-url $ETH_RPC_URL -vvv",
"test:integration": "forge test --match-path './test/integration/**' --fork-url $ETH_RPC_URL -vvv",
"coverage": "forge coverage --fork-url $ETH_RPC_URL --match-path './test/**' --report lcov --report summary",
"coverage:unit": "forge coverage --match-path './test/unit/**' --report lcov --report summary",
"coverage:integration": "forge coverage --match-path './test/integration/**' --fork-url $ETH_RPC_URL --report lcov --report summary",
"fork": "anvil --fork-url $ETH_RPC_URL --block-time 10 --chain-id 1337",
"deploy:local": "ETH_PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 forge script scripts/DeployProposal.s.sol:DeployProposal -vvvv --rpc-url http://127.0.0.1:8545 --broadcast",
"prettier": "npx prettier --check 'src/**/*.sol'",
"prettier:fix": "npx prettier --write 'src/**/*.sol'"
},
"authors": "elliotfriedman,eswak,joeysantoro,onetruekirk",
"dependencies": {
"@openzeppelin/contracts": "4.9.3"
},
"devDependencies": {
"husky": "7.0.4",
"lint-staged": "12.2.0",
"prettier": "2.5.1",
"prettier-plugin-solidity": "1.0.0",
"solhint": "2.0.0",
"solhint-plugin-prettier": "0.0.5"
},
"lint-staged": {
"*.{sol}": [
  "npx prettier --config .prettierrc 'src/**/*.sol' --write"
]
}
}
```

    *GitHub* :
### [NC-107]<a name="nc-107"></a> Avoid revertible function calls in a constructor
It is advisable to to perform validation within the constructor itself rather than in function calls it makes. This is because contract deployement may be performed through a frontend or manually so by having all of the validation conditions viewable in a single place allows for greater transparency during deployment for both the team and project users.

*There are 1 instance(s) of this issue:*

```40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) {
45:         lastBufferUsedTime = block.timestamp.safeCastTo32();
46: 
47:         _setBufferCap(_bufferCap);
48:         bufferStored = _bufferCap;
49: 
50:         require(
51:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
52:             "RateLimited: rateLimitPerSecond too high"
53:         );
54:         _setRateLimitPerSecond(_rateLimitPerSecond); // <= FOUND
55: 
56:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
57:     }
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L54-L54)
### [NC-108]<a name="nc-108"></a> Avoid declaring variables with the names of defined functions within the project
Having such variables can create confusion in both developers and in users of the project. Consider renaming these variables to improve code clarity.

*There are 55 instance(s) of this issue:*

```294:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager) // <= FOUND
295:             .totalBorrowedCredit();
```

*GitHub* : [294](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L294-L294)

```294: 
295:         
296:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager) // <= FOUND
297:             .totalBorrowedCredit();
```

*GitHub* : [296](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L296-L296)

```447:             uint256 delegateVotes = _delegatesVotesCount[user][delegatee]; // <= FOUND
```

*GitHub* : [447](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L447-L447)

```88: 
89:     constructor(
90:         address _core,
91:         address _profitManager,
92:         address _credit,
93:         address _guild,
94:         address _rlgm,
95:         uint256 _mintRatio, // <= FOUND
96:         uint256 _rewardRatio
97:     ) CoreRef(_core) {
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L95-L95)

```133: 
134:         
135:         uint256 _mintRatio = mintRatio; // <= FOUND
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L135-L135)

```319: 
322:     function setMintRatio(
323:         uint256 _mintRatio // <= FOUND
324:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
```

*GitHub* : [323](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L323-L323)

```322:         uint256 mintAmount = rebasedBalance - rawBalance; // <= FOUND
```

*GitHub* : [322](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L322-L322)

```476:             uint256 mintAmount = rebasedBalance - balanceBefore; // <= FOUND
```

*GitHub* : [476](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L476-L476)

```542: 
543:             
544:             uint256 mintAmount = rebasedBalance - rawBalance; // <= FOUND
```

*GitHub* : [544](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L544-L544)

```574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore; // <= FOUND
```

*GitHub* : [574](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L574-L574)

```626: 
627:             
628:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter; // <= FOUND
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L628-L628)

```226:             uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight)); // <= FOUND
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L226-L226)

```307:         uint256 debtCeilingBefore = (totalBorrowedCredit * // <= FOUND
308:             toleratedGaugeWeight) / totalWeight;
```

*GitHub* : [307](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L307-L307)

```25: 
28:     event LoanOpen(
29:         uint256 indexed when,
30:         bytes32 indexed loanId,
31:         address indexed borrower,
32:         uint256 collateralAmount,
33:         uint256 borrowAmount // <= FOUND
34:     );
```

*GitHub* : [33](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L33-L33)

```77:         uint256 borrowTime;  // <= FOUND
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L77-L77)

```78:         uint256 borrowAmount;  // <= FOUND
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L78-L78)

```79:         uint256 borrowCreditMultiplier;  // <= FOUND
```

*GitHub* : [79](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L79-L79)

```202:         uint256 borrowTime = loan.borrowTime; // <= FOUND
```

*GitHub* : [202](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L202-L202)

```217: 
218:         
219:         uint256 borrowAmount = loan.borrowAmount; // <= FOUND
```

*GitHub* : [219](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L219-L219)

```339: 
341:     function _borrow(
342:         address borrower, // <= FOUND
343:         uint256 borrowAmount, // <= FOUND
344:         uint256 collateralAmount
345:     ) internal returns (bytes32 loanId) {
```

*GitHub* : [342](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L342-L343)

```438: 
440:     function borrow(
441:         uint256 borrowAmount, // <= FOUND
442:         uint256 collateralAmount
443:     ) external whenNotPaused returns (bytes32 loanId) {
```

*GitHub* : [441](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L441-L441)

```202: 
203:         
204:         uint256 borrowTime = loan.borrowTime; // <= FOUND
```

*GitHub* : [204](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L204-L204)

```217:         uint256 borrowAmount = loan.borrowAmount; // <= FOUND
```

*GitHub* : [217](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L217-L217)

```711:         uint256 borrowAmount = loans[loanId].borrowAmount; // <= FOUND
```

*GitHub* : [711](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L711-L711)

```54:     
55:     event LoanPartialRepay(
56:         uint256 indexed when,
57:         bytes32 indexed loanId,
58:         address indexed repayer,
59:         uint256 repayAmount // <= FOUND
60:     );
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L59-L59)

```151:             uint256 _callDebt = auctions[loanId].callDebt;  // <= FOUND
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L151-L151)

```12:     
13:     event AuctionStart(
14:         uint256 indexed when,
15:         bytes32 indexed loanId,
16:         address collateralToken, // <= FOUND
17:         uint256 collateralAmount,
18:         uint256 callDebt // <= FOUND
19:     );
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L16-L18)

```45:         uint256 callDebt; // <= FOUND
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L45-L45)

```75: 
80:     function startAuction(bytes32 loanId, uint256 callDebt) external { // <= FOUND
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L80-L80)

```82:         uint256 callTime;  // <= FOUND
```

*GitHub* : [82](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L82-L82)

```83:         uint256 callDebt;  // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L83-L83)

```19: 
20:     constructor(address coreAddress) { // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L20-L20)

```218: 
225:     function delegatesVotesCount(
226:         address delegator,
227:         address delegatee // <= FOUND
228:     ) public view virtual returns (uint256) {
```

*GitHub* : [227](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L227-L227)

```242: 
249:     function containsDelegate(
250:         address delegator,
251:         address delegatee // <= FOUND
252:     ) public view returns (bool) {
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L251-L251)

```264: 
271:     function incrementDelegation(
272:         address delegatee, // <= FOUND
273:         uint256 amount
274:     ) public virtual {
```

*GitHub* : [272](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L272-L272)

```276: 
282:     function undelegate(address delegatee, uint256 amount) public virtual { // <= FOUND
```

*GitHub* : [282](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L282-L282)

```317: 
318:     function _incrementDelegation(
319:         address delegator,
320:         address delegatee, // <= FOUND
321:         uint256 amount
322:     ) internal virtual {
```

*GitHub* : [320](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L320-L320)

```344: 
345:     function _undelegate(
346:         address delegator,
347:         address delegatee, // <= FOUND
348:         uint256 amount
349:     ) internal virtual {
```

*GitHub* : [347](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L347-L347)

```363: 
364:     function _writeCheckpoint(
365:         address delegatee, // <= FOUND
366:         function(uint256, uint256) view returns (uint256) op,
367:         uint256 delta
368:     ) private {
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L365-L365)

```446:             address delegatee = delegateList[i]; // <= FOUND
```

*GitHub* : [446](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L446-L446)

```467: 
472:     bytes32 public constant DELEGATION_TYPEHASH =
473:         keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)"); // <= FOUND
```

*GitHub* : [473](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L473-L473)

```471: 
473:     function delegateBySig(
474:         address delegatee, // <= FOUND
475:         uint256 nonce,
476:         uint256 expiry,
477:         uint8 v,
478:         bytes32 r,
479:         bytes32 s
480:     ) public {
```

*GitHub* : [474](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L474-L474)

```725: 
727:     function onBid(
728:         bytes32 loanId,
729:         address bidder, // <= FOUND
730:         uint256 collateralToBorrower,
731:         uint256 collateralToBidder,
732:         uint256 creditFromBidder
733:     ) external {
```

*GitHub* : [729](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L729-L729)

```20:     
21:     event AuctionEnd(
22:         uint256 indexed when,
23:         bytes32 indexed loanId,
24:         address collateralToken, // <= FOUND
25:         uint256 collateralSold,
26:         uint256 debtRecovered
27:     );
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L24-L24)

```116:         
117:         address collateralToken; // <= FOUND
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L117-L117)

```76:         address borrower;  // <= FOUND
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L76-L76)

```448: 
452:     function _addCollateral(
453:         address borrower, // <= FOUND
454:         bytes32 loanId,
455:         uint256 collateralToAdd
456:     ) internal {
```

*GitHub* : [453](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L453-L453)

```490: 
495:     function _partialRepay(
496:         address repayer, // <= FOUND
497:         bytes32 loanId,
498:         uint256 debtToRepay
499:     ) internal {
```

*GitHub* : [496](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L496-L496)

```567: 
569:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
```

*GitHub* : [569](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L569-L569)

```81:         address caller;  // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L81-L81)

```634: 
637:     function _call(
638:         address caller, // <= FOUND
639:         bytes32 loanId,
640:         address _auctionHouse
641:     ) internal {
```

*GitHub* : [638](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L638-L638)

```149: 
153:     function setRedemptionsPaused(
154:         bool paused // <= FOUND
155:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L154-L154)

```199: 
200:         
201:         
202:         
203:         
204:         
205:         bool isGauge = GuildToken(guildToken).isGauge(term); // <= FOUND
```

*GitHub* : [205](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L205-L205)

```80:         
81:         bytes callData; // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L81-L81)

```99:             bytes calldata callData = calls[i].callData; // <= FOUND
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L99-L99)
### [NC-109]<a name="nc-109"></a> Add inline comments for unnamed variables in function declarations
Unnamed variables in function declarations can confuse developers. To enhance clarity, add inline comments next to each unnamed variable. E.g address, -> address /* to */,

*There are 1 instance(s) of this issue:*

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op, // <= FOUND
366:         uint256 delta
367:     ) private 
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L365-L365)
### [NC-110]<a name="nc-110"></a> Public state variables should include natspec comments
State variables in Solidity contracts are essential for defining the state of the contract. Including comments for these variables improves code readability and maintainability by providing context and explaining their purpose. This practice aids future developers or auditors in understanding the code, thus reducing the likelihood of misinterpretation or errors.

*There are 3 instance(s) of this issue:*

```    /// shall be redistributed to holders through a savings rate or another mechanism.
uint256 public creditMultiplier = 1e18; // <= FOUND
```

  *GitHub* :

```    uint256 public gaugeWeightTolerance = 1.2e18; // 120% // <= FOUND
constructor(address _core) CoreRef(_core) {
```

  *GitHub* :

```    /// interpolated linearly over a period of DISTRIBUTION_PERIOD seconds after a distribution.
uint256 public constant DISTRIBUTION_PERIOD = 30 days; // <= FOUND
```

  *GitHub* :
### [NC-111]<a name="nc-111"></a> Incorrect NatSpec Syntax
In Solidity, just like in most other programming languages, regular comments serve to make code more understandable for developers. These are usually denoted by `//` for single line comments, or `/* ... */` for multi-line comments, and are ignored by the compiler.

On the other hand, NatSpec comments in Solidity, denoted by `///` for single-line comments, or `/** ... */` for multi-line comments, serve a different purpose. Besides aiding developer comprehension, they also form a part of the contract's interface, as they can be parsed and used by tools such as automated documentation generators or IDEs to provide users with details about the contract's functions, parameters and behavior. NatSpec comments can also be retrieved via JSON interfaces, and as such, they're included in the contract's ABI. 

Thus, using `///` and `/** ... */` appropriately ensures not only proper documentation for developers, but also helps create a richer and more informative interface for users and external tools interacting with your contract.

*There are 1 instance(s) of this issue:*

```252: // @dev all proposals that are in this Governor's state should have been created // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L252-L252)
### [NC-112]<a name="nc-112"></a> Use @inheritdoc rather than using a non-standard annotation
The `@inheritdoc` annotation in Solidity is used to copy documentation from the base function to the inheriting function. This makes the code cleaner and avoids redundancy in documentation. On the other hand, using non-standard annotations like `@dev see {file_path}` might not be recognized by documentation tools and could lead to confusion or incomplete documentation. By using `@inheritdoc`, you adhere to standard practices, ensuring that the documentation is correctly processed and that the inherited behavior is clearly and accurately represented in development tools that understand this standard notation.

*There are 4 instance(s) of this issue:*

```50: /**
51:      * @dev See {IGovernor-COUNTING_MODE}. // <= FOUND
52:      */
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L50-L51)

```50: /**
51:      * @dev See {IGovernor-hasVoted}. // <= FOUND
52:      */
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L50-L51)

```50: /**
51:      * @dev See {Governor-_quorumReached}. // <= FOUND
52:      */
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L50-L51)

```50: /**
51:      * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo). // <= FOUND
52:      */
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L50-L51)
### [NC-113]<a name="nc-113"></a> No @inheritdoc on override functions
In Solidity, using `@inheritdoc` on overridden functions is crucial for maintaining comprehensive and understandable NatSpec documentation. It ensures that when a function overrides an external interface or contract function, the original documentation is preserved. This not only helps developers understand the purpose and usage of the function but also aids in keeping documentation consistent and accurate across different versions of the codebase. Neglecting to use `@inheritdoc` can lead to incomplete or confusing documentation, making code maintenance and usage more challenging.

*There are 27 instance(s) of this issue:*

```57:     function quorum(
58:         uint256 
59:     ) public view override returns (uint256)  // <= FOUND
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L57-L59)

```78:     function setVotingDelay(
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR)  // <= FOUND
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L80)

```85:     function setVotingPeriod(
86:         uint256 newVotingPeriod
87:     ) public override onlyCoreRole(CoreRoles.GOVERNOR)  // <= FOUND
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L85-L87)

```92:     function setProposalThreshold(
93:         uint256 newProposalThreshold
94:     ) public override onlyCoreRole(CoreRoles.GOVERNOR)  // <= FOUND
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L92-L94)

```30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool)  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L30-L33)

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override  // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```171:     function propose(
172:         address[] memory ,
173:         uint256[] memory ,
174:         bytes[] memory ,
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L171)

```143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool)  // <= FOUND
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L143-L146)

```172:     function _quorumReached(
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool)  // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L174)

```186:     function _voteSucceeded(
187:         uint256 
188:     ) internal pure virtual override returns (bool)  // <= FOUND
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L188)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override  // <= FOUND
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L201)

```222:     function votingDelay() public pure override returns (uint256)  // <= FOUND
```

*GitHub* : [222](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L222-L222)

```230:     function votingPeriod() public pure override returns (uint256)  // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L230-L230)

```246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState)  // <= FOUND
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L246-L248)

```304:     function propose(
305:         address[] memory ,
306:         uint256[] memory ,
307:         bytes[] memory ,
308:         string memory 
309:     ) public pure override returns (uint256)  // <= FOUND
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L304-L309)

```403:     function _burn(address from, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool)  // <= FOUND
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L411)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool)  // <= FOUND
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L420)

```426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256)  // <= FOUND
```

*GitHub* : [426](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L426-L428)

```444:     function totalSupply() public view virtual override returns (uint256)  // <= FOUND
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L444-L444)

```461:     function _burn(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```509:     function _mint(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override  // <= FOUND
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L186)

```207:     function _decrementGaugeWeight(
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override  // <= FOUND
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L207-L211)

```242:     function _incrementGaugeWeight(
243:         address user,
244:         address gauge,
245:         uint256 weight
246:     ) internal override  // <= FOUND
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L242-L246)
### [NC-114]<a name="nc-114"></a> Natspec @author is missing from contract

*There are 7 instance(s) of this issue:*

```16: contract LendingTermOffboarding is CoreRef 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor 
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```10: contract AuctionHouse is CoreRef 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef 
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-115]<a name="nc-115"></a> Natspec @notice is missing from contract

*There are 3 instance(s) of this issue:*

```16: contract GuildGovernor is
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L16)

```14: contract GuildTimelockController is TimelockController, CoreRef 
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)
### [NC-116]<a name="nc-116"></a> Natspec @dev is missing from contract

*There are 11 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L16)

```16: contract LendingTermOffboarding is CoreRef 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor 
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is
19:     CoreRef,
20:     ERC20Burnable,
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: 
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L18)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes 
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef 
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-117]<a name="nc-117"></a> Natspec @title is missing from contract

*There are 7 instance(s) of this issue:*

```16: contract LendingTermOffboarding is CoreRef 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor 
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```10: contract AuctionHouse is CoreRef 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef 
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef 
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2 
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [NC-118]<a name="nc-118"></a> Natspec @author is missing from interface

*There are 1 instance(s) of this issue:*

```10: interface IERC20Mintable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L10-L10)
### [NC-119]<a name="nc-119"></a> Natspec @title is missing from interface

*There are 1 instance(s) of this issue:*

```10: interface IERC20Mintable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L10-L10)
### [NC-120]<a name="nc-120"></a> Natspec @dev is missing from interface

*There are 1 instance(s) of this issue:*

```10: interface IERC20Mintable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L10-L10)
### [NC-121]<a name="nc-121"></a> Natspec @notice is missing from interface

*There are 1 instance(s) of this issue:*

```10: interface IERC20Mintable 
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L10-L10)
### [NC-122]<a name="nc-122"></a> Natspec @author is missing from library

*There are 1 instance(s) of this issue:*

```8: library CoreRoles 
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L8-L8)
### [NC-123]<a name="nc-123"></a> Natspec @dev is missing from library

*There are 1 instance(s) of this issue:*

```8: library CoreRoles 
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L8-L8)
### [NC-124]<a name="nc-124"></a> Natspec @author is missing from abstract

*There are 1 instance(s) of this issue:*

```35: abstract contract ERC20MultiVotes is ERC20Permit 
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L35-L35)
### [NC-125]<a name="nc-125"></a> Natspec @dev is missing from abstract

*There are 3 instance(s) of this issue:*

```12: abstract contract CoreRef is Pausable 
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L12-L12)

```42: abstract contract ERC20RebaseDistributor is ERC20 
```

*GitHub* : [42](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L42-L42)

```14: abstract contract RateLimitedV2 is IRateLimitedV2, CoreRef 
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L14-L14)
### [NC-126]<a name="nc-126"></a> Natspec @notice is missing from abstract

*There are 1 instance(s) of this issue:*

```14: abstract contract RateLimitedV2 is IRateLimitedV2, CoreRef 
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L14-L14)
### [NC-127]<a name="nc-127"></a> Event declarations should have NatSpec descriptions

*There are 8 instance(s) of this issue:*

```181:     event Undelegation( // <= FOUND
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L181-L181)

```196:     event DelegateChanged( // <= FOUND
197:         address indexed delegator,
198:         address indexed fromDelegate,
199:         address indexed toDelegate
200:     );
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L196-L196)

```109:     event GaugeLossApply( // <= FOUND
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L109-L109)

```117:     event TermSurplusBufferUpdate( // <= FOUND
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L117-L117)

```127:     event ProfitSharingConfigUpdate( // <= FOUND
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L127-L127)

```137:     event ClaimRewards( // <= FOUND
138:         uint256 indexed when,
139:         address indexed user,
140:         address indexed gauge,
141:         uint256 amount
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L137-L137)

```25:     event LoanOpen( // <= FOUND
26:         uint256 indexed when,
27:         bytes32 indexed loanId,
28:         address indexed borrower,
29:         uint256 collateralAmount,
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L25-L25)

```40:     event LoanClose( // <= FOUND
41:         uint256 indexed when,
42:         bytes32 indexed loanId,
43:         LoanCloseType indexed closeType,
44:         uint256 debtRepaid
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L40-L40)
### [NC-128]<a name="nc-128"></a> Event declarations should have @dev NatSpec comments

*There are 8 instance(s) of this issue:*

```181:     event Undelegation( // <= FOUND
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L181-L181)

```196:     event DelegateChanged( // <= FOUND
197:         address indexed delegator,
198:         address indexed fromDelegate,
199:         address indexed toDelegate
200:     );
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L196-L196)

```109:     event GaugeLossApply( // <= FOUND
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L109-L109)

```117:     event TermSurplusBufferUpdate( // <= FOUND
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L117-L117)

```127:     event ProfitSharingConfigUpdate( // <= FOUND
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L127-L127)

```137:     event ClaimRewards( // <= FOUND
138:         uint256 indexed when,
139:         address indexed user,
140:         address indexed gauge,
141:         uint256 amount
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L137-L137)

```25:     event LoanOpen( // <= FOUND
26:         uint256 indexed when,
27:         bytes32 indexed loanId,
28:         address indexed borrower,
29:         uint256 collateralAmount,
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L25-L25)

```40:     event LoanClose( // <= FOUND
41:         uint256 indexed when,
42:         bytes32 indexed loanId,
43:         LoanCloseType indexed closeType,
44:         uint256 debtRepaid
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L40-L40)
### [NC-129]<a name="nc-129"></a> Event declarations should have @notice NatSpec comments

*There are 8 instance(s) of this issue:*

```181:     event Undelegation( // <= FOUND
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L181-L181)

```196:     event DelegateChanged( // <= FOUND
197:         address indexed delegator,
198:         address indexed fromDelegate,
199:         address indexed toDelegate
200:     );
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L196-L196)

```109:     event GaugeLossApply( // <= FOUND
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L109-L109)

```117:     event TermSurplusBufferUpdate( // <= FOUND
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L117-L117)

```127:     event ProfitSharingConfigUpdate( // <= FOUND
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L127-L127)

```137:     event ClaimRewards( // <= FOUND
138:         uint256 indexed when,
139:         address indexed user,
140:         address indexed gauge,
141:         uint256 amount
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L137-L137)

```25:     event LoanOpen( // <= FOUND
26:         uint256 indexed when,
27:         bytes32 indexed loanId,
28:         address indexed borrower,
29:         uint256 collateralAmount,
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L25-L25)

```40:     event LoanClose( // <= FOUND
41:         uint256 indexed when,
42:         bytes32 indexed loanId,
43:         LoanCloseType indexed closeType,
44:         uint256 debtRepaid
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L40-L40)
### [NC-130]<a name="nc-130"></a> Event declarations should have @params NatSpec comments

*There are 8 instance(s) of this issue:*

```181:     event Undelegation( // <= FOUND
182:         address indexed delegator,
183:         address indexed delegate,
184:         uint256 amount
185:     );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L181-L181)

```196:     event DelegateChanged( // <= FOUND
197:         address indexed delegator,
198:         address indexed fromDelegate,
199:         address indexed toDelegate
200:     );
```

*GitHub* : [196](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L196-L196)

```109:     event GaugeLossApply( // <= FOUND
110:         address indexed gauge,
111:         address indexed who,
112:         uint256 weight,
113:         uint256 when
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L109-L109)

```117:     event TermSurplusBufferUpdate( // <= FOUND
118:         uint256 indexed when,
119:         address indexed term,
120:         uint256 newValue
121:     );
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L117-L117)

```127:     event ProfitSharingConfigUpdate( // <= FOUND
128:         uint256 indexed when,
129:         uint256 surplusBufferSplit,
130:         uint256 creditSplit,
131:         uint256 guildSplit,
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L127-L127)

```137:     event ClaimRewards( // <= FOUND
138:         uint256 indexed when,
139:         address indexed user,
140:         address indexed gauge,
141:         uint256 amount
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L137-L137)

```25:     event LoanOpen( // <= FOUND
26:         uint256 indexed when,
27:         bytes32 indexed loanId,
28:         address indexed borrower,
29:         uint256 collateralAmount,
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L25-L25)

```40:     event LoanClose( // <= FOUND
41:         uint256 indexed when,
42:         bytes32 indexed loanId,
43:         LoanCloseType indexed closeType,
44:         uint256 debtRepaid
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L40-L40)
### [NC-131]<a name="nc-131"></a> Error declarations should have @dev NatSpec comments

*There are 1 instance(s) of this issue:*

```    - Consistency: make incrementGauges return a uint112 instead of uint256
- Import OpenZeppelin ERC20 & EnumerableSet instead of Solmate's
- Update error management style (use require + messages instead of Solidity errors) // <= FOUND
- Implement C4 audit fixes for [M-03], [M-04], [M-07], [G-02], and [G-04].
- Remove cycle-based logic
```

  *GitHub* :
### [NC-132]<a name="nc-132"></a> Error declarations should have @notice NatSpec comments

*There are 1 instance(s) of this issue:*

```    - Consistency: make incrementGauges return a uint112 instead of uint256
- Import OpenZeppelin ERC20 & EnumerableSet instead of Solmate's
- Update error management style (use require + messages instead of Solidity errors) // <= FOUND
- Implement C4 audit fixes for [M-03], [M-04], [M-07], [G-02], and [G-04].
- Remove cycle-based logic
```

  *GitHub* :
### [NC-133]<a name="nc-133"></a> Error declarations should have @params NatSpec comments

*There are 1 instance(s) of this issue:*

```    - Consistency: make incrementGauges return a uint112 instead of uint256
- Import OpenZeppelin ERC20 & EnumerableSet instead of Solmate's
- Update error management style (use require + messages instead of Solidity errors) // <= FOUND
- Implement C4 audit fixes for [M-03], [M-04], [M-07], [G-02], and [G-04].
- Remove cycle-based logic
```

  *GitHub* :
### [NC-134]<a name="nc-134"></a> Natspec @params comments are missing from modifier

*There are 1 instance(s) of this issue:*

```24:     modifier onlyCoreRole(bytes32 role) 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L24-L24)
### [NC-135]<a name="nc-135"></a> Natspec @dev comments are missing from modifier

*There are 1 instance(s) of this issue:*

```24:     modifier onlyCoreRole(bytes32 role) 
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L24-L24)
### [NC-136]<a name="nc-136"></a> Natspec @params comments are missing from struct

*There are 12 instance(s) of this issue:*

```74:     struct Call {
75:         
76:         address target;
77:         
78:         uint256 value;
79:         
80:         bytes callData;
81:     }
```

*GitHub* : [74](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L74-L74)

```48:     struct ProfitSharingConfig {
49:         uint32 surplusBufferSplit; 
50:         uint32 guildSplit; 
51:         uint32 otherSplit; 
52:         address otherRecipient; 
53:     }
```

*GitHub* : [48](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L48-L48)

```117:     struct ProposalVote {
118:         uint256 againstVotes;
119:         uint256 forVotes;
120:         uint256 abstainVotes;
121:         mapping(address => bool) hasVoted;
122:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L117-L117)

```43:     struct Checkpoint {
44:         uint32 fromBlock;
45:         uint224 votes;
46:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L43-L43)

```77:     struct RebasingState {
78:         uint8 isRebasing;
79:         uint248 nShares;
80:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L77-L77)

```99:     struct InterpolatedValue {
100:         uint32 lastTimestamp;
101:         uint224 lastValue;
102:         uint32 targetTimestamp;
103:         uint224 targetValue;
104:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L99-L99)

```40:     struct Auction {
41:         uint256 startTime;
42:         uint256 endTime;
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L40)

```61:     struct Signature {
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L61-L61)

```75:     struct Loan {
76:         address borrower; 
77:         uint256 borrowTime; 
78:         uint256 borrowAmount; 
79:         uint256 borrowCreditMultiplier; 
80:         uint256 collateralAmount; 
81:         address caller; 
82:         uint256 callTime; 
83:         uint256 callDebt; 
84:         uint256 closeTime; 
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L75)

```97:     struct LendingTermReferences {
98:         
99:         address profitManager;
100:         
101:         address guildToken;
102:         
103:         
104:         address auctionHouse;
105:         
106:         address creditMinter;
107:         
108:         address creditToken;
109:     }
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L97-L97)

```114:     struct LendingTermParams {
115:         
116:         address collateralToken;
117:         
118:         
119:         
120:         
121:         
122:         
123:         
124:         
125:         uint256 maxDebtPerCollateralToken;
126:         
127:         
128:         uint256 interestRate;
129:         
130:         
131:         
132:         
133:         uint256 maxDelayBetweenPartialRepay;
134:         
135:         
136:         
137:         uint256 minPartialRepayPercent;
138:         
139:         
140:         
141:         
142:         
143:         
144:         uint256 openingFee;
145:         
146:         
147:         uint256 hardCap;
148:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L114-L114)

```77:     struct UserStake {
78:         uint48 stakeTime;
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L77-L77)
### [NC-137]<a name="nc-137"></a> Natspec @dev comments are missing from struct

*There are 11 instance(s) of this issue:*

```74:     struct Call {
75:         
76:         address target;
77:         
78:         uint256 value;
79:         
80:         bytes callData;
81:     }
```

*GitHub* : [74](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L74-L74)

```117:     struct ProposalVote {
118:         uint256 againstVotes;
119:         uint256 forVotes;
120:         uint256 abstainVotes;
121:         mapping(address => bool) hasVoted;
122:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L117-L117)

```43:     struct Checkpoint {
44:         uint32 fromBlock;
45:         uint224 votes;
46:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L43-L43)

```77:     struct RebasingState {
78:         uint8 isRebasing;
79:         uint248 nShares;
80:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L77-L77)

```99:     struct InterpolatedValue {
100:         uint32 lastTimestamp;
101:         uint224 lastValue;
102:         uint32 targetTimestamp;
103:         uint224 targetValue;
104:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L99-L99)

```40:     struct Auction {
41:         uint256 startTime;
42:         uint256 endTime;
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L40)

```61:     struct Signature {
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L61-L61)

```75:     struct Loan {
76:         address borrower; 
77:         uint256 borrowTime; 
78:         uint256 borrowAmount; 
79:         uint256 borrowCreditMultiplier; 
80:         uint256 collateralAmount; 
81:         address caller; 
82:         uint256 callTime; 
83:         uint256 callDebt; 
84:         uint256 closeTime; 
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L75)

```97:     struct LendingTermReferences {
98:         
99:         address profitManager;
100:         
101:         address guildToken;
102:         
103:         
104:         address auctionHouse;
105:         
106:         address creditMinter;
107:         
108:         address creditToken;
109:     }
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L97-L97)

```114:     struct LendingTermParams {
115:         
116:         address collateralToken;
117:         
118:         
119:         
120:         
121:         
122:         
123:         
124:         
125:         uint256 maxDebtPerCollateralToken;
126:         
127:         
128:         uint256 interestRate;
129:         
130:         
131:         
132:         
133:         uint256 maxDelayBetweenPartialRepay;
134:         
135:         
136:         
137:         uint256 minPartialRepayPercent;
138:         
139:         
140:         
141:         
142:         
143:         
144:         uint256 openingFee;
145:         
146:         
147:         uint256 hardCap;
148:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L114-L114)

```77:     struct UserStake {
78:         uint48 stakeTime;
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L77-L77)
### [NC-138]<a name="nc-138"></a> Natspec @notice comments are missing from struct

*There are 11 instance(s) of this issue:*

```48:     struct ProfitSharingConfig {
49:         uint32 surplusBufferSplit; 
50:         uint32 guildSplit; 
51:         uint32 otherSplit; 
52:         address otherRecipient; 
53:     }
```

*GitHub* : [48](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L48-L48)

```117:     struct ProposalVote {
118:         uint256 againstVotes;
119:         uint256 forVotes;
120:         uint256 abstainVotes;
121:         mapping(address => bool) hasVoted;
122:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L117-L117)

```43:     struct Checkpoint {
44:         uint32 fromBlock;
45:         uint224 votes;
46:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L43-L43)

```77:     struct RebasingState {
78:         uint8 isRebasing;
79:         uint248 nShares;
80:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L77-L77)

```99:     struct InterpolatedValue {
100:         uint32 lastTimestamp;
101:         uint224 lastValue;
102:         uint32 targetTimestamp;
103:         uint224 targetValue;
104:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L99-L99)

```40:     struct Auction {
41:         uint256 startTime;
42:         uint256 endTime;
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L40)

```61:     struct Signature {
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L61-L61)

```75:     struct Loan {
76:         address borrower; 
77:         uint256 borrowTime; 
78:         uint256 borrowAmount; 
79:         uint256 borrowCreditMultiplier; 
80:         uint256 collateralAmount; 
81:         address caller; 
82:         uint256 callTime; 
83:         uint256 callDebt; 
84:         uint256 closeTime; 
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L75)

```97:     struct LendingTermReferences {
98:         
99:         address profitManager;
100:         
101:         address guildToken;
102:         
103:         
104:         address auctionHouse;
105:         
106:         address creditMinter;
107:         
108:         address creditToken;
109:     }
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L97-L97)

```114:     struct LendingTermParams {
115:         
116:         address collateralToken;
117:         
118:         
119:         
120:         
121:         
122:         
123:         
124:         
125:         uint256 maxDebtPerCollateralToken;
126:         
127:         
128:         uint256 interestRate;
129:         
130:         
131:         
132:         
133:         uint256 maxDelayBetweenPartialRepay;
134:         
135:         
136:         
137:         uint256 minPartialRepayPercent;
138:         
139:         
140:         
141:         
142:         
143:         
144:         uint256 openingFee;
145:         
146:         
147:         uint256 hardCap;
148:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L114-L114)

```77:     struct UserStake {
78:         uint48 stakeTime;
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L77-L77)
### [NC-139]<a name="nc-139"></a> Natspec @params comments are missing from function

*There are 155 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L87)

```57:     function quorum(
58:         uint256 
59:     ) public view override returns (uint256) 
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L57-L57)

```68:     function _setQuorum(uint256 newQuorum) internal 
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L68)

```78:     function setVotingDelay(
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L78)

```85:     function setVotingPeriod(
86:         uint256 newVotingPeriod
87:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L85-L85)

```92:     function setProposalThreshold(
93:         uint256 newProposalThreshold
94:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L92-L92)

```99:     function setQuorum(
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L99-L99)

```110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) 
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L110)

```123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) 
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```160:     function state(
161:         uint256 proposalId
162:     )
163:         public
164:         view
165:         override(Governor, GovernorTimelockControl)
166:         returns (ProposalState)
167:     
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L160-L160)

```171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L171-L171)

```30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool) 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L30-L30)

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override 
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override 
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override 
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```78:     function setQuorum(
79:         uint256 _quorum
80:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L78-L78)

```89:     function proposeOffboard(address term) external whenNotPaused 
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused 
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L116)

```92:     function allowImplementation(
93:         address implementation,
94:         bool allowed
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L92-L92)

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) 
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L105)

```171:     function propose(
172:         address[] memory ,
173:         uint256[] memory ,
174:         bytes[] memory ,
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L171)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) 
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L181)

```215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     
```

*GitHub* : [215](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L215-L215)

```156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L156)

```179:     function setMinBorrow(
180:         uint256 newValue
181:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [179](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L179-L179)

```187:     function setGaugeWeightTolerance(
188:         uint256 newValue
189:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L187-L187)

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L195)

```251:     function donateToSurplusBuffer(uint256 amount) external 
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L251)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external 
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L259)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L267)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L278)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) 
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) 
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L409)

```439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) 
```

*GitHub* : [439](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L439-L439)

```452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L452-L452)

```71:     function _setQuorum(uint256 newQuorum) internal virtual 
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L71-L71)

```93:     function updateTimelock(
94:         address newTimelock
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L93-L93)

```99:     function _updateTimelock(address newTimelock) private 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L99-L99)

```143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool) 
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L143-L143)

```153:     function proposalVotes(
154:         uint256 proposalId
155:     )
156:         public
157:         view
158:         virtual
159:         returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)
160:     
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L153-L153)

```172:     function _quorumReached(
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L172)

```186:     function _voteSucceeded(
187:         uint256 
188:     ) internal pure virtual override returns (bool) 
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L186)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L195)

```246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) 
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L246-L246)

```304:     function propose(
305:         address[] memory ,
306:         uint256[] memory ,
307:         bytes[] memory ,
308:         string memory 
309:     ) public pure override returns (uint256) 
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L304-L304)

```315:     function createVeto(bytes32 timelockId) external returns (uint256) 
```

*GitHub* : [315](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L315-L315)

```349:     function executeVeto(bytes32 timelockId) external returns (uint256) 
```

*GitHub* : [349](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L349-L349)

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L367)

```103:     function isGauge(address gauge) public view returns (bool) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L103-L103)

```108:     function isDeprecatedGauge(address gauge) public view returns (bool) 
```

*GitHub* : [108](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L108-L108)

```154:     function userGauges(address user) external view returns (address[] memory) 
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L154-L154)

```159:     function isUserGauge(
160:         address user,
161:         address gauge
162:     ) external view returns (bool) 
```

*GitHub* : [159](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L159-L159)

```167:     function numUserGauges(address user) external view returns (uint256) 
```

*GitHub* : [167](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L167-L167)

```172:     function userUnusedWeight(address user) external view returns (uint256) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L172-L172)

```230:     function _incrementGaugeWeight(
231:         address user,
232:         address gauge,
233:         uint256 weight
234:     ) internal virtual 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L230-L230)

```249:     function _incrementUserAndGlobalWeights(
250:         address user,
251:         uint256 weight
252:     ) internal returns (uint256 newUserWeight) 
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L249-L249)

```314:     function _decrementGaugeWeight(
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual 
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L314-L314)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) 
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)

```425:     function _removeGauge(address gauge) internal 
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L425-L425)

```444:     function _setMaxGauges(uint256 newMax) internal 
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L444-L444)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal 
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L452)

```403:     function _burn(address from, uint256 amount) internal virtual override 
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) 
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L408)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) 
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L416)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal 
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L500-L500)

```52:     function checkpoints(
53:         address account,
54:         uint32 pos
55:     ) public view virtual returns (Checkpoint memory) 
```

*GitHub* : [52](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L52-L52)

```60:     function numCheckpoints(
61:         address account
62:     ) public view virtual returns (uint32) 
```

*GitHub* : [60](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L60-L60)

```103:     function _checkpointsLookup(
104:         Checkpoint[] storage ckpts,
105:         uint256 blockNumber
106:     ) private view returns (uint256) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L103-L103)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) 
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```147:     function _setMaxDelegates(uint256 newMax) internal 
```

*GitHub* : [147](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L147-L147)

```155:     function _setContractExceedMaxDelegates(
156:         address account,
157:         bool canExceedMax
158:     ) internal 
```

*GitHub* : [155](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L155-L155)

```290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual 
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L290)

```317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual 
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L317)

```344:     function _undelegate(
345:         address delegator,
346:         address delegatee,
347:         uint256 amount
348:     ) internal virtual 
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L344-L344)

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private 
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L363)

```387:     function _add(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L387-L387)

```391:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [391](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L391-L391)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal 
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L427-L427)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public 
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)

```131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) 
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L131-L131)

```168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal 
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L168)

```228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal 
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L228-L228)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) 
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L252)

```260:     function _shares2balance(
261:         uint256 shares,
262:         uint256 sharePrice,
263:         uint256 deltaBalance,
264:         uint256 minBalance
265:     ) internal pure returns (uint256) 
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L260-L260)

```289:     function _enterRebase(address account) internal 
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L289)

```311:     function _exitRebase(address account) internal 
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L311)

```338:     function distribute(uint256 amount) external 
```

*GitHub* : [338](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L338-L338)

```389:     function isRebasing(address account) public view returns (bool) 
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L389-L389)

```426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256) 
```

*GitHub* : [426](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L426-L426)

```461:     function _burn(address account, uint256 amount) internal virtual override 
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```509:     function _mint(address account, uint256 amount) internal virtual override 
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)

```35:     function mint(
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) 
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L35)

```43:     function setMaxDelegates(
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L43)

```50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```58:     function forceEnterRebase(
59:         address account
60:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) 
```

*GitHub* : [58](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L58-L58)

```69:     function forceExitRebase(
70:         address account
71:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) 
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L69-L69)

```83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L83)

```90:     function _burn(
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) 
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L90)

```98:     function balanceOf(
99:         address account
100:     ) public view override(ERC20, ERC20RebaseDistributor) returns (uint256) 
```

*GitHub* : [98](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L98-L98)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L113)

```125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L125)

```59:     function setMaxDelegates(
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L59)

```66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```76:     function addGauge(
77:         uint256 _type,
78:         address gauge
79:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) 
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L76)

```83:     function removeGauge(
84:         address gauge
85:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L83-L83)

```89:     function setMaxGauges(
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L89)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```123:     function notifyGaugeLoss(address gauge) external 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L123-L123)

```133:     function applyGaugeLoss(address gauge, address who) external 
```

*GitHub* : [133](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L133-L133)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override 
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L182)

```197:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L197-L197)

```207:     function _decrementGaugeWeight(
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override 
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L207-L207)

```242:     function _incrementGaugeWeight(
243:         address user,
244:         address gauge,
245:         uint256 weight
246:     ) internal override 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L242-L242)

```268:     function mint(
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) 
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L268)

```279:     function _burn(
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) 
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L279)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L288)

```302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L302)

```67:     function getAuction(bytes32 loanId) external view returns (Auction memory) 
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L67-L67)

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) 
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L118-L118)

```166:     function bid(bytes32 loanId) external 
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L166-L166)

```202:     function forgive(bytes32 loanId) external 
```

*GitHub* : [202](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L202-L202)

```160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external 
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L160)

```195:     function getLoan(bytes32 loanId) external view returns (Loan memory) 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L195-L195)

```200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) 
```

*GitHub* : [200](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L200-L200)

```237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) 
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L237-L237)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) 
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L339)

```438:     function borrow(
439:         uint256 borrowAmount,
440:         uint256 collateralAmount
441:     ) external whenNotPaused returns (bytes32 loanId) 
```

*GitHub* : [438](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L438-L438)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal 
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```482:     function addCollateral(bytes32 loanId, uint256 collateralToAdd) external 
```

*GitHub* : [482](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L482-L482)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal 
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```562:     function partialRepay(bytes32 loanId, uint256 debtToRepay) external 
```

*GitHub* : [562](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L562-L562)

```567:     function _repay(address repayer, bytes32 loanId) internal 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```628:     function repay(bytes32 loanId) external 
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L628-L628)

```634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal 
```

*GitHub* : [634](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L634-L634)

```678:     function call(bytes32 loanId) external 
```

*GitHub* : [678](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L678-L678)

```683:     function callMany(bytes32[] memory loanIds) public 
```

*GitHub* : [683](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L683-L683)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [695](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L695-L695)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external 
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```829:     function setAuctionHouse(
830:         address _newValue
831:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [829](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L829-L829)

```846:     function setHardCap(
847:         uint256 _newValue
848:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [846](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L846-L846)

```80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) 
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L80-L80)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) 
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L87-L87)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L103)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) 
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L117-L117)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) 
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L134)

```149:     function setRedemptionsPaused(
150:         bool paused
151:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L149-L149)

```106:     function getUserStake(
107:         address user,
108:         address term
109:     ) external view returns (UserStake memory) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L106-L106)

```114:     function stake(address term, uint256 amount) external whenNotPaused 
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L114)

```158:     function unstake(address term, uint256 amount) external 
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L158-L158)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L216)

```293:     function updateMintRatio(address user, address term) external 
```

*GitHub* : [293](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L293-L293)

```319:     function setMintRatio(
320:         uint256 _mintRatio
321:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L319-L319)

```328:     function setRewardRatio(
329:         uint256 _rewardRatio
330:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [328](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L328-L328)

```158:     function _updateBufferStored(uint128 newBufferCap) internal 
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L158)
### [NC-140]<a name="nc-140"></a> Natspec @dev comments are missing from function

*There are 184 instance(s) of this issue:*

```30:     function core() public view returns (Core) 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L30-L30)

```39:     function setCore(
40:         address newCore
41:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L39-L39)

```49:     function _setCore(address newCore) internal 
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L49-L49)

```57:     function pause() public onlyCoreRole(CoreRoles.GUARDIAN) 
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L57-L57)

```62:     function unpause() public onlyCoreRole(CoreRoles.GUARDIAN) 
```

*GitHub* : [62](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L62-L62)

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L87)

```57:     function quorum(
58:         uint256 
59:     ) public view override returns (uint256) 
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L57-L57)

```78:     function setVotingDelay(
79:         uint256 newVotingDelay
80:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L78-L78)

```85:     function setVotingPeriod(
86:         uint256 newVotingPeriod
87:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L85-L85)

```92:     function setProposalThreshold(
93:         uint256 newProposalThreshold
94:     ) public override onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L92-L92)

```99:     function setQuorum(
100:         uint256 newQuorum
101:     ) public onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L99-L99)

```110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) 
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L110)

```123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) 
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```142:     function _executor()
143:         internal
144:         view
145:         override(Governor, GovernorTimelockControl)
146:         returns (address)
147:     
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L142-L142)

```151:     function proposalThreshold()
152:         public
153:         view
154:         override(Governor, GovernorSettings)
155:         returns (uint256)
156:     
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L151-L151)

```160:     function state(
161:         uint256 proposalId
162:     )
163:         public
164:         view
165:         override(Governor, GovernorTimelockControl)
166:         returns (ProposalState)
167:     
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L160-L160)

```171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L171-L171)

```78:     function setQuorum(
79:         uint256 _quorum
80:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [78](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L78-L78)

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused 
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L116)

```153:     function offboard(address term) external whenNotPaused 
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L153-L153)

```175:     function cleanup(address term) external whenNotPaused 
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L175-L175)

```92:     function allowImplementation(
93:         address implementation,
94:         bool allowed
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L92-L92)

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) 
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L105)

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) 
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L181-L181)

```215:     function getOnboardProposeArgs(
216:         address term
217:     )
218:         public
219:         view
220:         returns (
221:             address[] memory targets,
222:             uint256[] memory values,
223:             bytes[] memory calldatas,
224:             string memory description
225:         )
226:     
```

*GitHub* : [215](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L215-L215)

```151:     function minBorrow() external view returns (uint256) 
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L151-L151)

```156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L156)

```172:     function totalBorrowedCredit() external view returns (uint256) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L172-L172)

```179:     function setMinBorrow(
180:         uint256 newValue
181:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [179](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L179-L179)

```187:     function setGaugeWeightTolerance(
188:         uint256 newValue
189:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L187-L187)

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L195)

```230:     function getProfitSharingConfig()
231:         external
232:         view
233:         returns (
234:             uint256 surplusBufferSplit,
235:             uint256 creditSplit,
236:             uint256 guildSplit,
237:             uint256 otherSplit,
238:             address otherRecipient
239:         )
240:     
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L230-L230)

```251:     function donateToSurplusBuffer(uint256 amount) external 
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L251)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external 
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L259)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L267)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) 
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L278)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) 
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```439:     function claimRewards(
440:         address user
441:     ) external returns (uint256 creditEarned) 
```

*GitHub* : [439](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L439-L439)

```452:     function getPendingRewards(
453:         address user
454:     )
455:         external
456:         view
457:         returns (
458:             address[] memory gauges,
459:             uint256[] memory creditEarned,
460:             uint256 totalCreditEarned
461:         )
462:     
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L452-L452)

```93:     function updateTimelock(
94:         address newTimelock
95:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L93-L93)

```99:     function _updateTimelock(address newTimelock) private 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L99-L99)

```130:     function COUNTING_MODE()
131:         public
132:         pure
133:         virtual
134:         override
135:         returns (string memory)
136:     
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L130-L130)

```143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool) 
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L143-L143)

```172:     function _quorumReached(
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L172)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L195)

```246:     function state(
247:         uint256 proposalId
248:     ) public view override returns (ProposalState) 
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L246-L246)

```315:     function createVeto(bytes32 timelockId) external returns (uint256) 
```

*GitHub* : [315](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L315-L315)

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L367)

```98:     function gauges() external view returns (address[] memory) 
```

*GitHub* : [98](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L98-L98)

```103:     function isGauge(address gauge) public view returns (bool) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L103-L103)

```108:     function isDeprecatedGauge(address gauge) public view returns (bool) 
```

*GitHub* : [108](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L108-L108)

```113:     function numGauges() external view returns (uint256) 
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L113-L113)

```118:     function deprecatedGauges() external view returns (address[] memory) 
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L118-L118)

```123:     function numDeprecatedGauges() external view returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L123-L123)

```128:     function liveGauges() external view returns (address[] memory _liveGauges) 
```

*GitHub* : [128](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L128-L128)

```149:     function numLiveGauges() external view returns (uint256) 
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L149-L149)

```154:     function userGauges(address user) external view returns (address[] memory) 
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L154-L154)

```159:     function isUserGauge(
160:         address user,
161:         address gauge
162:     ) external view returns (bool) 
```

*GitHub* : [159](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L159-L159)

```167:     function numUserGauges(address user) external view returns (uint256) 
```

*GitHub* : [167](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L167-L167)

```172:     function userUnusedWeight(address user) external view returns (uint256) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L172-L172)

```182:     function calculateGaugeAllocation(
183:         address gauge,
184:         uint256 quantity
185:     ) external view returns (uint256) 
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L182-L182)

```219:     function incrementGauge(
220:         address gauge,
221:         uint256 weight
222:     ) public virtual returns (uint256 newUserWeight) 
```

*GitHub* : [219](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L219-L219)

```249:     function _incrementUserAndGlobalWeights(
250:         address user,
251:         uint256 weight
252:     ) internal returns (uint256 newUserWeight) 
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L249-L249)

```269:     function incrementGauges(
270:         address[] calldata gaugeList,
271:         uint256[] calldata weights
272:     ) public virtual returns (uint256 newUserWeight) 
```

*GitHub* : [269](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L269-L269)

```301:     function decrementGauge(
302:         address gauge,
303:         uint256 weight
304:     ) public virtual returns (uint256 newUserWeight) 
```

*GitHub* : [301](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L301-L301)

```314:     function _decrementGaugeWeight(
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual 
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L314-L314)

```340:     function decrementGauges(
341:         address[] calldata gaugeList,
342:         uint256[] calldata weights
343:     ) public virtual returns (uint256 newUserWeight) 
```

*GitHub* : [340](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L340-L340)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) 
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)

```425:     function _removeGauge(address gauge) internal 
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L425-L425)

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal 
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L452)

```403:     function _burn(address from, uint256 amount) internal virtual override 
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) 
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L408)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) 
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L416)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal 
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L500-L500)

```52:     function checkpoints(
53:         address account,
54:         uint32 pos
55:     ) public view virtual returns (Checkpoint memory) 
```

*GitHub* : [52](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L52-L52)

```60:     function numCheckpoints(
61:         address account
62:     ) public view virtual returns (uint32) 
```

*GitHub* : [60](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L60-L60)

```71:     function freeVotes(address account) public view virtual returns (uint256) 
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L71-L71)

```80:     function getVotes(address account) public view virtual returns (uint256) 
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L80-L80)

```91:     function getPastVotes(
92:         address account,
93:         uint256 blockNumber
94:     ) public view virtual returns (uint256) 
```

*GitHub* : [91](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L91-L91)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) 
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```147:     function _setMaxDelegates(uint256 newMax) internal 
```

*GitHub* : [147](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L147-L147)

```155:     function _setContractExceedMaxDelegates(
156:         address account,
157:         bool canExceedMax
158:     ) internal 
```

*GitHub* : [155](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L155-L155)

```218:     function delegatesVotesCount(
219:         address delegator,
220:         address delegatee
221:     ) public view virtual returns (uint256) 
```

*GitHub* : [218](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L218-L218)

```230:     function delegates(
231:         address delegator
232:     ) public view returns (address[] memory) 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L230-L230)

```242:     function containsDelegate(
243:         address delegator,
244:         address delegatee
245:     ) public view returns (bool) 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L242-L242)

```254:     function delegateCount(address delegator) public view returns (uint256) 
```

*GitHub* : [254](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L254-L254)

```276:     function undelegate(address delegatee, uint256 amount) public virtual 
```

*GitHub* : [276](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L276-L276)

```290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual 
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L290)

```317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual 
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L317)

```344:     function _undelegate(
345:         address delegator,
346:         address delegatee,
347:         uint256 amount
348:     ) internal virtual 
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L344-L344)

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private 
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L363)

```387:     function _add(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L387-L387)

```391:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [391](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L391-L391)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal 
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L427-L427)

```131:     function interpolatedValue(
132:         InterpolatedValue memory val
133:     ) internal view returns (uint256) 
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L131-L131)

```168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal 
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L168)

```228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal 
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L228-L228)

```242:     function rebasingSharePrice() internal view returns (uint256) 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L242-L242)

```247:     function unmintedRebaseRewards() internal view returns (uint256) 
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L247-L247)

```252:     function _balance2shares(
253:         uint256 balance,
254:         uint256 sharePrice
255:     ) internal pure returns (uint256) 
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L252)

```260:     function _shares2balance(
261:         uint256 shares,
262:         uint256 sharePrice,
263:         uint256 deltaBalance,
264:         uint256 minBalance
265:     ) internal pure returns (uint256) 
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L260-L260)

```281:     function enterRebase() external 
```

*GitHub* : [281](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L281-L281)

```289:     function _enterRebase(address account) internal 
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L289)

```303:     function exitRebase() external 
```

*GitHub* : [303](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L303-L303)

```311:     function _exitRebase(address account) internal 
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L311)

```389:     function isRebasing(address account) public view returns (bool) 
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L389-L389)

```394:     function rebasingSupply() public view returns (uint256) 
```

*GitHub* : [394](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L394-L394)

```399:     function nonRebasingSupply() external view virtual returns (uint256) 
```

*GitHub* : [399](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L399-L399)

```415:     function pendingDistributedSupply() external view returns (uint256) 
```

*GitHub* : [415](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L415-L415)

```426:     function balanceOf(
427:         address account
428:     ) public view virtual override returns (uint256) 
```

*GitHub* : [426](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L426-L426)

```444:     function totalSupply() public view virtual override returns (uint256) 
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L444-L444)

```509:     function _mint(address account, uint256 amount) internal virtual override 
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)

```35:     function mint(
36:         address to,
37:         uint256 amount
38:     ) external onlyCoreRole(CoreRoles.CREDIT_MINTER) 
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L35-L35)

```43:     function setMaxDelegates(
44:         uint256 newMax
45:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L43-L43)

```50:     function setContractExceedMaxDelegates(
51:         address account,
52:         bool canExceedMax
53:     ) external onlyCoreRole(CoreRoles.CREDIT_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L50-L50)

```58:     function forceEnterRebase(
59:         address account
60:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) 
```

*GitHub* : [58](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L58-L58)

```69:     function forceExitRebase(
70:         address account
71:     ) external onlyCoreRole(CoreRoles.CREDIT_REBASE_PARAMETERS) 
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L69-L69)

```83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L83)

```90:     function _burn(
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) 
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L90)

```98:     function balanceOf(
99:         address account
100:     ) public view override(ERC20, ERC20RebaseDistributor) returns (uint256) 
```

*GitHub* : [98](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L98-L98)

```104:     function totalSupply()
105:         public
106:         view
107:         override(ERC20, ERC20RebaseDistributor)
108:         returns (uint256)
109:     
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L104-L104)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L113)

```125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L125)

```59:     function setMaxDelegates(
60:         uint256 newMax
61:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L59-L59)

```66:     function setContractExceedMaxDelegates(
67:         address account,
68:         bool canExceedMax
69:     ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L66-L66)

```76:     function addGauge(
77:         uint256 _type,
78:         address gauge
79:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) 
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L76)

```83:     function removeGauge(
84:         address gauge
85:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L83-L83)

```89:     function setMaxGauges(
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L89)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```123:     function notifyGaugeLoss(address gauge) external 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L123-L123)

```133:     function applyGaugeLoss(address gauge, address who) external 
```

*GitHub* : [133](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L133-L133)

```175:     function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L175-L175)

```197:     function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [197](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L197-L197)

```268:     function mint(
269:         address to,
270:         uint256 amount
271:     ) external onlyCoreRole(CoreRoles.GUILD_MINTER) 
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L268-L268)

```279:     function _burn(
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) 
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L279)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L288)

```302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L302)

```67:     function getAuction(bytes32 loanId) external view returns (Auction memory) 
```

*GitHub* : [67](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L67-L67)

```75:     function startAuction(bytes32 loanId, uint256 callDebt) external 
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L75-L75)

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) 
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L118-L118)

```160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external 
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L160)

```176:     function getReferences()
177:         external
178:         view
179:         returns (LendingTermReferences memory)
180:     
```

*GitHub* : [176](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L176-L176)

```185:     function getParameters() external view returns (LendingTermParams memory) 
```

*GitHub* : [185](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L185-L185)

```190:     function collateralToken() external view returns (address) 
```

*GitHub* : [190](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L190-L190)

```195:     function getLoan(bytes32 loanId) external view returns (Loan memory) 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L195-L195)

```200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) 
```

*GitHub* : [200](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L200-L200)

```237:     function partialRepayDelayPassed(
238:         bytes32 loanId
239:     ) public view returns (bool) 
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L237-L237)

```334:     function debtCeiling() external view returns (uint256) 
```

*GitHub* : [334](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L334-L334)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) 
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L339)

```438:     function borrow(
439:         uint256 borrowAmount,
440:         uint256 collateralAmount
441:     ) external whenNotPaused returns (bytes32 loanId) 
```

*GitHub* : [438](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L438-L438)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal 
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```482:     function addCollateral(bytes32 loanId, uint256 collateralToAdd) external 
```

*GitHub* : [482](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L482-L482)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal 
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```562:     function partialRepay(bytes32 loanId, uint256 debtToRepay) external 
```

*GitHub* : [562](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L562-L562)

```567:     function _repay(address repayer, bytes32 loanId) internal 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```628:     function repay(bytes32 loanId) external 
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L628-L628)

```634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal 
```

*GitHub* : [634](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L634-L634)

```678:     function call(bytes32 loanId) external 
```

*GitHub* : [678](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L678-L678)

```683:     function callMany(bytes32[] memory loanIds) public 
```

*GitHub* : [683](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L683-L683)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [695](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L695-L695)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external 
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```829:     function setAuctionHouse(
830:         address _newValue
831:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [829](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L829-L829)

```846:     function setHardCap(
847:         uint256 _newValue
848:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [846](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L846-L846)

```80:     function getMintAmountOut(uint256 amountIn) public view returns (uint256) 
```

*GitHub* : [80](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L80-L80)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) 
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L87-L87)

```97:     function redeemableCredit() public view returns (uint256) 
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L97-L97)

```149:     function setRedemptionsPaused(
150:         bool paused
151:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L149-L149)

```106:     function getUserStake(
107:         address user,
108:         address term
109:     ) external view returns (UserStake memory) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L106-L106)

```114:     function stake(address term, uint256 amount) external whenNotPaused 
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L114)

```158:     function unstake(address term, uint256 amount) external 
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L158-L158)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L216)

```293:     function updateMintRatio(address user, address term) external 
```

*GitHub* : [293](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L293-L293)

```319:     function setMintRatio(
320:         uint256 _mintRatio
321:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L319-L319)

```328:     function setRewardRatio(
329:         uint256 _rewardRatio
330:     ) external onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [328](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L328-L328)

```49:     function mint(
50:         address to,
51:         uint256 amount
52:     ) external onlyCoreRole(role) whenNotPaused 
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L49-L49)

```60:     function replenishBuffer(uint256 amount) external onlyCoreRole(role) 
```

*GitHub* : [60](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L60-L60)

```61:     function setRateLimitPerSecond(
62:         uint128 newRateLimitPerSecond
63:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L61-L61)

```75:     function setBufferCap(
76:         uint128 newBufferCap
77:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) 
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L75-L75)

```93:     function _depleteBuffer(uint256 amount) internal 
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L93-L93)

```111:     function _replenishBuffer(uint256 amount) internal 
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L111-L111)

```138:     function _setRateLimitPerSecond(uint128 newRateLimitPerSecond) internal 
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L138-L138)

```149:     function _setBufferCap(uint128 newBufferCap) internal 
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L149-L149)

```158:     function _updateBufferStored(uint128 newBufferCap) internal 
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L158)
### [NC-141]<a name="nc-141"></a> Natspec @notice comments are missing from function

*There are 65 instance(s) of this issue:*

```68:     function _setQuorum(uint256 newQuorum) internal 
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L68)

```123:     function _cancel(
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```132:     function _execute(
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) 
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```142:     function _executor()
143:         internal
144:         view
145:         override(Governor, GovernorTimelockControl)
146:         returns (address)
147:     
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L142-L142)

```151:     function proposalThreshold()
152:         public
153:         view
154:         override(Governor, GovernorSettings)
155:         returns (uint256)
156:     
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L151-L151)

```160:     function state(
161:         uint256 proposalId
162:     )
163:         public
164:         view
165:         override(Governor, GovernorTimelockControl)
166:         returns (ProposalState)
167:     
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L160-L160)

```171:     function supportsInterface(
172:         bytes4 interfaceId
173:     ) public view override(Governor, GovernorTimelockControl) returns (bool) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L171-L171)

```30:     function hasRole(
31:         bytes32 role,
32:         address account
33:     ) public view virtual override returns (bool) 
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L30-L30)

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override 
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override 
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override 
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```171:     function propose(
172:         address[] memory ,
173:         uint256[] memory ,
174:         bytes[] memory ,
175:         string memory 
176:     ) public pure override(IGovernor, Governor) returns (uint256) 
```

*GitHub* : [171](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L171-L171)

```57:     function quorum(
58:         uint256 
59:     ) public view override returns (uint256) 
```

*GitHub* : [57](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L57-L57)

```71:     function _setQuorum(uint256 newQuorum) internal virtual 
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L71-L71)

```99:     function _updateTimelock(address newTimelock) private 
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L99-L99)

```130:     function COUNTING_MODE()
131:         public
132:         pure
133:         virtual
134:         override
135:         returns (string memory)
136:     
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L130-L130)

```143:     function hasVoted(
144:         uint256 proposalId,
145:         address account
146:     ) public view virtual override returns (bool) 
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L143-L143)

```153:     function proposalVotes(
154:         uint256 proposalId
155:     )
156:         public
157:         view
158:         virtual
159:         returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes)
160:     
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L153-L153)

```172:     function _quorumReached(
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L172)

```186:     function _voteSucceeded(
187:         uint256 
188:     ) internal pure virtual override returns (bool) 
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L186)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L195)

```222:     function votingDelay() public pure override returns (uint256) 
```

*GitHub* : [222](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L222-L222)

```230:     function votingPeriod() public pure override returns (uint256) 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L230-L230)

```304:     function propose(
305:         address[] memory ,
306:         uint256[] memory ,
307:         bytes[] memory ,
308:         string memory 
309:     ) public pure override returns (uint256) 
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L304-L304)

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L367)

```230:     function _incrementGaugeWeight(
231:         address user,
232:         address gauge,
233:         uint256 weight
234:     ) internal virtual 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L230-L230)

```249:     function _incrementUserAndGlobalWeights(
250:         address user,
251:         uint256 weight
252:     ) internal returns (uint256 newUserWeight) 
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L249-L249)

```314:     function _decrementGaugeWeight(
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual 
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L314-L314)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) 
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)

```425:     function _removeGauge(address gauge) internal 
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L425-L425)

```403:     function _burn(address from, uint256 amount) internal virtual override 
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) 
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L408)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) 
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L416)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal 
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L500-L500)

```103:     function _checkpointsLookup(
104:         Checkpoint[] storage ckpts,
105:         uint256 blockNumber
106:     ) private view returns (uint256) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L103-L103)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) 
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual 
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L290)

```317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual 
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L317)

```344:     function _undelegate(
345:         address delegator,
346:         address delegatee,
347:         uint256 amount
348:     ) internal virtual 
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L344-L344)

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private 
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L363)

```387:     function _add(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L387-L387)

```391:     function _subtract(uint256 a, uint256 b) private pure returns (uint256) 
```

*GitHub* : [391](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L391-L391)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal 
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L427-L427)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public 
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)

```289:     function _enterRebase(address account) internal 
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L289)

```311:     function _exitRebase(address account) internal 
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L311)

```83:     function _mint(
84:         address account,
85:         uint256 amount
86:     ) internal override(ERC20, ERC20RebaseDistributor) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L83)

```90:     function _burn(
91:         address account,
92:         uint256 amount
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor) 
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L90)

```98:     function balanceOf(
99:         address account
100:     ) public view override(ERC20, ERC20RebaseDistributor) returns (uint256) 
```

*GitHub* : [98](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L98-L98)

```104:     function totalSupply()
105:         public
106:         view
107:         override(ERC20, ERC20RebaseDistributor)
108:         returns (uint256)
109:     
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L104-L104)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L113)

```125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L125)

```76:     function addGauge(
77:         uint256 _type,
78:         address gauge
79:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) 
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L76)

```83:     function removeGauge(
84:         address gauge
85:     ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) 
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L83-L83)

```89:     function setMaxGauges(
90:         uint256 max
91:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L89-L89)

```95:     function setCanExceedMaxGauges(
96:         address who,
97:         bool can
98:     ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) 
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L95-L95)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override 
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L182)

```207:     function _decrementGaugeWeight(
208:         address user,
209:         address gauge,
210:         uint256 weight
211:     ) internal override 
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L207-L207)

```242:     function _incrementGaugeWeight(
243:         address user,
244:         address gauge,
245:         uint256 weight
246:     ) internal override 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L242-L242)

```279:     function _burn(
280:         address from,
281:         uint256 amount
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) 
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L279)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L288)

```302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L302)

```138:     function _setRateLimitPerSecond(uint128 newRateLimitPerSecond) internal 
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L138-L138)

```149:     function _setBufferCap(uint128 newBufferCap) internal 
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L149-L149)

```158:     function _updateBufferStored(uint128 newBufferCap) internal 
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L158)
### [NC-142]<a name="nc-142"></a> Natspec @dev comments are missing from constructor

*There are 16 instance(s) of this issue:*

```12:     constructor() 
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L12-L12)

```19:     constructor(address coreAddress) 
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L19)

```30:     constructor(
31:         address _core,
32:         address _timelock,
33:         address _token,
34:         uint256 initialVotingDelay,
35:         uint256 initialVotingPeriod,
36:         uint256 initialProposalThreshold,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Governor")
41:         GovernorVotes(IVotes(_token))
42:         GovernorTimelockControl(TimelockController(payable(_timelock)))
43:         GovernorSettings(
44:             initialVotingDelay,
45:             initialVotingPeriod,
46:             initialProposalThreshold
47:         )
48:     
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L30-L30)

```15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L15-L15)

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L66)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L63)

```106:     constructor(address _core) CoreRef(_core) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L106-L106)

```32:     constructor(
33:         address _core,
34:         address initialTimelock,
35:         address _token,
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L32-L32)

```24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L24-L24)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L43)

```56:     constructor(
57:         address _core,
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) 
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L56-L56)

```153:     constructor() CoreRef(address(1)) 
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L153-L153)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) 
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L65)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) 
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L88)

```30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L30-L30)

```40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) 
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L40-L40)
### [NC-143]<a name="nc-143"></a> Natspec @notice comments are missing from constructor

*There are 14 instance(s) of this issue:*

```19:     constructor(address coreAddress) 
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L19)

```30:     constructor(
31:         address _core,
32:         address _timelock,
33:         address _token,
34:         uint256 initialVotingDelay,
35:         uint256 initialVotingPeriod,
36:         uint256 initialProposalThreshold,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Governor")
41:         GovernorVotes(IVotes(_token))
42:         GovernorTimelockControl(TimelockController(payable(_timelock)))
43:         GovernorSettings(
44:             initialVotingDelay,
45:             initialVotingPeriod,
46:             initialProposalThreshold
47:         )
48:     
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L30-L30)

```15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L15-L15)

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L66)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L63)

```106:     constructor(address _core) CoreRef(_core) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L106-L106)

```32:     constructor(
33:         address _core,
34:         address initialTimelock,
35:         address _token,
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L32-L32)

```24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L24-L24)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L43)

```56:     constructor(
57:         address _core,
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) 
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L56-L56)

```153:     constructor() CoreRef(address(1)) 
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L153-L153)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) 
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L65)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) 
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L88)

```30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L30-L30)
### [NC-144]<a name="nc-144"></a> Natspec @params comments are missing from constructor

*There are 12 instance(s) of this issue:*

```19:     constructor(address coreAddress) 
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L19)

```30:     constructor(
31:         address _core,
32:         address _timelock,
33:         address _token,
34:         uint256 initialVotingDelay,
35:         uint256 initialVotingPeriod,
36:         uint256 initialProposalThreshold,
37:         uint256 initialQuorum
38:     )
39:         CoreRef(_core)
40:         Governor("ECG Governor")
41:         GovernorVotes(IVotes(_token))
42:         GovernorTimelockControl(TimelockController(payable(_timelock)))
43:         GovernorSettings(
44:             initialVotingDelay,
45:             initialVotingPeriod,
46:             initialProposalThreshold
47:         )
48:     
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L30-L30)

```15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L15-L15)

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) 
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L66)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L63)

```106:     constructor(address _core) CoreRef(_core) 
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L106-L106)

```32:     constructor(
33:         address _core,
34:         address initialTimelock,
35:         address _token,
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L32-L32)

```24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L24-L24)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L43)

```56:     constructor(
57:         address _core,
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) 
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L56-L56)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) 
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L65)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) 
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L88)
### [NC-145]<a name="nc-145"></a> Natspec @dev comments are missing from enum

*There are 1 instance(s) of this issue:*

```35:     enum LoanCloseType {
36:         Repay,
37:         Call,
38:         Forgive
39:     }
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L35-L35)
### [NC-146]<a name="nc-146"></a> Natspec @notice comments are missing from enum

*There are 1 instance(s) of this issue:*

```111:     enum VoteType {
112:         Against,
113:         For,
114:         Abstain
115:     }
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L111-L111)
### [NC-147]<a name="nc-147"></a> Natspec comments are missing from unchecked blocks

*There are 4 instance(s) of this issue:*

```445:             unchecked {
446:                 ++i;
447:             }
```

*GitHub* : [445](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L445-L445)

```180:               unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
```

*GitHub* : [180](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L180-L180)

```137:               unchecked {
138:                     ++j;
139:                 }
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L137-L137)

```532:                 unchecked {
533:                     ++i;
534:                 }
```

*GitHub* : [532](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L532-L532)
### [NC-148]<a name="nc-148"></a> ERC777 tokens can introduce reentrancy risks
ERC777 is an advanced token standard that introduces hooks, allowing operators to execute additional logic during transfers. While this feature offers greater flexibility, it also opens up the possibility of reentrancy attacks. Specifically, when tokens are sent, the receiving contract's `tokensReceived` hook gets called, and this external call can execute arbitrary code. An attacker can exploit this feature to re-enter the original function, potentially leading to double-spending or other types of financial manipulation.

To mitigate reentrancy risks with ERC777, it's crucial to adopt established security measures, such as utilizing reentrancy guards or following the check-effects-interactions pattern. Some developers opt to stick with the simpler ERC20 standard, which does not have these hooks, to minimize this risk. If you do choose to use ERC777, extreme caution and thorough auditing are advised to secure against potential reentrancy vulnerabilities.

*There are 15 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external { // <= FOUND
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external { // <= FOUND
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```489:     function transferFrom(
490:         address from,
491:         address to,
492:         uint256 amount
493:     ) public virtual override returns (bool) {
494:         _decrementWeightUntilFree(from, amount);
495:         return super.transferFrom(from, to, amount); // <= FOUND
496:     }
```

*GitHub* : [489](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L489-L495)

```416:     function transferFrom(
417:         address from,
418:         address to,
419:         uint256 amount
420:     ) public virtual override returns (bool) {
421:         _decrementVotesUntilFree(from, amount);
422:         return super.transferFrom(from, to, amount); // <= FOUND
423:     }
```

*GitHub* : [416](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L416-L422)

```646:     function transferFrom(
647:         address from,
648:         address to,
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         
652:         
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
657:             rebasingStateTo.isRebasing == 1)
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) {
661:             uint256 shares = uint256(rebasingStateFrom.nShares);
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount;
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         
678:         bool success = ERC20.transferFrom(from, to, amount);
679: 
680:         
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) {
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
689:             sharesDelta -= int256(sharesSpent);
690:             rebasingState[from] = RebasingState({
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
696:         
697:         if (rebasingStateTo.isRebasing == 1) {
698:             
699:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
700:             uint256 toBalanceAfter = _shares2balance(
701:                 rebasingStateTo.nShares,
702:                 _rebasingSharePrice,
703:                 amount,
704:                 rawToBalanceAfter
705:             );
706: 
707:             
708:             uint256 toSharesAfter = _balance2shares(
709:                 toBalanceAfter,
710:                 _rebasingSharePrice
711:             );
712:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
713:             sharesDelta += int256(sharesReceived);
714:             rebasingState[to] = RebasingState({
715:                 isRebasing: 1,
716:                 nShares: uint248(toSharesAfter)
717:             });
718: 
719:             
720:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
721:             if (mintAmount != 0) {
722:                 ERC20._mint(to, mintAmount);
723:                 decreaseUnmintedRebaseRewards(mintAmount);
724:                 emit RebaseReward(to, block.timestamp, mintAmount);
725:             }
726:         }
727: 
728:         
729:         if (
730:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1
731:         ) {
732:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
733:         }
734: 
735:         return success;
736:     }
```

*GitHub* : [646](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L646-L646)

```125:     function transferFrom(
126:         address from,
127:         address to,
128:         uint256 amount
129:     )
130:         public
131:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
132:         returns (bool)
133:     {
134:         _decrementVotesUntilFree(from, amount); 
135:         return ERC20RebaseDistributor.transferFrom(from, to, amount); // <= FOUND
136:     }
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L125-L135)

```302:     function transferFrom(
303:         address from,
304:         address to,
305:         uint256 amount
306:     )
307:         public
308:         virtual
309:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
310:         returns (bool)
311:     {
312:         _decrementWeightUntilFree(from, amount);
313:         _decrementVotesUntilFree(from, amount);
314:         return ERC20.transferFrom(from, to, amount); // <= FOUND
315:     }
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L302-L314)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L339)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal {
453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0");
454: 
455:         Loan storage loan = loans[loanId];
456: 
457:         
458:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
459:         require(loan.closeTime == 0, "LendingTerm: loan closed");
460:         require(loan.callTime == 0, "LendingTerm: loan called");
461: 
462:         
463:         loans[loanId].collateralAmount += collateralToAdd;
464: 
465:         
466:         IERC20(params.collateralToken).safeTransferFrom(
467:             borrower,
468:             address(this),
469:             collateralToAdd
470:         );
471: 
472:         
473:         emit LoanAddCollateral(
474:             block.timestamp,
475:             loanId,
476:             borrower,
477:             collateralToAdd
478:         );
479:     }
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L109)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn;
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L117-L126)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)### GAS Risk Issues


### [GAS-01]<a name="gas-01"></a> Internal functions never used once can be removed 
Internal functions which are never used use unnecessary gas and should be safely removed.

*There are 6 instance(s) of this issue:*

```132:     function _execute( // <= FOUND
133:         uint256 proposalId,
134:         address[] memory targets,
135:         uint256[] memory values,
136:         bytes[] memory calldatas,
137:         bytes32 descriptionHash
138:     ) internal override(Governor, GovernorTimelockControl) 
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L132)

```142:     function _executor() // <= FOUND
143:         internal
144:         view
145:         override(Governor, GovernorTimelockControl)
146:         returns (address)
147:     
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L142-L142)

```44:     function _revokeRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```186:     function _voteSucceeded( // <= FOUND
187:         uint256 
188:     ) internal pure virtual override returns (bool) 
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L186)

```195:     function _countVote( // <= FOUND
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override 
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L195)

```182:     function _beforeTokenTransfer( // <= FOUND
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override 
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L182)
### [GAS-02]<a name="gas-02"></a> Some error strings are not descriptive 
Consider adding more detail to these error strings

*There are 4 instance(s) of this issue:*

```314:     function _decrementGaugeWeight(
315:         address user,
316:         address gauge,
317:         uint256 weight
318:     ) internal virtual {
319:         uint256 oldWeight = getUserGaugeWeight[user][gauge];
320: 
321:         getUserGaugeWeight[user][gauge] = oldWeight - weight;
322:         if (oldWeight == weight) {
323:             
324:             require(_userGauges[user].remove(gauge)); // <= FOUND
325:         }
326: 
327:         getGaugeWeight[gauge] -= weight;
328: 
329:         getUserWeight[user] -= weight;
330: 
331:         emit DecrementGaugeWeight(user, gauge, weight);
332:     }
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L324-L324)

```344:     function _undelegate(
345:         address delegator,
346:         address delegatee,
347:         uint256 amount
348:     ) internal virtual {
349:         uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] -
350:             amount;
351: 
352:         if (newDelegates == 0) {
353:             require(_delegates[delegator].remove(delegatee)); // <= FOUND
354:         }
355: 
356:         _delegatesVotesCount[delegator][delegatee] = newDelegates;
357:         userDelegatedVotes[delegator] -= amount;
358: 
359:         emit Undelegation(delegator, delegatee, amount);
360:         _writeCheckpoint(delegatee, _subtract, amount);
361:     }
```

*GitHub* : [353](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L353-L353)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal {
428:         uint256 userFreeVotes = freeVotes(user);
429: 
430:         
431:         if (userFreeVotes >= votes) return;
432: 
433:         
434:         uint256 totalFreed;
435: 
436:         
437:         address[] memory delegateList = _delegates[user].values();
438: 
439:         
440:         uint256 size = delegateList.length;
441:         for (
442:             uint256 i = 0;
443:             i < size && (userFreeVotes + totalFreed) < votes;
444:             i++
445:         ) {
446:             address delegatee = delegateList[i];
447:             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];
448:             if (delegateVotes != 0) {
449:                 totalFreed += delegateVotes;
450: 
451:                 require(_delegates[user].remove(delegatee));  // <= FOUND
452: 
453:                 _delegatesVotesCount[user][delegatee] = 0;
454: 
455:                 _writeCheckpoint(delegatee, _subtract, delegateVotes);
456:                 emit Undelegation(user, delegatee, delegateVotes);
457:             }
458:         }
459: 
460:         userDelegatedVotes[user] -= totalFreed;
461:     }
```

*GitHub* : [451](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L451-L451)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0)); // <= FOUND
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [503](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L503-L503)
### [GAS-03]<a name="gas-03"></a> Lack of unchecked in loops 
In Solidity, the `unchecked` block allows arithmetic operations to not revert on overflow. Without using `unchecked` in loops, extra gas is consumed due to overflow checks. If it's certain that overflows won't occur within the loop, using `unchecked` can make the loop more gas-efficient by skipping unnecessary checks.

*There are 2 instance(s) of this issue:*

```96:        for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```685:        for (uint256 i = 0; i < loanIds.length; i++) {
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [GAS-04]<a name="gas-04"></a> Multiple accesses of the same mapping/array key/index should be cached 
Caching repeated accesses to the same mapping or array key/index in smart contracts can lead to significant gas savings. In Solidity, each read operation from storage (like accessing a value in a mapping or array using a key or index) costs gas. By storing the accessed value in a local variable and reusing it within the function, you avoid multiple expensive storage read operations. This practice is particularly beneficial in loops or functions with multiple reads of the same data. Implementing this caching approach enhances efficiency and reduces transaction costs, which is crucial for optimizing smart contract performance and user experience on the blockchain.

*There are 2 instance(s) of this issue:*

```89:     function proposeOffboard(address term) external whenNotPaused {
90:         require(
91:             polls[block.number][term] == 0, // <= FOUND
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS, // <= FOUND
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1;  // <= FOUND
105:         lastPollBlock[term] = block.number; // <= FOUND
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L105)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge]; // <= FOUND
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0; // <= FOUND
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge]; // <= FOUND
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] = // <= FOUND
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L396)
### [GAS-05]<a name="gas-05"></a> State variables used within a function more than once should be cached to save gas 
Cache such variables and perform operations on them, if operations include modifications to the state variable(s) then remember to equate the state variable to it's cached counterpart at the end

*There are 1 instance(s) of this issue:*

```168:     function updateTotalRebasingShares( // <= FOUND
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             }); // <= FOUND
196:             __unmintedRebaseRewards = InterpolatedValue({
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             }); // <= FOUND
202:             return;
203:         }
204: 
205:         
206:         
207:         
208:         
209:         
210:         InterpolatedValue memory val = __rebasingSharePrice; // <= FOUND
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice +
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
218:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), 
221:                 targetTimestamp: val.targetTimestamp, 
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) 
223:             }); // <= FOUND
224:         }
225:     }
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L223)
### [GAS-06]<a name="gas-06"></a> Shorten the array rather than copying to a new one 
Leveraging inline assembly in Solidity provides the ability to directly manipulate the length slot of an array, thereby altering its length without the need to copy the elements to a new array of the desired size. This technique is more gas-efficient as it avoids the computational expense associated with array duplication. However, this method circumvents the type-checking and safety mechanisms of high-level Solidity and should be used judiciously. Always ensure that the array doesn't contain vital data beyond the revised length, as this data will become unreachable yet still consume storage space.

*There are 9 instance(s) of this issue:*

```95:         returnData = new bytes[](calls.length); // <= FOUND
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L95-L95)

```227:         targets = new address[](3); // <= FOUND
```

*GitHub* : [227](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L227-L227)

```228:         values = new uint256[](3); // <= FOUND
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L228-L228)

```229:         calldatas = new bytes[](3); // <= FOUND
```

*GitHub* : [229](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L229-L229)

```465:         creditEarned = new uint256[](gauges.length); // <= FOUND
```

*GitHub* : [465](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L465-L465)

```379:         targets = new address[](1); // <= FOUND
```

*GitHub* : [379](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L379-L379)

```381:         values = new uint256[](1);  // <= FOUND
```

*GitHub* : [381](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L381-L381)

```382:         calldatas = new bytes[](1); // <= FOUND
```

*GitHub* : [382](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L382-L382)

```129:         _liveGauges = new address[]( // <= FOUND
130:             _gauges.length() - _deprecatedGauges.length()
131:         );
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L129-L129)
### [GAS-07]<a name="gas-07"></a> Using bools for storage incurs overhead 
Using boolean variables (`bool`) for storage in Solidity can incur overhead due to the way data is packed in Ethereum's storage layout. A `bool` takes a full storage slot, even though it represents only a true or false value. This leads to inefficient usage of storage space and potentially higher gas costs. To resolve this issue, developers can use bit fields or uint8/uint256 to pack multiple boolean values into a single storage slot. By employing such optimization techniques, it's possible to save on storage space and reduce gas costs, making the contract more efficient.

*There are 8 instance(s) of this issue:*

```199: 
200:         
201:         
202:         
203:         
204:         
205:         bool isGauge = GuildToken(guildToken).isGauge(term); // <= FOUND
```

*GitHub* : [199](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L199-L205)

```235:         bool added = _userGauges[user].add(gauge);  // <= FOUND
```

*GitHub* : [235](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L235-L235)

```399:         bool newAdd = _gauges.add(gauge); // <= FOUND
```

*GitHub* : [399](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L399-L399)

```400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge); // <= FOUND
```

*GitHub* : [400](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L400-L400)

```329: 
330:         bool newDelegate = _delegates[delegator].add(delegatee);  // <= FOUND
```

*GitHub* : [329](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L329-L330)

```169: 
176:     bool public transferable;  // <= FOUND
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L169-L176)

```46: 
48:     bool public redemptionsPaused; // <= FOUND
```

*GitHub* : [46](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L46-L48)

```227:         bool updateState; // <= FOUND
```

*GitHub* : [227](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L227-L227)
### [GAS-08]<a name="gas-08"></a> Low level call can be optimized with assembly
Low-level calls, when optimized with assembly, can save gas by avoiding unnecessary operations related to unused returndata. In a typical `.call`, Solidity automatically allocates memory and handles returndata even if it's not used, incurring extra gas costs. By using assembly, a developer can precisely control the execution, selectively ignoring or handling returndata, thereby optimizing gas usage. This specific control over the EVM allows for more efficient execution of calls by eliminating unnecessary memory operations, providing a more gas-efficient method when unused returndata is a concern. However, such optimization should be handled with care, as improper use of assembly might lead to vulnerabilities.

*There are 14 instance(s) of this issue:*

```99:             bytes calldata callData = calls[i].callData; // <= FOUND
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L99-L99)

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [102](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L102-L102)

```114:         
115:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
116:             abi.encodeWithSelector(IERC20.totalSupply.selector)
117:         );
```

*GitHub* : [115](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L115-L115)

```84:         require(
85:             loan.callTime == block.timestamp, // <= FOUND
86:             "AuctionHouse: loan previously called"
87:         );
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L85-L85)

```136:             
137:             creditAsked = auctions[loanId].callDebt; // <= FOUND
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L137-L137)

```151:             uint256 _callDebt = auctions[loanId].callDebt;  // <= FOUND
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L151-L151)

```212: 
213:         if (loan.callTime != 0) { // <= FOUND
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L213-L213)

```213:             return loan.callDebt; // <= FOUND
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L213-L213)

```460:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L460)

```460: 
461:         
462:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [462](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L462-L462)

```666:         loans[loanId].callTime = block.timestamp; // <= FOUND
```

*GitHub* : [666](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L666-L666)

```667:         loans[loanId].callDebt = loanDebt; // <= FOUND
```

*GitHub* : [667](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L667-L667)

```668:         loans[loanId].caller = caller; // <= FOUND
```

*GitHub* : [668](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L668-L668)

```734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0, // <= FOUND
736:             "LendingTerm: loan not called"
737:         );
```

*GitHub* : [735](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L735-L735)
### [GAS-09]<a name="gas-09"></a> Optimize by Using Assembly for Low-Level Calls' Return Data
Using assembly for low-level calls in Solidity can provide gas savings, especially when dealing with return data. High-level Solidity calls include overhead for decoding return data, which can be bypassed with assembly. By directly accessing return data in assembly, you can eliminate unnecessary memory allocation and data copying, leading to a more gas-efficient execution. However, this approach requires a deep understanding of the Ethereum Virtual Machine (EVM) and is prone to errors. It’s crucial to ensure security and correctness in the implementation. This technique is best suited for advanced users aiming to optimize contract performance in specific, gas-critical scenarios.

*There are 2 instance(s) of this issue:*

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L101-L102)

```114:         
115:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
116:             abi.encodeWithSelector(IERC20.totalSupply.selector)
117:         );
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L114-L115)
### [GAS-10]<a name="gas-10"></a> Low level call can be optimized with assembly
Optimizing low-level calls using assembly in Solidity can be beneficial, particularly when dealing with function return data. Typically, even if return data from a low-level call is not used, Solidity still allocates memory to store it, which incurs gas costs. By using assembly, developers can bypass the automatic memory allocation for unused return data. This manual optimization involves handling the call at the assembly level and deliberately choosing not to store the return data in memory when it's not needed.

*There are 2 instance(s) of this issue:*

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [102](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L102-L102)

```114:         
115:         (bool success, bytes memory returned) = params.collateralToken.call( // <= FOUND
116:             abi.encodeWithSelector(IERC20.totalSupply.selector)
117:         );
```

*GitHub* : [115](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L115-L115)
### [GAS-11]<a name="gas-11"></a> Unbounded Gas Consumption Risk Due to External Call Recipients
In the context of Solidity, external function calls without a specified gas limit present a significant risk. The callee contract has the potential to consume all the gas allocated to the transaction, causing an undesired revert and disrupt the function's execution. To mitigate this, it's recommended to explicitly set a gas limit when performing external calls using addr.call{gas: <amount>}. This limits the gas forwarded to the callee, preventing potential pitfalls and offering better control over transaction execution.

*There are 1 instance(s) of this issue:*

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params);
167:         return term;
168:     }
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L105)
### [GAS-12]<a name="gas-12"></a> Consider Using Solady's Gas Optimized Lib for Math
In instances where many similar mathematical operations are performed, consider using Solday's math lib to benefit from the gas saving it can introduce.

*There are 20 instance(s) of this issue:*

```152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L152-L152)

```429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [429](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L429-L429)

```483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [483](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L483-L483)

```192: 
193:         return (quantity * weight) / total; // <= FOUND
```

*GitHub* : [192](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L192-L193)

```256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
```

*GitHub* : [256](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L256-L256)

```141:             collateralReceived = (_collateralAmount * elapsed) / midPoint; // <= FOUND
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L141-L141)

```152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L152-L152)

```226:             loanDebt += (borrowAmount * _openingFee) / 1e18; // <= FOUND
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L226-L226)

```230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L230-L230)

```383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18; // <= FOUND
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L383-L387)

```510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt;  // <= FOUND
```

*GitHub* : [510](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L510-L510)

```516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [516](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L516-L516)

```518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [518](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L518-L518)

```523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18, // <= FOUND
525:             "LendingTerm: repay below min"
526:         );
```

*GitHub* : [523](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L523-L524)

```83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L83-L83)

```92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)

```134:         uint256 guildAmount = (_mintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L134-L134)

```177:         uint256 guildAmount = (userMintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L177-L177)

```252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18; // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L252-L252)

```302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18; // <= FOUND
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L302-L302)
### [GAS-13]<a name="gas-13"></a> x + y is more efficient than using += for state variables (likewise for -=)
In instances found where either += or -= are used against state variables use x = x + y instead

*There are 16 instance(s) of this issue:*

```158:     function unstake(address term, uint256 amount) external {
159:         
160:         (, UserStake memory userStake, bool slashed) = getRewards(
161:             msg.sender,
162:             term
163:         );
164: 
165:         
166:         if (slashed) return;
167: 
168:         
169:         require(
170:             amount != 0 && userStake.credit >= amount,
171:             "SurplusGuildMinter: invalid amount"
172:         );
173: 
174:         
175:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /
176:             userStake.credit; 
177:         uint256 guildAmount = (userMintRatio * amount) / 1e18;
178: 
179:         if (amount == userStake.credit) guildAmount = userStake.guild;
180: 
181:         userStake.credit -= SafeCastLib.safeCastTo128(amount); // <= FOUND
182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount); // <= FOUND
183: 
184:         if (userStake.credit == 0) {
185:             userStake.stakeTime = 0;
186:             userStake.lastGaugeLoss = 0;
187:             userStake.profitIndex = 0;
188:         } else {
189:             
190:             
191:             require(
192:                 userStake.credit >= MIN_STAKE,
193:                 "SurplusGuildMinter: remaining stake below min"
194:             );
195:         }
196:         _stakes[msg.sender][term] = userStake;
197: 
198:         
199:         ProfitManager(profitManager).withdrawFromTermSurplusBuffer(
200:             term,
201:             msg.sender,
202:             amount
203:         );
204: 
205:         
206:         GuildToken(guild).decrementGauge(term, guildAmount);
207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
208:         GuildToken(guild).burn(guildAmount);
209: 
210:         
211:         emit Unstake(block.timestamp, term, amount);
212:     }
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L181-L182)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer; // <= FOUND
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L312-L312)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease; // <= FOUND
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [536](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L536-L536)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount; // <= FOUND
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* : [615](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L615-L615)

```695:     function forgive(bytes32 loanId) external onlyCoreRole(CoreRoles.GOVERNOR) {
696:         Loan storage loan = loans[loanId];
697: 
698:         
699:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
700: 
701:         
702:         require(loan.closeTime == 0, "LendingTerm: loan closed");
703: 
704:         
705:         loans[loanId].closeTime = block.timestamp;
706:         issuance -= loan.borrowAmount; // <= FOUND
707: 
708:         
709:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
710:             .creditMultiplier();
711:         uint256 borrowAmount = loans[loanId].borrowAmount;
712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
714:         int256 pnl = -int256(principal);
715:         ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
716: 
717:         
718:         params.hardCap = 0;
719: 
720:         
721:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0);
722:     }
```

*GitHub* : [706](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L706-L706)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount; // <= FOUND
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [801](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L801-L801)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn; // <= FOUND
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [108](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L108-L108)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn; // <= FOUND
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn);
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L125-L125)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut; // <= FOUND
142:         ERC20(pegToken).safeTransfer(to, amountOut);
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L141-L141)

```249:     function _incrementUserAndGlobalWeights(
250:         address user,
251:         uint256 weight
252:     ) internal returns (uint256 newUserWeight) {
253:         newUserWeight = getUserWeight[user] + weight;
254:         
255:         require(newUserWeight <= balanceOf(user), "ERC20Gauges: overweight");
256: 
257:         
258:         getUserWeight[user] = newUserWeight;
259: 
260:         totalWeight += weight; // <= FOUND
261:     }
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L260-L260)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) {
399:         bool newAdd = _gauges.add(gauge);
400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge);
401:         
402:         require(
403:             gauge != address(0) && (newAdd || previouslyDeprecated),
404:             "ERC20Gauges: invalid gauge"
405:         );
406: 
407:         if (newAdd) {
408:             
409:             gaugeType[gauge] = _type;
410:         } else {
411:             
412:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type");
413:         }
414: 
415:         
416:         weight = getGaugeWeight[gauge];
417:         if (weight != 0) {
418:             totalTypeWeight[_type] += weight;
419:             totalWeight += weight; // <= FOUND
420:         }
421: 
422:         emit AddGauge(gauge, _type);
423:     }
```

*GitHub* : [419](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L419-L419)

```301:     function decrementGauge(
302:         address gauge,
303:         uint256 weight
304:     ) public virtual returns (uint256 newUserWeight) {
305:         
306:         _decrementGaugeWeight(msg.sender, gauge, weight);
307:         if (!_deprecatedGauges.contains(gauge)) {
308:             totalTypeWeight[gaugeType[gauge]] -= weight;
309:             totalWeight -= weight; // <= FOUND
310:         }
311:         return getUserWeight[msg.sender];
312:     }
```

*GitHub* : [309](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L309-L309)

```340:     function decrementGauges(
341:         address[] calldata gaugeList,
342:         uint256[] calldata weights
343:     ) public virtual returns (uint256 newUserWeight) {
344:         uint256 size = gaugeList.length;
345:         require(weights.length == size, "ERC20Gauges: size mismatch");
346: 
347:         
348:         uint256 weightsSum;
349: 
350:         
351:         
352:         for (uint256 i = 0; i < size; ) {
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i];
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight);
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i;
363:             }
364:         }
365:         totalWeight -= weightsSum; // <= FOUND
366:         return getUserWeight[msg.sender];
367:     }
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L365-L365)

```425:     function _removeGauge(address gauge) internal {
426:         
427:         require(
428:             _gauges.contains(gauge) && _deprecatedGauges.add(gauge),
429:             "ERC20Gauges: invalid gauge"
430:         );
431: 
432:         
433:         uint256 weight = getGaugeWeight[gauge];
434:         if (weight != 0) {
435:             totalTypeWeight[gaugeType[gauge]] -= weight;
436:             totalWeight -= weight; // <= FOUND
437:         }
438: 
439:         emit RemoveGauge(gauge);
440:     }
```

*GitHub* : [436](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L436-L436)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal {
501:         uint256 userFreeWeight = balanceOf(user) - getUserWeight[user];
502: 
503:         
504:         if (userFreeWeight >= weight) return;
505: 
506:         
507:         uint256 userFreed;
508:         uint256 totalFreed;
509: 
510:         
511:         address[] memory gaugeList = _userGauges[user].values();
512: 
513:         
514:         uint256 size = gaugeList.length;
515:         for (
516:             uint256 i = 0;
517:             i < size && (userFreeWeight + userFreed) < weight;
518: 
519:         ) {
520:             address gauge = gaugeList[i];
521:             uint256 userGaugeWeight = getUserGaugeWeight[user][gauge];
522:             if (userGaugeWeight != 0) {
523:                 userFreed += userGaugeWeight;
524:                 _decrementGaugeWeight(user, gauge, userGaugeWeight);
525: 
526:                 
527:                 if (!_deprecatedGauges.contains(gauge)) {
528:                     totalTypeWeight[gaugeType[gauge]] -= userGaugeWeight;
529:                     totalFreed += userGaugeWeight;
530:                 }
531: 
532:                 unchecked {
533:                     ++i;
534:                 }
535:             }
536:         }
537: 
538:         totalWeight -= totalFreed; // <= FOUND
539:     }
```

*GitHub* : [538](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L538-L538)

```133:     function applyGaugeLoss(address gauge, address who) external {
134:         
135:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
136:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];
137:         require(
138:             _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,
139:             "GuildToken: no loss to apply"
140:         );
141: 
142:         
143:         uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];
144: 
145:         
146:         lastGaugeLossApplied[gauge][who] = block.timestamp;
147:         _decrementGaugeWeight(who, gauge, _userGaugeWeight);
148:         if (!_deprecatedGauges.contains(gauge)) {
149:             totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;
150:             totalWeight -= _userGaugeWeight; // <= FOUND
151:         }
152: 
153:         
154:         _burn(who, uint256(_userGaugeWeight));
155:         emit GaugeLossApply(
156:             gauge,
157:             who,
158:             uint256(_userGaugeWeight),
159:             block.timestamp
160:         );
161:     }
```

*GitHub* : [150](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L150-L150)
### [GAS-14]<a name="gas-14"></a> There is a 32 byte length threshold for error strings, strings longer than this consume more gas
In require statements found which are longer than 32 characters, shorten these to 32 character or less

*There are 29 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) {
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted"); // <= FOUND
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L104-L104)

```89:     function proposeOffboard(address term) external whenNotPaused {
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* :

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term];
125:         require(_weight != 0, "LendingTermOffboarding: poll not found"); // <= FOUND
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight"); // <= FOUND
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0,
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight;
137:         polls[snapshotBlock][term] = _weight + userWeight;
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true;
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L125-L130)

```153:     function offboard(address term) external whenNotPaused {
154:         require(canOffboard[term], "LendingTermOffboarding: quorum not met"); // <= FOUND
155: 
156:         
157:         
158:         
159:         GuildToken(guildToken).removeGauge(term);
160: 
161:         
162:         if (
163:             nOffboardingsInProgress++ == 0 &&
164:             !SimplePSM(psm).redemptionsPaused()
165:         ) {
166:             SimplePSM(psm).setRedemptionsPaused(true);
167:         }
168: 
169:         emit Offboard(block.timestamp, term);
170:     }
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L154-L154)

```175:     function cleanup(address term) external whenNotPaused {
176:         require(canOffboard[term], "LendingTermOffboarding: quorum not met"); // <= FOUND
177:         require(
178:             LendingTerm(term).issuance() == 0,
179:             "LendingTermOffboarding: not all loans closed"
180:         );
181:         require(
182:             GuildToken(guildToken).isDeprecatedGauge(term),
183:             "LendingTermOffboarding: re-onboarded"
184:         );
185: 
186:         
187:         core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);
188:         core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);
189: 
190:         
191:         if (
192:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()
193:         ) {
194:             SimplePSM(psm).setRedemptionsPaused(false);
195:         }
196: 
197:         canOffboard[term] = false;
198:         emit Cleanup(block.timestamp, term);
199:     }
```

*GitHub* : [176](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L176-L176)

```105:     function createTerm(
106:         address implementation,
107:         LendingTerm.LendingTermParams calldata params
108:     ) external returns (address) {
109:         require(
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         );
113:         
114:         (bool success, bytes memory returned) = params.collateralToken.call(
115:             abi.encodeWithSelector(IERC20.totalSupply.selector)
116:         );
117:         require(
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
121: 
122:         require(
123:             params.maxDebtPerCollateralToken != 0, 
124:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
125:         );
126: 
127:         require(
128:             params.interestRate < 1e18, 
129:             "LendingTermOnboarding: invalid interestRate"
130:         );
131: 
132:         require(
133:             
134:             params.maxDelayBetweenPartialRepay < 31557601, 
135:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
136:         );
137: 
138:         require(
139:             params.minPartialRepayPercent < 1e18, 
140:             "LendingTermOnboarding: invalid minPartialRepayPercent"
141:         );
142: 
143:         require(
144:             params.openingFee <= 0.1e18, 
145:             "LendingTermOnboarding: invalid openingFee"
146:         );
147: 
148:         require(
149:             params.hardCap != 0, 
150:             "LendingTermOnboarding: invalid hardCap"
151:         );
152: 
153:         address term = Clones.clone(implementation);
154:         LendingTerm(term).initialize(
155:             address(core()),
156:             LendingTerm.LendingTermReferences({
157:                 profitManager: profitManager,
158:                 guildToken: guildToken,
159:                 auctionHouse: auctionHouse,
160:                 creditMinter: creditMinter,
161:                 creditToken: creditToken
162:             }),
163:             params
164:         );
165:         created[term] = block.timestamp;
166:         emit TermCreated(block.timestamp, implementation, term, params);
167:         return term;
168:     }
```

*GitHub* :

```181:     function proposeOnboard(
182:         address term
183:     ) external whenNotPaused returns (uint256 proposalId) {
184:         
185:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
186: 
187:         
188:         require(
189:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp,
190:             "LendingTermOnboarding: recently proposed"
191:         );
192:         lastProposal[term] = block.timestamp;
193: 
194:         
195:         
196:         
197:         
198:         
199:         bool isGauge = GuildToken(guildToken).isGauge(term);
200:         require(!isGauge, "LendingTermOnboarding: active term"); // <= FOUND
201: 
202:         
203:         (
204:             address[] memory targets,
205:             uint256[] memory values,
206:             bytes[] memory calldatas,
207:             string memory description
208:         ) = getOnboardProposeArgs(term);
209: 
210:         
211:         return Governor.propose(targets, values, calldatas, description);
212:     }
```

*GitHub* : [185](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L185-L200)

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support,
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId];
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true;
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* :

```315:     function createVeto(bytes32 timelockId) external returns (uint256) {
316:         
317:         uint256 timelockExecutionTime = TimelockController(payable(timelock))
318:             .getTimestamp(timelockId);
319:         require(
320:             timelockExecutionTime > 1,
321:             "GuildVetoGovernor: action must be pending"
322:         );
323: 
324:         
325:         (
326:             address[] memory targets,
327:             uint256[] memory values,
328:             bytes[] memory calldatas,
329:             string memory description
330:         ) = _getVetoCalls(timelockId);
331: 
332:         uint256 proposalId = super.propose(
333:             targets,
334:             values,
335:             calldatas,
336:             description
337:         );
338: 
339:         
340:         _timelockIds[proposalId] = timelockId;
341: 
342:         return proposalId;
343:     }
```

*GitHub* :

```452:     function _setCanExceedMaxGauges(
453:         address account,
454:         bool canExceedMax
455:     ) internal {
456:         if (canExceedMax) {
457:             require(
458:                 account.code.length != 0,
459:                 "ERC20Gauges: not a smart contract"
460:             );
461:         }
462: 
463:         canExceedMaxGauges[account] = canExceedMax;
464: 
465:         emit CanExceedMaxGaugesUpdate(account, canExceedMax);
466:     }
```

*GitHub* :

```91:     function getPastVotes(
92:         address account,
93:         uint256 blockNumber
94:     ) public view virtual returns (uint256) {
95:         require(
96:             blockNumber < block.number,
97:             "ERC20MultiVotes: not a past block"
98:         );
99:         return _checkpointsLookup(_checkpoints[account], blockNumber);
100:     }
```

*GitHub* :

```155:     function _setContractExceedMaxDelegates(
156:         address account,
157:         bool canExceedMax
158:     ) internal {
159:         require(
160:             !canExceedMax || account.code.length != 0,
161:             "ERC20MultiVotes: not a smart contract"
162:         ); 
163: 
164:         canContractExceedMaxDelegates[account] = canExceedMax;
165: 
166:         emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax);
167:     }
```

*GitHub* :

```290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual {
294:         uint256 count = delegateCount(delegator);
295: 
296:         
297:         require(count < 2, "ERC20MultiVotes: delegation error"); // <= FOUND
298: 
299:         address oldDelegatee;
300:         
301:         if (count == 1) {
302:             oldDelegatee = _delegates[delegator].at(0);
303:             _undelegate(
304:                 delegator,
305:                 oldDelegatee,
306:                 _delegatesVotesCount[delegator][oldDelegatee]
307:             );
308:         }
309: 
310:         
311:         if (newDelegatee != address(0)) {
312:             _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));
313:         }
314:         emit DelegateChanged(delegator, oldDelegatee, newDelegatee);
315:     }
```

*GitHub* : [297](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L297-L297)

```317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual {
322:         
323:         uint256 free = freeVotes(delegator);
324:         require(
325:             delegatee != address(0) && free >= amount,
326:             "ERC20MultiVotes: delegation error"
327:         );
328: 
329:         bool newDelegate = _delegates[delegator].add(delegatee); 
330:         require(
331:             !newDelegate ||
332:                 delegateCount(delegator) <= maxDelegates ||
333:                 canContractExceedMaxDelegates[delegator],
334:             "ERC20MultiVotes: delegation error"
335:         );
336: 
337:         _delegatesVotesCount[delegator][delegatee] += amount;
338:         userDelegatedVotes[delegator] += amount;
339: 
340:         emit Delegation(delegator, delegatee, amount);
341:         _writeCheckpoint(delegatee, _add, amount);
342:     }
```

*GitHub* :

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* :

```281:     function enterRebase() external {
282:         require(
283:             rebasingState[msg.sender].isRebasing == 0,
284:             "ERC20RebaseDistributor: already rebasing"
285:         );
286:         _enterRebase(msg.sender);
287:     }
```

*GitHub* :

```303:     function exitRebase() external {
304:         require(
305:             rebasingState[msg.sender].isRebasing == 1,
306:             "ERC20RebaseDistributor: not rebasing"
307:         );
308:         _exitRebase(msg.sender);
309:     }
```

*GitHub* :

```338:     function distribute(uint256 amount) external {
339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero"); // <= FOUND
340: 
341:         
342:         _burn(msg.sender, amount);
343: 
344:         
345:         uint256 _rebasingSharePrice = rebasingSharePrice();
346:         uint256 _totalRebasingShares = totalRebasingShares;
347:         uint256 _rebasingSupply = _shares2balance(
348:             _totalRebasingShares,
349:             _rebasingSharePrice,
350:             0,
351:             0
352:         );
353:         emit RebaseDistribution(
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
359: 
360:         
361:         
362:         if (_rebasingSupply != 0) {
363:             
364:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;
365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares;
369:             __rebasingSharePrice = InterpolatedValue({
370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
375: 
376:             
377:             uint256 _unmintedRebaseRewards = unmintedRebaseRewards();
378:             __unmintedRebaseRewards = InterpolatedValue({
379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
385:         }
386:     }
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L339-L339)

```75:     function startAuction(bytes32 loanId, uint256 callDebt) external {
76:         
77:         require(
78:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
79:             "AuctionHouse: invalid caller"
80:         );
81: 
82:         
83:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId);
84:         require(
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         );
88: 
89:         
90:         require(
91:             auctions[loanId].startTime == 0,
92:             "AuctionHouse: auction exists"
93:         );
94: 
95:         
96:         auctions[loanId] = Auction({
97:             startTime: block.timestamp,
98:             endTime: 0,
99:             lendingTerm: msg.sender,
100:             collateralAmount: loan.collateralAmount,
101:             callDebt: callDebt
102:         });
103:         nAuctionsInProgress++;
104: 
105:         
106:         emit AuctionStart(
107:             block.timestamp,
108:             loanId,
109:             LendingTerm(msg.sender).collateralToken(),
110:             loan.collateralAmount,
111:             callDebt
112:         );
113:     }
```

*GitHub* :

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached"); // <= FOUND
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [392](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L392-L392)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* :

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* :

```634:     function _call(
635:         address caller,
636:         bytes32 loanId,
637:         address _auctionHouse
638:     ) internal {
639:         Loan storage loan = loans[loanId];
640: 
641:         
642:         uint256 borrowTime = loan.borrowTime;
643:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
644: 
645:         
646:         require(loan.closeTime == 0, "LendingTerm: loan closed");
647: 
648:         
649:         require(loan.callTime == 0, "LendingTerm: loan called");
650: 
651:         
652:         require(
653:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||
654:                 partialRepayDelayPassed(loanId),
655:             "LendingTerm: cannot call"
656:         );
657: 
658:         
659:         require(
660:             borrowTime < block.timestamp,
661:             "LendingTerm: loan opened in same block"
662:         );
663: 
664:         
665:         uint256 loanDebt = getLoanDebt(loanId);
666:         loans[loanId].callTime = block.timestamp;
667:         loans[loanId].callDebt = loanDebt;
668:         loans[loanId].caller = caller;
669: 
670:         
671:         AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt);
672: 
673:         
674:         emit LoanCall(block.timestamp, loanId);
675:     }
```

*GitHub* :

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* :

```829:     function setAuctionHouse(
830:         address _newValue
831:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
832:         
833:         
834:         
835:         
836:         require(
837:             AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,
838:             "LendingTerm: auctions in progress"
839:         );
840: 
841:         refs.auctionHouse = _newValue;
842:     }
```

*GitHub* :

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* :

```158:     function unstake(address term, uint256 amount) external {
159:         
160:         (, UserStake memory userStake, bool slashed) = getRewards(
161:             msg.sender,
162:             term
163:         );
164: 
165:         
166:         if (slashed) return;
167: 
168:         
169:         require(
170:             amount != 0 && userStake.credit >= amount,
171:             "SurplusGuildMinter: invalid amount"
172:         );
173: 
174:         
175:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /
176:             userStake.credit; 
177:         uint256 guildAmount = (userMintRatio * amount) / 1e18;
178: 
179:         if (amount == userStake.credit) guildAmount = userStake.guild;
180: 
181:         userStake.credit -= SafeCastLib.safeCastTo128(amount);
182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);
183: 
184:         if (userStake.credit == 0) {
185:             userStake.stakeTime = 0;
186:             userStake.lastGaugeLoss = 0;
187:             userStake.profitIndex = 0;
188:         } else {
189:             
190:             
191:             require(
192:                 userStake.credit >= MIN_STAKE,
193:                 "SurplusGuildMinter: remaining stake below min"
194:             );
195:         }
196:         _stakes[msg.sender][term] = userStake;
197: 
198:         
199:         ProfitManager(profitManager).withdrawFromTermSurplusBuffer(
200:             term,
201:             msg.sender,
202:             amount
203:         );
204: 
205:         
206:         GuildToken(guild).decrementGauge(term, guildAmount);
207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
208:         GuildToken(guild).burn(guildAmount);
209: 
210:         
211:         emit Unstake(block.timestamp, term, amount);
212:     }
```

*GitHub* :

```61:     function setRateLimitPerSecond(
62:         uint128 newRateLimitPerSecond
63:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
64:         require(
65:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
66:             "RateLimited: rateLimitPerSecond too high"
67:         );
68:         _updateBufferStored(bufferCap);
69: 
70:         _setRateLimitPerSecond(newRateLimitPerSecond);
71:     }
```

*GitHub* :

```93:     function _depleteBuffer(uint256 amount) internal {
94:         uint256 newBuffer = buffer();
95: 
96:         require(newBuffer != 0, "RateLimited: no rate limit buffer"); // <= FOUND
97:         require(amount <= newBuffer, "RateLimited: rate limit hit");
98: 
99:         uint32 blockTimestamp = block.timestamp.safeCastTo32();
100:         uint224 newBufferStored = (newBuffer - amount).safeCastTo224();
101: 
102:         
103:         lastBufferUsedTime = blockTimestamp;
104:         bufferStored = newBufferStored;
105: 
106:         emit BufferUsed(amount, bufferStored);
107:     }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L96-L96)
### [GAS-15]<a name="gas-15"></a> Public functions not used internally can be marked as external to save gas
Public functions that aren't used internally in Solidity contracts should be made external to optimize gas usage and improve contract efficiency. External functions can only be called from outside the contract, and their arguments are directly read from the calldata, which is more gas-efficient than loading them into memory, as is the case for public functions. By using external visibility, developers can reduce gas consumption for external calls and ensure that the contract operates more cost-effectively for users. Moreover, setting the appropriate visibility level for functions also enhances code readability and maintainability, promoting a more secure and well-structured contract design.

*There are 7 instance(s) of this issue:*

```110:     function guardianCancel(
111:         address[] memory targets,
112:         uint256[] memory values,
113:         bytes[] memory calldatas,
114:         bytes32 descriptionHash
115:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) 
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L110)

```222:     function votingDelay() public pure override returns (uint256) 
```

*GitHub* : [222](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L222-L222)

```230:     function votingPeriod() public pure override returns (uint256) 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L230-L230)

```230:     function delegates(
231:         address delegator
232:     ) public view returns (address[] memory) 
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L230-L230)

```242:     function containsDelegate(
243:         address delegator,
244:         address delegatee
245:     ) public view returns (bool) 
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L242-L242)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public 
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L471)

```683:     function callMany(bytes32[] memory loanIds) public 
```

*GitHub* : [683](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L683-L683)
### [GAS-16]<a name="gas-16"></a> bytes.concat() can be used in place of abi.encodePacked
Given concatenation is not going to be used for hashing bytes.concat is the preferred method to use as its more gas efficient

*There are 1 instance(s) of this issue:*

```367:     function _getVetoCalls(
368:         bytes32 timelockId
369:     )
370:         internal
371:         view
372:         returns (
373:             address[] memory targets,
374:             uint256[] memory values,
375:             bytes[] memory calldatas,
376:             string memory description
377:         )
378:     {
379:         targets = new address[](1);
380:         targets[0] = timelock;
381:         values = new uint256[](1); 
382:         calldatas = new bytes[](1);
383:         calldatas[0] = abi.encodeWithSelector(
384:             TimelockController.cancel.selector,
385:             timelockId
386:         );
387:         description = string.concat(
388:             "Veto proposal for ",
389:             string(abi.encodePacked(timelockId)) // <= FOUND
390:         );
391:     }
```

*GitHub* : [389](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L389-L389)
### [GAS-17]<a name="gas-17"></a> Usage of smaller uint/int types causes overhead
When using a smaller int/uint type it first needs to be converted to it's 258 bit counterpart to be operated, this increases the gass cost and thus should be avoided. However it does make sense to use smaller int/uint values within structs provided you pack the struct properly.

*There are 14 instance(s) of this issue:*

```195:     function _countVote(
196:         uint256 proposalId,
197:         address account,
198:         uint8 support, // <= FOUND
199:         uint256 weight,
200:         bytes memory 
201:     ) internal virtual override {
202:         ProposalVote storage proposalvote = _proposalVotes[proposalId];
203: 
204:         require(
205:             !proposalvote.hasVoted[account],
206:             "GuildVetoGovernor: vote already cast"
207:         );
208:         proposalvote.hasVoted[account] = true;
209: 
210:         if (support == uint8(VoteType.Against)) {
211:             proposalvote.againstVotes += weight;
212:         } else {
213:             revert("GuildVetoGovernor: can only vote against in veto proposals");
214:         }
215:     }
```

*GitHub* : [198](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L198-L198)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v, // <= FOUND
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0));
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [475](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L475-L475)

```52:     function checkpoints(
53:         address account,
54:         uint32 pos // <= FOUND
55:     ) public view virtual returns (Checkpoint memory) {
56:         return _checkpoints[account][pos];
57:     }
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L54-L54)

```93:     function _depleteBuffer(uint256 amount) internal {
94:         uint256 newBuffer = buffer();
95: 
96:         require(newBuffer != 0, "RateLimited: no rate limit buffer");
97:         require(amount <= newBuffer, "RateLimited: rate limit hit");
98: 
99:         uint32 blockTimestamp = block.timestamp.safeCastTo32(); // <= FOUND
100:         uint224 newBufferStored = (newBuffer - amount).safeCastTo224(); // <= FOUND
101: 
102:         
103:         lastBufferUsedTime = blockTimestamp;
104:         bufferStored = newBufferStored;
105: 
106:         emit BufferUsed(amount, bufferStored);
107:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L99-L100)

```111:     function _replenishBuffer(uint256 amount) internal {
112:         uint256 newBuffer = buffer();
113: 
114:         uint256 _bufferCap = bufferCap; 
115: 
116:         
117:         if (newBuffer == _bufferCap) {
118:             
119:             
120:             
121:             return;
122:         }
123: 
124:         uint32 blockTimestamp = block.timestamp.safeCastTo32(); // <= FOUND
125:         
126:         uint224 newBufferStored = Math // <= FOUND
127:             .min(newBuffer + amount, _bufferCap)
128:             .safeCastTo224();
129: 
130:         
131:         lastBufferUsedTime = blockTimestamp;
132:         bufferStored = newBufferStored;
133: 
134:         emit BufferReplenished(amount, bufferStored);
135:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L124-L126)

```158:     function _updateBufferStored(uint128 newBufferCap) internal { // <= FOUND
159:         uint224 newBufferStored = buffer().safeCastTo224(); // <= FOUND
160:         uint32 newBlockTimestamp = block.timestamp.safeCastTo32(); // <= FOUND
161: 
162:         if (newBufferStored > newBufferCap) {
163:             bufferStored = uint224(newBufferCap); 
164:             lastBufferUsedTime = newBlockTimestamp;
165:         } else {
166:             bufferStored = newBufferStored;
167:             lastBufferUsedTime = newBlockTimestamp;
168:         }
169:     }
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L160)

```31: uint32 public lastBufferUsedTime; // <= FOUND
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L31-L31)

```61:     function setRateLimitPerSecond(
62:         uint128 newRateLimitPerSecond // <= FOUND
63:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
64:         require(
65:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
66:             "RateLimited: rateLimitPerSecond too high"
67:         );
68:         _updateBufferStored(bufferCap);
69: 
70:         _setRateLimitPerSecond(newRateLimitPerSecond);
71:     }
```

*GitHub* : [62](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L62-L62)

```75:     function setBufferCap(
76:         uint128 newBufferCap // <= FOUND
77:     ) external virtual onlyCoreRole(CoreRoles.GOVERNOR) {
78:         _setBufferCap(newBufferCap);
79:     }
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L76-L76)

```138:     function _setRateLimitPerSecond(uint128 newRateLimitPerSecond) internal { // <= FOUND
139:         uint256 oldRateLimitPerSecond = rateLimitPerSecond;
140:         rateLimitPerSecond = newRateLimitPerSecond;
141: 
142:         emit RateLimitPerSecondUpdate(
143:             oldRateLimitPerSecond,
144:             newRateLimitPerSecond
145:         );
146:     }
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L138-L138)

```149:     function _setBufferCap(uint128 newBufferCap) internal { // <= FOUND
150:         _updateBufferStored(newBufferCap);
151: 
152:         uint256 oldBufferCap = bufferCap;
153:         bufferCap = newBufferCap;
154: 
155:         emit BufferCapUpdate(oldBufferCap, newBufferCap);
156:     }
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L149-L149)

```23: uint128 public rateLimitPerSecond; // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L23-L23)

```26: uint128 public bufferCap; // <= FOUND
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L26-L26)

```34: uint224 public bufferStored; // <= FOUND
```

*GitHub* : [34](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L34-L34)
### [GAS-18]<a name="gas-18"></a> Use != 0 instead of > 0
Replace spotted instances with != 0 for uints as this uses less gas

*There are 3 instance(s) of this issue:*

```342:         
343:         else if (amount > 0) { // <= FOUND
```

*GitHub* : [343](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L343-L343)

```374: 
375:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) { // <= FOUND
```

*GitHub* : [375](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L375-L375)

```175:         if (sharesDelta > 0) { // <= FOUND
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L175-L175)
### [GAS-19]<a name="gas-19"></a> Integer increments by one can be unchecked to save on gas fees
Using unchecked increments in Solidity can save on gas fees by bypassing built-in overflow checks, thus optimizing gas usage, but requires careful assessment of potential risks and edge cases to avoid unintended consequences.

*There are 5 instance(s) of this issue:*

```87:     function emergencyAction(
88:         Call[] calldata calls
89:     )
90:         external
91:         payable
92:         onlyCoreRole(CoreRoles.GOVERNOR)
93:         returns (bytes[] memory returnData)
94:     {
95:         returnData = new bytes[](calls.length);
96:         for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
107:     }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```153:     function offboard(address term) external whenNotPaused {
154:         require(canOffboard[term], "LendingTermOffboarding: quorum not met");
155: 
156:         
157:         
158:         
159:         GuildToken(guildToken).removeGauge(term);
160: 
161:         
162:         if (
163:             nOffboardingsInProgress++ == 0 && // <= FOUND
164:             !SimplePSM(psm).redemptionsPaused()
165:         ) {
166:             SimplePSM(psm).setRedemptionsPaused(true);
167:         }
168: 
169:         emit Offboard(block.timestamp, term);
170:     }
```

*GitHub* : [163](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L163-L163)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal {
428:         uint256 userFreeVotes = freeVotes(user);
429: 
430:         
431:         if (userFreeVotes >= votes) return;
432: 
433:         
434:         uint256 totalFreed;
435: 
436:         
437:         address[] memory delegateList = _delegates[user].values();
438: 
439:         
440:         uint256 size = delegateList.length;
441:         for (
442:             uint256 i = 0;
443:             i < size && (userFreeVotes + totalFreed) < votes;
444:             i++ // <= FOUND
445:         ) {
446:             address delegatee = delegateList[i];
447:             uint256 delegateVotes = _delegatesVotesCount[user][delegatee];
448:             if (delegateVotes != 0) {
449:                 totalFreed += delegateVotes;
450: 
451:                 require(_delegates[user].remove(delegatee)); 
452: 
453:                 _delegatesVotesCount[user][delegatee] = 0;
454: 
455:                 _writeCheckpoint(delegatee, _subtract, delegateVotes);
456:                 emit Undelegation(user, delegatee, delegateVotes);
457:             }
458:         }
459: 
460:         userDelegatedVotes[user] -= totalFreed;
461:     }
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L444-L444)

```75:     function startAuction(bytes32 loanId, uint256 callDebt) external {
76:         
77:         require(
78:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
79:             "AuctionHouse: invalid caller"
80:         );
81: 
82:         
83:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId);
84:         require(
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         );
88: 
89:         
90:         require(
91:             auctions[loanId].startTime == 0,
92:             "AuctionHouse: auction exists"
93:         );
94: 
95:         
96:         auctions[loanId] = Auction({
97:             startTime: block.timestamp,
98:             endTime: 0,
99:             lendingTerm: msg.sender,
100:             collateralAmount: loan.collateralAmount,
101:             callDebt: callDebt
102:         });
103:         nAuctionsInProgress++; // <= FOUND
104: 
105:         
106:         emit AuctionStart(
107:             block.timestamp,
108:             loanId,
109:             LendingTerm(msg.sender).collateralToken(),
110:             loan.collateralAmount,
111:             callDebt
112:         );
113:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L103-L103)

```683:     function callMany(bytes32[] memory loanIds) public {
684:         address _auctionHouse = refs.auctionHouse;
685:         for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
688:     }
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [GAS-20]<a name="gas-20"></a> Use byte32 in place of string
For strings of 32 char strings and below you can use bytes32 instead as it's more gas efficient

*There are 2 instance(s) of this issue:*

```230:         description = string.concat( // <= FOUND
231:             "[", // <= FOUND
232:             Strings.toString(block.number),
233:             "]", // <= FOUND
234:             " Enable term ", // <= FOUND
235:             Strings.toHexString(term)
236:         );
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L230-L234)

```387:         description = string.concat( // <= FOUND
388:             "Veto proposal for ", // <= FOUND
389:             string(abi.encodePacked(timelockId)) // <= FOUND
390:         );
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L387-L389)
### [GAS-21]<a name="gas-21"></a> Default bool values are manually reset
Using .delete is better than resetting a Solidity variable to its default value manually because it frees up storage space on the Ethereum blockchain, resulting in gas cost savings.

*There are 1 instance(s) of this issue:*

```175:     function cleanup(address term) external whenNotPaused { // <= FOUND
176:         require(canOffboard[term], "LendingTermOffboarding: quorum not met");
177:         require(
178:             LendingTerm(term).issuance() == 0,
179:             "LendingTermOffboarding: not all loans closed"
180:         );
181:         require(
182:             GuildToken(guildToken).isDeprecatedGauge(term),
183:             "LendingTermOffboarding: re-onboarded"
184:         );
185: 
186:         
187:         core().revokeRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER, term);
188:         core().revokeRole(CoreRoles.GAUGE_PNL_NOTIFIER, term);
189: 
190:         
191:         if (
192:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused()
193:         ) {
194:             SimplePSM(psm).setRedemptionsPaused(false);
195:         }
196: 
197:         canOffboard[term] = false;
198:         emit Cleanup(block.timestamp, term);
199:     }
```

*GitHub* : [175](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L175-L175)
### [GAS-22]<a name="gas-22"></a> Default int values are manually reset
Using .delete is better than resetting a Solidity variable to its default value manually because it frees up storage space on the Ethereum blockchain, resulting in gas cost savings.

*There are 10 instance(s) of this issue:*

```310:                 termSurplusBuffer[gauge] = 0; // <= FOUND
```

*GitHub* : [310](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L310-L310)

```326:                 surplusBuffer = 0; // <= FOUND
```

*GitHub* : [326](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L326-L326)

```164:         
165:         forVotes = 0; // <= FOUND
```

*GitHub* : [164](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L164-L165)

```166:         
167:         abstainVotes = 0; // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L166-L167)

```453: 
454:                 _delegatesVotesCount[user][delegatee] = 0; // <= FOUND
```

*GitHub* : [453](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L453-L454)

```718: 
719:         
720:         params.hardCap = 0; // <= FOUND
```

*GitHub* : [718](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L718-L720)

```185:             userStake.stakeTime = 0; // <= FOUND
```

*GitHub* : [185](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L185-L185)

```186:             userStake.lastGaugeLoss = 0; // <= FOUND
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L186-L186)

```187:             userStake.profitIndex = 0; // <= FOUND
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L187-L187)

```254:                 guildReward = 0; // <= FOUND
```

*GitHub* : [254](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L254-L254)
### [GAS-23]<a name="gas-23"></a> <= or >= is more efficient than < or > 
Make such found comparisons to the <=/>= equivalent when comparing against integer literals

*There are 5 instance(s) of this issue:*

```127: 
128:         require(
129:             params.interestRate < 1e18,  // <= FOUND
130:             "LendingTermOnboarding: invalid interestRate"
131:         );
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L129-L129)

```138: 
139:         require(
140:             params.minPartialRepayPercent < 1e18,  // <= FOUND
141:             "LendingTermOnboarding: invalid minPartialRepayPercent"
142:         );
```

*GitHub* : [140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L140-L140)

```297: 
298:         
299:         require(count < 2, "ERC20MultiVotes: delegation error"); // <= FOUND
```

*GitHub* : [299](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L299-L299)

```132: 
133:         require(
134:             
135:             params.maxDelayBetweenPartialRepay < 31557601,  // <= FOUND
136:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
137:         );
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L135-L135)

```319:         require(
320:             timelockExecutionTime > 1, // <= FOUND
321:             "GuildVetoGovernor: action must be pending"
322:         );
```

*GitHub* : [320](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L320-L320)
### [GAS-24]<a name="gas-24"></a> Mappings used within a function more than once should be cached to save gas
Cache such mappings and perform operations on them, if operations include modifications to the mapping(s) then remember to equate the mapping to it's cached counterpart at the end

*There are 1 instance(s) of this issue:*

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS, // <= FOUND
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number; // <= FOUND
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L105)
### [GAS-25]<a name="gas-25"></a> Use assembly to check for the zero address

Using assembly for address comparisons in Solidity can save gas because it allows for more direct access to the Ethereum Virtual Machine (EVM), reducing the overhead of higher-level operations. Solidity's high-level abstraction simplifies coding but can introduce additional gas costs. Using assembly for simple operations like address comparisons can be more gas-efficient.

*There are 8 instance(s) of this issue:*

```156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
161:         assert(
162:             credit == address(0) && guild == address(0) && psm == address(0) // <= FOUND
163:         );
164:         credit = _credit;
165:         guild = _guild;
166:         psm = _psm;
167:     }
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L162)

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
202:         if (otherRecipient == address(0)) { // <= FOUND
203:             require(otherSplit == 0, "GuildToken: invalid config");
204:         } else {
205:             require(otherSplit != 0, "GuildToken: invalid config");
206:         }
207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         );
211: 
212:         profitSharingConfig = ProfitSharingConfig({
213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9),
214:             guildSplit: uint32(guildSplit / 1e9),
215:             otherSplit: uint32(otherSplit / 1e9),
216:             otherRecipient: otherRecipient
217:         });
218: 
219:         emit ProfitSharingConfigUpdate(
220:             block.timestamp,
221:             surplusBufferSplit,
222:             creditSplit,
223:             guildSplit,
224:             otherSplit,
225:             otherRecipient
226:         );
227:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L202)

```395:     function _addGauge(
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) {
399:         bool newAdd = _gauges.add(gauge);
400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge);
401:         
402:         require(
403:             gauge != address(0) && (newAdd || previouslyDeprecated), // <= FOUND
404:             "ERC20Gauges: invalid gauge"
405:         );
406: 
407:         if (newAdd) {
408:             
409:             gaugeType[gauge] = _type;
410:         } else {
411:             
412:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type");
413:         }
414: 
415:         
416:         weight = getGaugeWeight[gauge];
417:         if (weight != 0) {
418:             totalTypeWeight[_type] += weight;
419:             totalWeight += weight;
420:         }
421: 
422:         emit AddGauge(gauge, _type);
423:     }
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L403)

```290:     function _delegate(
291:         address delegator,
292:         address newDelegatee
293:     ) internal virtual {
294:         uint256 count = delegateCount(delegator);
295: 
296:         
297:         require(count < 2, "ERC20MultiVotes: delegation error");
298: 
299:         address oldDelegatee;
300:         
301:         if (count == 1) {
302:             oldDelegatee = _delegates[delegator].at(0);
303:             _undelegate(
304:                 delegator,
305:                 oldDelegatee,
306:                 _delegatesVotesCount[delegator][oldDelegatee]
307:             );
308:         }
309: 
310:         
311:         if (newDelegatee != address(0)) { // <= FOUND
312:             _incrementDelegation(delegator, newDelegatee, freeVotes(delegator));
313:         }
314:         emit DelegateChanged(delegator, oldDelegatee, newDelegatee);
315:     }
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L311)

```317:     function _incrementDelegation(
318:         address delegator,
319:         address delegatee,
320:         uint256 amount
321:     ) internal virtual {
322:         
323:         uint256 free = freeVotes(delegator);
324:         require(
325:             delegatee != address(0) && free >= amount, // <= FOUND
326:             "ERC20MultiVotes: delegation error"
327:         );
328: 
329:         bool newDelegate = _delegates[delegator].add(delegatee); 
330:         require(
331:             !newDelegate ||
332:                 delegateCount(delegator) <= maxDelegates ||
333:                 canContractExceedMaxDelegates[delegator],
334:             "ERC20MultiVotes: delegation error"
335:         );
336: 
337:         _delegatesVotesCount[delegator][delegatee] += amount;
338:         userDelegatedVotes[delegator] += amount;
339: 
340:         emit Delegation(delegator, delegatee, amount);
341:         _writeCheckpoint(delegatee, _add, amount);
342:     }
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L325)

```471:     function delegateBySig(
472:         address delegatee,
473:         uint256 nonce,
474:         uint256 expiry,
475:         uint8 v,
476:         bytes32 r,
477:         bytes32 s
478:     ) public {
479:         require(
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         );
483:         address signer = ecrecover(
484:             keccak256(
485:                 abi.encodePacked(
486:                     "\x19\x01",
487:                     _domainSeparatorV4(),
488:                     keccak256(
489:                         abi.encode(
490:                             DELEGATION_TYPEHASH,
491:                             delegatee,
492:                             nonce,
493:                             expiry
494:                         )
495:                     )
496:                 )
497:             ),
498:             v,
499:             r,
500:             s
501:         );
502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce");
503:         require(signer != address(0)); // <= FOUND
504:         _delegate(signer, delegatee);
505:     }
```

*GitHub* : [471](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L471-L503)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override {
187:         require(
188:             transferable || from == address(0) || to == address(0), // <= FOUND
189:             "GuildToken: transfers disabled"
190:         );
191:     }
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L188)

```160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0)); // <= FOUND
167:         assert(_core != address(0)); // <= FOUND
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L167)
### [GAS-26]<a name="gas-26"></a> Divisions which do not divide by -X cannot overflow or overflow so such operations can be unchecked to save gas
Make such found divisions are unchecked when ensured it is safe to do so

*There are 13 instance(s) of this issue:*

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
202:         if (otherRecipient == address(0)) {
203:             require(otherSplit == 0, "GuildToken: invalid config");
204:         } else {
205:             require(otherSplit != 0, "GuildToken: invalid config");
206:         }
207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         );
211: 
212:         profitSharingConfig = ProfitSharingConfig({
213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9), // <= FOUND
214:             guildSplit: uint32(guildSplit / 1e9), // <= FOUND
215:             otherSplit: uint32(otherSplit / 1e9), // <= FOUND
216:             otherRecipient: otherRecipient
217:         });
218: 
219:         emit ProfitSharingConfigUpdate(
220:             block.timestamp,
221:             surplusBufferSplit,
222:             creditSplit,
223:             guildSplit,
224:             otherSplit,
225:             otherRecipient
226:         );
227:     }
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L213-L215)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9; // <= FOUND
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9; // <= FOUND
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9; // <= FOUND
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
```

*GitHub* : [347](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L347-L353)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned);
435:         }
436:     }
```

*GitHub* : [429](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L429-L429)

```200:     function getLoanDebt(bytes32 loanId) public view returns (uint256) {
201:         Loan storage loan = loans[loanId];
202:         uint256 borrowTime = loan.borrowTime;
203: 
204:         if (borrowTime == 0) {
205:             return 0;
206:         }
207: 
208:         if (loan.closeTime != 0) {
209:             return 0;
210:         }
211: 
212:         if (loan.callTime != 0) {
213:             return loan.callDebt;
214:         }
215: 
216:         
217:         uint256 borrowAmount = loan.borrowAmount;
218:         uint256 interest = (borrowAmount *
219:             params.interestRate *
220:             (block.timestamp - borrowTime)) /
221:             YEAR /
222:             1e18;
223:         uint256 loanDebt = borrowAmount + interest;
224:         uint256 _openingFee = params.openingFee;
225:         if (_openingFee != 0) {
226:             loanDebt += (borrowAmount * _openingFee) / 1e18; // <= FOUND
227:         }
228:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
229:             .creditMultiplier();
230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier;
231: 
232:         return loanDebt;
233:     }
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L226-L226)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18; // <= FOUND
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L387-L387)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18; // <= FOUND
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18; // <= FOUND
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18, // <= FOUND
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [516](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L516-L524)

```87:     function getRedeemAmountOut(
88:         uint256 amountIn
89:     ) public view returns (uint256) {
90:         uint256 creditMultiplier = ProfitManager(profitManager)
91:             .creditMultiplier();
92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
93:     }
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18; // <= FOUND
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L134-L134)

```158:     function unstake(address term, uint256 amount) external {
159:         
160:         (, UserStake memory userStake, bool slashed) = getRewards(
161:             msg.sender,
162:             term
163:         );
164: 
165:         
166:         if (slashed) return;
167: 
168:         
169:         require(
170:             amount != 0 && userStake.credit >= amount,
171:             "SurplusGuildMinter: invalid amount"
172:         );
173: 
174:         
175:         uint256 userMintRatio = (uint256(userStake.guild) * 1e18) /
176:             userStake.credit; 
177:         uint256 guildAmount = (userMintRatio * amount) / 1e18; // <= FOUND
178: 
179:         if (amount == userStake.credit) guildAmount = userStake.guild;
180: 
181:         userStake.credit -= SafeCastLib.safeCastTo128(amount);
182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount);
183: 
184:         if (userStake.credit == 0) {
185:             userStake.stakeTime = 0;
186:             userStake.lastGaugeLoss = 0;
187:             userStake.profitIndex = 0;
188:         } else {
189:             
190:             
191:             require(
192:                 userStake.credit >= MIN_STAKE,
193:                 "SurplusGuildMinter: remaining stake below min"
194:             );
195:         }
196:         _stakes[msg.sender][term] = userStake;
197: 
198:         
199:         ProfitManager(profitManager).withdrawFromTermSurplusBuffer(
200:             term,
201:             msg.sender,
202:             amount
203:         );
204: 
205:         
206:         GuildToken(guild).decrementGauge(term, guildAmount);
207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
208:         GuildToken(guild).burn(guildAmount);
209: 
210:         
211:         emit Unstake(block.timestamp, term, amount);
212:     }
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L177-L177)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18; // <= FOUND
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward);
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L252-L252)

```293:     function updateMintRatio(address user, address term) external {
294:         
295:         (, UserStake memory userStake, bool slashed) = getRewards(user, term);
296: 
297:         
298:         if (userStake.stakeTime == 0 || slashed) return;
299: 
300:         
301:         uint256 guildBefore = uint256(userStake.guild);
302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18; // <= FOUND
303:         if (guildAfter > guildBefore) {
304:             uint256 guildAmount = guildAfter - guildBefore;
305:             RateLimitedMinter(rlgm).mint(address(this), guildAmount);
306:             GuildToken(guild).incrementGauge(term, guildAmount);
307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
308:         } else if (guildAfter < guildBefore) {
309:             uint256 guildAmount = guildBefore - guildAfter;
310:             GuildToken(guild).decrementGauge(term, guildAmount);
311:             RateLimitedMinter(rlgm).replenishBuffer(guildAmount);
312:             GuildToken(guild).burn(guildAmount);
313:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter);
314:         }
315:     }
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L302-L302)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) {
123:         
124:         return (a & b) + (a ^ b) / 2; // <= FOUND
125:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L124-L124)

```118:     function getBidDetail(
119:         bytes32 loanId
120:     ) public view returns (uint256 collateralReceived, uint256 creditAsked) {
121:         
122:         uint256 _startTime = auctions[loanId].startTime;
123:         require(_startTime != 0, "AuctionHouse: invalid auction");
124: 
125:         
126:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended");
127: 
128:         
129:         
130:         
131:         assert(block.timestamp >= _startTime);
132: 
133:         
134:         if (block.timestamp < _startTime + midPoint) {
135:             
136:             creditAsked = auctions[loanId].callDebt;
137: 
138:             
139:             uint256 elapsed = block.timestamp - _startTime; 
140:             uint256 _collateralAmount = auctions[loanId].collateralAmount; 
141:             collateralReceived = (_collateralAmount * elapsed) / midPoint;
142:         }
143:         
144:         else if (block.timestamp < _startTime + auctionDuration) {
145:             
146:             collateralReceived = auctions[loanId].collateralAmount;
147: 
148:             
149:             uint256 PHASE_2_DURATION = auctionDuration - midPoint;
150:             uint256 elapsed = block.timestamp - _startTime - midPoint; 
151:             uint256 _callDebt = auctions[loanId].callDebt; 
152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION; // <= FOUND
153:         }
154:         
155:         
156:         else {
157:             
158:             collateralReceived = auctions[loanId].collateralAmount;
159:             
160:         }
161:     }
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L152-L152)
### [GAS-27]<a name="gas-27"></a> Can transfer 0
In Solidity, performing unnecessary operations can consume more gas than needed, leading to cost inefficiencies. For instance, if a `transfer` function doesn't have a zero amount check and someone calls it with a zero amount, unnecessary gas will be consumed in executing the function, even though the state of the contract remains the same. By implementing a zero amount check, such unnecessary function calls can be avoided, thereby saving gas and making the contract more efficient.

*There are 6 instance(s) of this issue:*

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```481:     function transfer(
482:         address to,
483:         uint256 amount
484:     ) public virtual override returns (bool) {
485:         _decrementWeightUntilFree(msg.sender, amount);
486:         return super.transfer(to, amount); // <= FOUND
487:     }
```

*GitHub* : [481](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L481-L486)

```408:     function transfer(
409:         address to,
410:         uint256 amount
411:     ) public virtual override returns (bool) {
412:         _decrementVotesUntilFree(msg.sender, amount);
413:         return super.transfer(to, amount); // <= FOUND
414:     }
```

*GitHub* : [408](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L408-L413)

```113:     function transfer(
114:         address to,
115:         uint256 amount
116:     )
117:         public
118:         override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)
119:         returns (bool)
120:     {
121:         _decrementVotesUntilFree(msg.sender, amount); 
122:         return ERC20RebaseDistributor.transfer(to, amount); // <= FOUND
123:     }
```

*GitHub* : [113](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L113-L122)

```288:     function transfer(
289:         address to,
290:         uint256 amount
291:     )
292:         public
293:         virtual
294:         override(ERC20, ERC20Gauges, ERC20MultiVotes)
295:         returns (bool)
296:     {
297:         _decrementWeightUntilFree(msg.sender, amount);
298:         _decrementVotesUntilFree(msg.sender, amount);
299:         return ERC20.transfer(to, amount); // <= FOUND
300:     }
```

*GitHub* : [288](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L288-L299)
### [GAS-28]<a name="gas-28"></a> Divisions of powers of 2 can be replaced by a right shift operation to save gas
Replace such found divisions with right shift operations when ensured it is safe to do so. NOTE: This only applies to uint variables!

*There are 1 instance(s) of this issue:*

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256) {
123:         
124:         return (a & b) + (a ^ b) / 2; // <= FOUND
125:     }
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L124-L124)
### [GAS-29]<a name="gas-29"></a> Struct variables can be packed into fewer storage slots
In Solidity, each storage slot has a size of 32 bytes. If a struct contains multiple uint values, it's efficient to pack these into as few storage slots as possible to optimize gas usage. The EVM (Ethereum Virtual Machine) charges gas for each storage operation, so minimizing the number of slots used can result in substantial gas savings. This can be achieved by ordering struct fields according to their size or by using smaller data types where possible. However, developers must balance these optimizations with the need for code clarity and the precision requirements of their application. Always ensure that data packing does not compromise the functionality or security of the contract.

*There are 4 instance(s) of this issue:*

```117:     struct ProposalVote {
118:         uint256 againstVotes; // <= FOUND
119:         uint256 forVotes; // <= FOUND
120:         uint256 abstainVotes; // <= FOUND
121:         mapping(address => bool) hasVoted;
122:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L117-L120)

```40:     struct Auction {
41:         uint256 startTime; // <= FOUND
42:         uint256 endTime; // <= FOUND
43:         address lendingTerm;
44:         uint256 collateralAmount; // <= FOUND
45:         uint256 callDebt; // <= FOUND
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L45)

```75:     struct Loan {
76:         address borrower; 
77:         uint256 borrowTime;  // <= FOUND
78:         uint256 borrowAmount;  // <= FOUND
79:         uint256 borrowCreditMultiplier;  // <= FOUND
80:         uint256 collateralAmount;  // <= FOUND
81:         address caller; 
82:         uint256 callTime;  // <= FOUND
83:         uint256 callDebt;  // <= FOUND
84:         uint256 closeTime;  // <= FOUND
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L84)

```114:     struct LendingTermParams {
115:         
116:         address collateralToken;
117:         
118:         
119:         
120:         
121:         
122:         
123:         
124:         
125:         uint256 maxDebtPerCollateralToken; // <= FOUND
126:         
127:         
128:         uint256 interestRate; // <= FOUND
129:         
130:         
131:         
132:         
133:         uint256 maxDelayBetweenPartialRepay; // <= FOUND
134:         
135:         
136:         
137:         uint256 minPartialRepayPercent; // <= FOUND
138:         
139:         
140:         
141:         
142:         
143:         
144:         uint256 openingFee; // <= FOUND
145:         
146:         
147:         uint256 hardCap; // <= FOUND
148:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L114-L147)
### [GAS-30]<a name="gas-30"></a> Consider activating via-ir for deploying
The Solidity compiler's Intermediate Representation (IR) based code generator, which can be activated using --via-ir on the command line or {"viaIR": true} in the options, serves a dual purpose. Firstly, it boosts the transparency and audibility of code generation, which enhances developers' comprehension and control over the contract's final bytecode. Secondly, it enables more sophisticated optimization passes that span multiple functions, thereby potentially leading to more efficient bytecode.

It's important to note that using the IR-based code generator may lengthen compile times due to the extra optimization steps. Therefore, it's advised to test your contract with and without this option enabled to measure the performance and gas cost implications. If the IR-based code generator significantly enhances your contract's performance or reduces gas costs, consider using the --via-ir flag during deployment. This way, you can leverage more advanced compiler optimizations without hindering your development workflow.

*There are 1 instance(s) of this issue:*

```13: all
```

*GitHub* : [13](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L13-L13)
### [GAS-31]<a name="gas-31"></a> Superfluous event fields
The Ethereum network automatically appends certain data, including `block.number` and `block.timestamp`, to every event emitted by smart contracts. This inherent feature means that explicitly adding these parameters to your event logs isn't necessary, as they're already accessible through the transaction receipt. In fact, manually adding these details to your events can lead to wasted gas because it increases the data payload of the transaction, thereby upping the associated gas cost. For gas-efficient coding, it's best to rely on the default inclusions of `block.number` and `block.timestamp` rather than duplicating these in your events.

*There are 15 instance(s) of this issue:*

```18: event OffboardSupport(
19:         uint256 indexed timestamp, // <= FOUND
20:         address indexed term,
21:         uint256 indexed snapshotBlock, // <= FOUND
22:         address user,
23:         uint256 userWeight
24:     );
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L19-L21)

```83: event TimelockChange(address oldTimelock, address newTimelock); // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L83-L83)

```26: event Offboard(uint256 indexed timestamp, address indexed term); // <= FOUND
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L26-L26)

```28: event Cleanup(uint256 indexed timestamp, address indexed term); // <= FOUND
```

*GitHub* : [28](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L28-L28)

```172: event TransfersEnabled(uint256 block, uint256 timestamp); // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L172-L172)

```194: event ProfitManagerUpdated(uint256 timestamp, address newValue); // <= FOUND
```

*GitHub* : [194](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L194-L194)

```32: event Stake(
33:         uint256 indexed timestamp, // <= FOUND
34:         address indexed term,
35:         uint256 amount
36:     );
```

*GitHub* : [33](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L33-L33)

```38: event Unstake(
39:         uint256 indexed timestamp, // <= FOUND
40:         address indexed term,
41:         uint256 amount
42:     );
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L39-L39)

```45: event GuildReward(
46:         uint256 indexed timestamp, // <= FOUND
47:         address indexed user,
48:         uint256 amount
49:     );
```

*GitHub* : [46](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L46-L46)

```51: event MintRatioUpdate(uint256 indexed timestamp, uint256 ratio); // <= FOUND
```

*GitHub* : [51](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L51-L51)

```53: event RewardRatioUpdate(uint256 indexed timestamp, uint256 ratio); // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L53-L53)

```48: event RebaseEnter(address indexed account, uint256 indexed timestamp); // <= FOUND
```

*GitHub* : [48](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L48-L48)

```50: event RebaseExit(address indexed account, uint256 indexed timestamp); // <= FOUND
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L50-L50)

```52: event RebaseDistribution(
53:         address indexed source,
54:         uint256 indexed timestamp, // <= FOUND
55:         uint256 amountDistributed,
56:         uint256 amountRebasing
57:     );
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L54-L54)

```67: event RebaseReward(
68:         address indexed account,
69:         uint256 indexed timestamp, // <= FOUND
70:         uint256 amount
71:     );
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L69-L69)
### [GAS-32]<a name="gas-32"></a> Add unchecked {} for subtractions where the operands cannot underflow
n Solidity 0.8.x and above, arithmetic operations like subtraction automatically check for underflows and overflows, and revert the transaction if such a condition is met. This built-in safety feature provides a layer of security against potential numerical errors. However, these automatic checks also come with additional gas costs.

In some situations, you may already have a guard condition, like a require() statement or an if statement, that ensures the safety of the arithmetic operation. In such cases, the automatic check becomes redundant and leads to unnecessary gas expenditure.

For example, you may have a function that subtracts a smaller number from a larger one, and you may have already verified that the smaller number is indeed smaller. In this case, you're already sure that the subtraction operation won't underflow, so there's no need for the automatic check.

In these situations, you can use the unchecked { } block around the subtraction operation to skip the automatic check. This will reduce gas costs and make your contract more efficient, without sacrificing security. However, it's critical to use unchecked { } only when you're absolutely sure that the operation is safe.

*There are 33 instance(s) of this issue:*

```246:         creditSplit = 1e18 - surplusBufferSplit - guildSplit - otherSplit; // <= FOUND
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L246-L246)

```271:         uint256 newSurplusBuffer = surplusBuffer - amount;  // <= FOUND
```

*GitHub* : [271](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L271-L271)

```283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount;  // <= FOUND
```

*GitHub* : [283](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L283-L283)

```317:                 
318:                 surplusBuffer = _surplusBuffer - loss; // <= FOUND
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L317-L318)

```427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex; // <= FOUND
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L427-L427)

```478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex; // <= FOUND
```

*GitHub* : [478](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L478-L478)

```321: 
322:         getUserGaugeWeight[user][gauge] = oldWeight - weight; // <= FOUND
```

*GitHub* : [321](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L321-L322)

```371:         uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes; // <= FOUND
```

*GitHub* : [371](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L371-L371)

```146:             
147:             uint256 elapsed = block.timestamp - lastTimestamp; // <= FOUND
```

*GitHub* : [146](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L146-L147)

```147:             uint256 delta = targetValue - lastValue; // <= FOUND
```

*GitHub* : [147](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L147-L147)

```181:                     sharesAfter = sharesBefore - shareDecrease; // <= FOUND
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L181-L181)

```322:         uint256 mintAmount = rebasedBalance - rawBalance; // <= FOUND
```

*GitHub* : [322](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L322-L322)

```476:             uint256 mintAmount = rebasedBalance - balanceBefore; // <= FOUND
```

*GitHub* : [476](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L476-L476)

```490:             uint256 balanceAfter = balanceBefore - amount; // <= FOUND
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L490-L490)

```495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter; // <= FOUND
```

*GitHub* : [495](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L495-L495)

```531:             uint256 sharesReceived = sharesAfter - _rebasingState.nShares; // <= FOUND
```

*GitHub* : [531](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L531-L531)

```542: 
543:             
544:             uint256 mintAmount = rebasedBalance - rawBalance; // <= FOUND
```

*GitHub* : [542](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L542-L544)

```574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore; // <= FOUND
```

*GitHub* : [574](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L574-L574)

```589:             uint256 fromBalanceAfter = fromBalanceBefore - amount; // <= FOUND
```

*GitHub* : [589](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L589-L589)

```594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter; // <= FOUND
```

*GitHub* : [594](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L594-L594)

```618:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares; // <= FOUND
```

*GitHub* : [618](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L618-L618)

```626: 
627:             
628:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter; // <= FOUND
```

*GitHub* : [626](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L626-L628)

```139: 
140:             
141:             uint256 elapsed = block.timestamp - _startTime;  // <= FOUND
```

*GitHub* : [139](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L139-L141)

```149: 
150:             
151:             uint256 PHASE_2_DURATION = auctionDuration - midPoint; // <= FOUND
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L149-L151)

```150:             uint256 elapsed = block.timestamp - _startTime - midPoint;  // <= FOUND
```

*GitHub* : [150](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L150-L150)

```312:         uint256 remainingDebtCeiling = debtCeilingBefore - _issuance;  // <= FOUND
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L312-L312)

```319:         uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight;  // <= FOUND
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L319-L319)

```517:         uint256 interestRepaid = debtToRepay - principalRepaid; // <= FOUND
```

*GitHub* : [517](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L517-L517)

```587:         uint256 interest = loanDebt - principal; // <= FOUND
```

*GitHub* : [587](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L587-L587)

```759:             interest = creditFromBidder - principal; // <= FOUND
```

*GitHub* : [759](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L759-L759)

```247: 
248:         uint256 deltaIndex = _profitIndex - _userProfitIndex; // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L247-L248)

```304:             uint256 guildAmount = guildAfter - guildBefore; // <= FOUND
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L304-L304)

```309:             uint256 guildAmount = guildBefore - guildAfter; // <= FOUND
```

*GitHub* : [309](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L309-L309)
### [GAS-33]<a name="gas-33"></a> Private functions never used can be removed
Private functions which are never used use unnecessary gas and should be safely removed.

*There are 2 instance(s) of this issue:*

```387:     function _add(uint256 a, uint256 b) private pure returns (uint256)  // <= FOUND
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L387-L387)

```391:     function _subtract(uint256 a, uint256 b) private pure returns (uint256)  // <= FOUND
```

*GitHub* : [391](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L391-L391)
### [GAS-34]<a name="gas-34"></a> Private functions used once can be inlined
Private functions which are only called once can be inlined to save GAS.

*There are 1 instance(s) of this issue:*

```103:     function _checkpointsLookup( // <= FOUND
104:         Checkpoint[] storage ckpts,
105:         uint256 blockNumber
106:     ) private view returns (uint256) 
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L103-L103)
### [GAS-35]<a name="gas-35"></a> Use bitmap to save gas
Bitmaps in Solidity are essentially a way of representing a set of boolean values within an integer type variable such as `uint256`. Each bit in the integer represents a true or false value (1 or 0), thus allowing efficient storage of multiple boolean values.

Bitmaps can save gas in the Ethereum network because they condense a lot of information into a small amount of storage. In Ethereum, storage is one of the most significant costs in terms of gas usage. By reducing the amount of storage space needed, you can potentially save on gas fees.

Here's a quick comparison:

If you were to represent 256 different boolean values in the traditional way, you would have to declare 256 different `bool` variables. Given that each `bool` occupies a storage slot and each storage slot costs 20,000 gas to initialize, you would end up paying a considerable amount of gas.

On the other hand, if you were to use a bitmap, you could store these 256 boolean values within a single `uint256` variable. In other words, you'd only pay for a single storage slot, resulting in significant gas savings.

However, it's important to note that while bitmaps can provide gas efficiencies, they do add complexity to the code, making it harder to read and maintain. Also, using bitmaps is efficient only when dealing with a large number of boolean variables that are frequently changed or accessed together. 

In contrast, the straightforward counterpart to bitmaps would be using arrays or mappings to store boolean values, with each `bool` value occupying its own storage slot. This approach is simpler and more readable but could potentially be more expensive in terms of gas usage.

*There are 6 instance(s) of this issue:*

```139:             canOffboard[term] = true; // <= FOUND
```

*GitHub* : [139](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L139-L139)

```208:         proposalvote.hasVoted[account] = true; // <= FOUND
```

*GitHub* : [208](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L208-L208)

```176:         transferable = true; // <= FOUND
```

*GitHub* : [176](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L176-L176)

```230:             slashed = true; // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L230-L230)

```268:             updateState = true; // <= FOUND
```

*GitHub* : [268](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L268-L268)

```197: 
198:         canOffboard[term] = false; // <= FOUND
```

*GitHub* : [198](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L198-L198)
### [GAS-36]<a name="gas-36"></a> Use assembly hashing
From a gas standpoint, the assembly version of the keccak256 hashing function can be more efficient than the high-level Solidity version. This is because Solidity has additional overhead when handling function calls and memory management, which can increase the gas cost.

*There are 10 instance(s) of this issue:*

```12:     
15:     bytes32 internal constant GOVERNOR = keccak256("GOVERNOR_ROLE"); // <= FOUND
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L12-L15)

```15: 
17:     bytes32 internal constant GUARDIAN = keccak256("GUARDIAN_ROLE"); // <= FOUND
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L15-L17)

```20: 
24:     bytes32 internal constant CREDIT_MINTER = keccak256("CREDIT_MINTER_ROLE"); // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L20-L24)

```27: 
29:     bytes32 internal constant GUILD_MINTER = keccak256("GUILD_MINTER_ROLE"); // <= FOUND
```

*GitHub* : [27](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L27-L29)

```36: 
40:     bytes32 internal constant GAUGE_ADD = keccak256("GAUGE_ADD_ROLE"); // <= FOUND
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L36-L40)

```39: 
41:     bytes32 internal constant GAUGE_REMOVE = keccak256("GAUGE_REMOVE_ROLE"); // <= FOUND
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L39-L41)

```71: 
76:     bytes32 internal constant TIMELOCK_PROPOSER = keccak256("PROPOSER_ROLE"); // <= FOUND
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L71-L76)

```74: 
76:     bytes32 internal constant TIMELOCK_EXECUTOR = keccak256("EXECUTOR_ROLE"); // <= FOUND
```

*GitHub* : [74](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L74-L76)

```77: 
79:     bytes32 internal constant TIMELOCK_CANCELLER = keccak256("CANCELLER_ROLE"); // <= FOUND
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L77-L79)

```347: 
348:         loanId = keccak256( // <= FOUND
349:             abi.encode(borrower, address(this), block.timestamp)
350:         );
```

*GitHub* : [347](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L347-L348)
### [GAS-37]<a name="gas-37"></a> Consider using OZ EnumerateSet in place of nested mappings
Nested mappings and multi-dimensional arrays in Solidity operate through a process of double hashing, wherein the original storage slot and the first key are concatenated and hashed, and then this hash is again concatenated with the second key and hashed. This process can be quite gas expensive due to the double-hashing operation and subsequent storage operation (sstore).

A possible optimization involves manually concatenating the keys followed by a single hash operation and an sstore. However, this technique introduces the risk of storage collision, especially when there are other nested hash maps in the contract that use the same key types. Because Solidity is unaware of the number and structure of nested hash maps in a contract, it follows a conservative approach in computing the storage slot to avoid possible collisions.

OpenZeppelin's EnumerableSet provides a potential solution to this problem. It creates a data structure that combines the benefits of set operations with the ability to enumerate stored elements, which is not natively available in Solidity. EnumerableSet handles the element uniqueness internally and can therefore provide a more gas-efficient and collision-resistant alternative to nested mappings or multi-dimensional arrays in certain scenarios.

*There are 7 instance(s) of this issue:*

```49:     mapping(uint256 => mapping(address => uint256)) public polls; // <= FOUND
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L49-L49)

```53:     mapping(address => mapping(uint256 => mapping(address => uint256))) // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L53-L53)

```44:     mapping(address => mapping(address => uint256)) public userGaugeProfitIndex; // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L44-L44)

```120:     mapping(address => mapping(address => uint256)) public lastGaugeLossApplied; // <= FOUND
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L120-L120)

```86:     mapping(address => mapping(address => UserStake)) internal _stakes; // <= FOUND
```

*GitHub* : [86](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L86-L86)

```66:     mapping(address => mapping(address => uint256)) public getUserGaugeWeight; // <= FOUND
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L66-L66)

```203:     mapping(address => mapping(address => uint256)) // <= FOUND
```

*GitHub* : [203](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L203-L203)
### [GAS-38]<a name="gas-38"></a> Use assembly to emit events
With the use of inline assembly in Solidity, we can take advantage of low-level features like scratch space and the free memory pointer, offering more gas-efficient ways of emitting events. The scratch space is a certain area of memory where we can temporarily store data, and the free memory pointer indicates the next available memory slot. Using these, we can efficiently assemble event data without incurring additional memory expansion costs. However, safety is paramount: to avoid overwriting or leakage, we must cache the free memory pointer before use and restore it afterward, ensuring that it points to the correct memory location post-operation.

*There are 72 instance(s) of this issue:*

```53: 
54:         emit CoreUpdate(oldCore, newCore); // <= FOUND
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L54-L54)

```69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L69-L69)

```81:         emit QuorumUpdated(quorum, _quorum); // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L81-L81)

```106:         emit OffboardSupport( // <= FOUND
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L106-L106)

```141:         emit OffboardSupport( // <= FOUND
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L141-L141)

```169: 
170:         emit Offboard(block.timestamp, term); // <= FOUND
```

*GitHub* : [170](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L170-L170)

```198:         emit Cleanup(block.timestamp, term); // <= FOUND
```

*GitHub* : [198](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L198-L198)

```97:         emit ImplementationAllowChanged( // <= FOUND
98:             block.timestamp,
99:             implementation,
100:             allowed
101:         );
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L97-L97)

```166:         emit TermCreated(block.timestamp, implementation, term, params); // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L166-L166)

```107:         emit MinBorrowUpdate(block.timestamp, 100e18); // <= FOUND
```

*GitHub* : [107](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L107-L107)

```183:         emit MinBorrowUpdate(block.timestamp, newValue); // <= FOUND
```

*GitHub* : [183](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L183-L183)

```191:         emit GaugeWeightToleranceUpdate(block.timestamp, newValue); // <= FOUND
```

*GitHub* : [191](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L191-L191)

```219: 
220:         emit ProfitSharingConfigUpdate( // <= FOUND
221:             block.timestamp,
222:             surplusBufferSplit,
223:             creditSplit,
224:             guildSplit,
225:             otherSplit,
226:             otherRecipient
227:         );
```

*GitHub* : [220](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L220-L220)

```255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer); // <= FOUND
```

*GitHub* : [255](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L255-L255)

```263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer); // <= FOUND
```

*GitHub* : [263](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L263-L263)

```311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0); // <= FOUND
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L311-L311)

```318:                 emit SurplusBufferUpdate( // <= FOUND
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
```

*GitHub* : [318](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L318-L318)

```328:                 emit SurplusBufferUpdate(block.timestamp, 0); // <= FOUND
```

*GitHub* : [328](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L328-L328)

```335:                 emit CreditMultiplierUpdate( // <= FOUND
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
```

*GitHub* : [335](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L335-L335)

```363:                 emit SurplusBufferUpdate( // <= FOUND
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L363-L363)

```404: 
405:         emit GaugePnL(gauge, block.timestamp, amount); // <= FOUND
```

*GitHub* : [405](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L405-L405)

```433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned); // <= FOUND
```

*GitHub* : [433](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L433-L433)

```100:         emit TimelockChange(timelock, newTimelock); // <= FOUND
```

*GitHub* : [100](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L100-L100)

```246: 
247:         emit IncrementGaugeWeight(user, gauge, weight); // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L247-L247)

```331: 
332:         emit DecrementGaugeWeight(user, gauge, weight); // <= FOUND
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L332-L332)

```422: 
423:         emit AddGauge(gauge, _type); // <= FOUND
```

*GitHub* : [423](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L423-L423)

```439: 
440:         emit RemoveGauge(gauge); // <= FOUND
```

*GitHub* : [440](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L440-L440)

```448: 
449:         emit MaxGaugesUpdate(oldMax, newMax); // <= FOUND
```

*GitHub* : [449](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L449-L449)

```465: 
466:         emit CanExceedMaxGaugesUpdate(account, canExceedMax); // <= FOUND
```

*GitHub* : [466](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L466-L466)

```151: 
152:         emit MaxDelegatesUpdate(oldMax, newMax); // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L152-L152)

```166: 
167:         emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax); // <= FOUND
```

*GitHub* : [167](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L167-L167)

```314:         emit DelegateChanged(delegator, oldDelegatee, newDelegatee); // <= FOUND
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L314-L314)

```340: 
341:         emit Delegation(delegator, delegatee, amount); // <= FOUND
```

*GitHub* : [341](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L341-L341)

```359: 
360:         emit Undelegation(delegator, delegatee, amount); // <= FOUND
```

*GitHub* : [360](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L360-L360)

```384:         emit DelegateVotesChanged(delegatee, oldWeight, newWeight); // <= FOUND
```

*GitHub* : [384](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L384-L384)

```456:                 emit Undelegation(user, delegatee, delegateVotes); // <= FOUND
```

*GitHub* : [456](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L456-L456)

```298:         emit RebaseEnter(account, block.timestamp); // <= FOUND
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L298-L298)

```326:             emit RebaseReward(account, block.timestamp, mintAmount); // <= FOUND
```

*GitHub* : [326](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L326-L326)

```332: 
333:         emit RebaseExit(account, block.timestamp); // <= FOUND
```

*GitHub* : [333](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L333-L333)

```353:         emit RebaseDistribution( // <= FOUND
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
```

*GitHub* : [353](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L353-L353)

```481:                 emit RebaseReward(account, block.timestamp, mintAmount); // <= FOUND
```

*GitHub* : [481](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L481-L481)

```579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount); // <= FOUND
```

*GitHub* : [579](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L579-L579)

```630:                 emit RebaseReward(to, block.timestamp, mintAmount); // <= FOUND
```

*GitHub* : [630](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L630-L630)

```673:                 emit RebaseReward(from, block.timestamp, mintAmount); // <= FOUND
```

*GitHub* : [673](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L673-L673)

```128:         emit GaugeLoss(gauge, block.timestamp); // <= FOUND
```

*GitHub* : [128](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L128-L128)

```155:         emit GaugeLossApply( // <= FOUND
156:             gauge,
157:             who,
158:             uint256(_userGaugeWeight),
159:             block.timestamp
160:         );
```

*GitHub* : [155](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L155-L155)

```177:         emit TransfersEnabled(block.number, block.timestamp); // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L177-L177)

```199:         emit ProfitManagerUpdated(block.timestamp, _newProfitManager); // <= FOUND
```

*GitHub* : [199](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L199-L199)

```106: 
107:         
108:         emit AuctionStart( // <= FOUND
109:             block.timestamp,
110:             loanId,
111:             LendingTerm(msg.sender).collateralToken(),
112:             loan.collateralAmount,
113:             callDebt
114:         );
```

*GitHub* : [108](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L108-L108)

```189: 
190:         
191:         emit AuctionEnd( // <= FOUND
192:             block.timestamp,
193:             loanId,
194:             LendingTerm(_lendingTerm).collateralToken(),
195:             collateralReceived, 
196:             creditAsked 
197:         );
```

*GitHub* : [191](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L191-L191)

```223: 
224:         
225:         emit AuctionEnd( // <= FOUND
226:             block.timestamp,
227:             loanId,
228:             LendingTerm(_lendingTerm).collateralToken(),
229:             0, 
230:             0 
231:         );
```

*GitHub* : [225](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L225-L225)

```428: 
429:         
430:         emit LoanOpen( // <= FOUND
431:             block.timestamp,
432:             loanId,
433:             borrower,
434:             collateralAmount,
435:             borrowAmount
436:         );
```

*GitHub* : [430](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L430-L430)

```473: 
474:         
475:         emit LoanAddCollateral( // <= FOUND
476:             block.timestamp,
477:             loanId,
478:             borrower,
479:             collateralToAdd
480:         );
```

*GitHub* : [475](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L475-L475)

```558: 
559:         
560:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay); // <= FOUND
```

*GitHub* : [560](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L560-L560)

```624: 
625:         
626:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt); // <= FOUND
```

*GitHub* : [626](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L626-L626)

```674: 
675:         
676:         emit LoanCall(block.timestamp, loanId); // <= FOUND
```

*GitHub* : [676](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L676-L676)

```721: 
722:         
723:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Forgive, 0); // <= FOUND
```

*GitHub* : [723](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L723-L723)

```819: 
820:         emit LoanClose( // <= FOUND
821:             block.timestamp,
822:             loanId,
823:             LoanCloseType.Call,
824:             creditFromBidder
825:         );
```

*GitHub* : [820](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L820-L820)

```111:         emit Mint(block.timestamp, to, amountIn, amountOut); // <= FOUND
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L111-L111)

```129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut); // <= FOUND
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L129-L129)

```143:         emit Redeem(block.timestamp, to, amountIn, amountOut); // <= FOUND
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L143-L143)

```153:         emit RedemptionsPaused(block.timestamp, paused); // <= FOUND
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L153-L153)

```154: 
155:         
156:         emit Stake(block.timestamp, term, amount); // <= FOUND
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L156-L156)

```211: 
212:         
213:         emit Unstake(block.timestamp, term, amount); // <= FOUND
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L213-L213)

```260:                 emit GuildReward(block.timestamp, user, guildReward); // <= FOUND
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L260-L260)

```275:             emit Unstake(block.timestamp, term, uint256(userStake.credit)); // <= FOUND
```

*GitHub* : [275](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L275-L275)

```323:         emit MintRatioUpdate(block.timestamp, _mintRatio); // <= FOUND
```

*GitHub* : [323](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L323-L323)

```332:         emit RewardRatioUpdate(block.timestamp, _rewardRatio); // <= FOUND
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L332-L332)

```106: 
107:         emit BufferUsed(amount, bufferStored); // <= FOUND
```

*GitHub* : [107](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L107-L107)

```134: 
135:         emit BufferReplenished(amount, bufferStored); // <= FOUND
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L135-L135)

```142: 
143:         emit RateLimitPerSecondUpdate( // <= FOUND
144:             oldRateLimitPerSecond,
145:             newRateLimitPerSecond
146:         );
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L143-L143)

```155: 
156:         emit BufferCapUpdate(oldBufferCap, newBufferCap); // <= FOUND
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L156-L156)
### [GAS-39]<a name="gas-39"></a> Use solady library where possible to save gas
The following OpenZeppelin imports have a Solady equivalent, as such they can be used to save GAS as Solady modules have been specifically designed to be as GAS efficient as possible

*There are 6 instance(s) of this issue:*

```5: import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L5-L5)

```4: import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // <= FOUND
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L4-L4)

```6: import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L6-L6)

```6: import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L6-L6)

```5: import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // <= FOUND
```

*GitHub* : [5](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L5-L5)

```6: import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol"; // <= FOUND
```

*GitHub* : [6](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L6-L6)
### [GAS-40]<a name="gas-40"></a> Use unchecked for operations on immutable variables
The `unchecked { }` block in Solidity provides a way to execute arithmetic operations without the usual automatic overflow/underflow checks, thus saving gas. When using it with immutable variables during assignment in the constructor, it's safe and efficient because these variables' values are defined at contract deployment and remain constant thereafter. You are certain of these values at compile-time, and hence the risk of unexpected overflow or underflow is eliminated. However, this optimization should be used with caution, ensuring it doesn't compromise code clarity and security.

*There are 1 instance(s) of this issue:*

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager;
72:         credit = _credit;
73:         pegToken = _pegToken;
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals); // <= FOUND
77:     }
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L76)
### [GAS-41]<a name="gas-41"></a> Counting down in for statements is more gas efficient
Looping downwards in Solidity is more gas efficient due to how the EVM compares variables. In a 'for' loop that counts down, the end condition is usually to compare with zero, which is cheaper than comparing with another number. As such, restructure your loops to count downwards where possible.

*There are 7 instance(s) of this issue:*

```96:        for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value;
99:             bytes calldata callData = calls[i].callData;
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```443:        for (uint256 i = 0; i < gauges.length; ) {
444:             creditEarned += claimGaugeRewards(user, gauges[i]);
445:             unchecked {
446:                 ++i; // <= FOUND
447:             }
448:         }
```

*GitHub* : [446](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L446-L446)

```467:        for (uint256 i = 0; i < gauges.length; ) {
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i; // <= FOUND
489:             }
490:         }
```

*GitHub* : [488](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L488-L488)

```134:        for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) {
135:             if (!_deprecatedGauges.contains(allGauges[i])) {
136:                 _liveGauges[j] = allGauges[i];
137:                 unchecked {
138:                     ++j; // <= FOUND
139:                 }
140:             }
141:             unchecked {
142:                 ++i; // <= FOUND
143:             }
144:         }
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L138-L142)

```280:        for (uint256 i = 0; i < size; ) {
281:             address gauge = gaugeList[i];
282:             uint256 weight = weights[i];
283:             weightsSum += weight;
284: 
285:             require(isGauge(gauge), "ERC20Gauges: invalid gauge");
286: 
287:             _incrementGaugeWeight(msg.sender, gauge, weight);
288:             unchecked {
289:                 ++i; // <= FOUND
290:             }
291:         }
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L289-L289)

```352:        for (uint256 i = 0; i < size; ) {
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i];
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight);
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i; // <= FOUND
363:             }
364:         }
```

*GitHub* : [362](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L362-L362)

```685:        for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
686:             _call(msg.sender, loanIds[i], _auctionHouse);
687:         }
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [GAS-42]<a name="gas-42"></a> State variables can be packed into fewer storage slots by truncating timestamp bytes
State variables in Solidity are typically stored in 32-byte storage slots. When dealing with timestamps, which generally fit into a smaller byte size, it can be beneficial to truncate these bytes and pack them with other variables. This reduces the number of required storage slots, saving both storage space and associated gas costs. For example, a timestamp generally fits into a uint32, so it can be combined with other small variables within a single storage slot. When designing a contract, carefully structuring state variables to utilize truncation and packing can lead to a more efficient and cost-effective implementation.

*There are 4 instance(s) of this issue:*

```99:     struct InterpolatedValue { // <= FOUND
100:         uint32 lastTimestamp; // <= FOUND
101:         uint224 lastValue;
102:         uint32 targetTimestamp; // <= FOUND
103:         uint224 targetValue;
104:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L99-L102)

```40:     struct Auction { // <= FOUND
41:         uint256 startTime; // <= FOUND
42:         uint256 endTime; // <= FOUND
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L42)

```75:     struct Loan { // <= FOUND
76:         address borrower; 
77:         uint256 borrowTime;  // <= FOUND
78:         uint256 borrowAmount; 
79:         uint256 borrowCreditMultiplier; 
80:         uint256 collateralAmount; 
81:         address caller; 
82:         uint256 callTime;  // <= FOUND
83:         uint256 callDebt; 
84:         uint256 closeTime;  // <= FOUND
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L84)

```77:     struct UserStake { // <= FOUND
78:         uint48 stakeTime; // <= FOUND
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L77-L78)
### [GAS-43]<a name="gas-43"></a> Using private rather than public for constants and immutables, saves gas
Using private visibility for constants and immutables in Solidity instead of public can save gas. This is because private elements are not included in the contract's ABI, reducing the deployment and interaction costs. To achieve better efficiency, it is recommended to use private visibility when external access is not needed.

*There are 6 instance(s) of this issue:*

```36: uint256 public constant POLL_DURATION_BLOCKS = 46523;  // <= FOUND
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L36-L36)

```25: uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days; // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L25-L25)

```29: uint256 public constant YEAR = 31557600; // <= FOUND
```

*GitHub* : [29](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L29-L29)

```26: uint256 public constant MIN_STAKE = 1e18; // <= FOUND
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L26-L26)

```467: bytes32 public constant DELEGATION_TYPEHASH = // <= FOUND
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L467-L467)

```97: uint256 public constant DISTRIBUTION_PERIOD = 30 days; // <= FOUND
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L97-L97)
### [GAS-44]<a name="gas-44"></a> Mark Functions That Revert For Normal Users As payable
In Solidity, marking functions as `payable` allows them to accept Ether. If a function is known to revert for regular users (non-admin or specific roles) but needs to be accessible to others, marking it as `payable` can be beneficial. This ensures that even if a regular user accidentally sends Ether to the function, the Ether won't be trapped, as the function reverts, returning the funds. This can save gas by avoiding unnecessary failure handling in the function itself. Resolution: Carefully assess the roles and access patterns, and mark functions that should revert for regular users as `payable` to handle accidental Ether transfers.

*There are 1 instance(s) of this issue:*

```50:     function createRole(
51:         bytes32 role,
52:         bytes32 adminRole
53:     ) external onlyRole(CoreRoles.GOVERNOR) {
54:         _setRoleAdmin(role, adminRole);
55:     }
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L50-L50)
### [GAS-45]<a name="gas-45"></a> State variable read in a loop
Reading a state variable inside a loop in Solidity can be gas-inefficient, particularly in older versions of the language. Each read from a state variable in a loop incurs a gas cost, and these costs can accumulate quickly if the loop iterates many times. As a resolution, developers often manually cache the state variable outside the loop, reducing the number of state reads. By reading the variable only once and using the cached value within the loop, the gas costs can be significantly reduced. This approach requires careful consideration of the code's logic but can lead to more efficient contract execution.

*There are 2 instance(s) of this issue:*

```443:        for (uint256 i = 0; i < gauges.length; ) {
444:             creditEarned += claimGaugeRewards(user, gauges[i]); // <= FOUND
445:             unchecked {
446:                 ++i;
447:             }
448:         }
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L444-L444)

```467:        for (uint256 i = 0; i < gauges.length; ) {
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
484:                 totalCreditEarned += creditEarned[i]; // <= FOUND
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
```

*GitHub* : [483](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L483-L484)
### [GAS-46]<a name="gas-46"></a> Function names can be optimized
Function names in Solidity contracts can be optimized to save gas during both deployment and execution. Method IDs are the first four bytes of the keccak256 hash of the function signature, and having two leading zero bytes can save 128 gas each during deployment. Additionally, renaming functions to have lower method IDs can save 22 gas per call, per sorted position shifted. This optimization leverages the way EVM handles data storage, making the execution more efficient. While these savings might seem minor, they can add up in contracts with numerous calls, contributing to more economical and efficient code.

*There are 14 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is // <= FOUND
17:     CoreRef, // <= FOUND
18:     Governor, // <= FOUND
19:     GovernorVotes, // <= FOUND
20:     GovernorTimelockControl, // <= FOUND
21:     GovernorSettings, // <= FOUND
22:     GovernorCountingSimple // <= FOUND
23:  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L23)

```14: contract GuildTimelockController is TimelockController, CoreRef  // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```16: contract LendingTermOffboarding is CoreRef  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor  // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is // <= FOUND
19:     CoreRef, // <= FOUND
20:     ERC20Burnable, // <= FOUND
21:     ERC20MultiVotes, // <= FOUND
22:     ERC20RebaseDistributor // <= FOUND
23:  // <= FOUND
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L23)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef  // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef  // <= FOUND
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2  // <= FOUND
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [GAS-47]<a name="gas-47"></a> Consider migrating require statements to custom errors
Using custom errors instead of 'require' statements in Solidity can lead to gas savings and improve developer experience. Custom errors provide explicit error messages, aiding in troubleshooting. Moreover, custom errors are cheaper as they don't require a string literal, thus saving gas. Hence, developers should replace 'require' statements with custom errors wherever possible for efficiency and readability.

*There are 106 instance(s) of this issue:*

```25:         require(_core.hasRole(role, msg.sender), "UNAUTHORIZED"); // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L25-L25)

```104:             require(success, "CoreRef: underlying call reverted"); // <= FOUND
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L104-L104)

```90:         require( // <= FOUND
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         ); // <= FOUND
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L90-L93)

```94:         require( // <= FOUND
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         ); // <= FOUND
```

*GitHub* : [94](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L94-L97)

```99:         
100:         require( // <= FOUND
101:             GuildToken(guildToken).isGauge(term),
102:             "LendingTermOffboarding: not an active term"
103:         ); // <= FOUND
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L99-L103)

```120:         require( // <= FOUND
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         ); // <= FOUND
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L120-L123)

```125:         require(_weight != 0, "LendingTermOffboarding: poll not found"); // <= FOUND
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L125-L125)

```130:         require(userWeight != 0, "LendingTermOffboarding: zero weight"); // <= FOUND
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L130-L130)

```131:         require( // <= FOUND
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0,
133:             "LendingTermOffboarding: already voted"
134:         ); // <= FOUND
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L131-L134)

```154:         require(canOffboard[term], "LendingTermOffboarding: quorum not met"); // <= FOUND
```

*GitHub* : [154](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L154-L154)

```177:         require( // <= FOUND
178:             LendingTerm(term).issuance() == 0,
179:             "LendingTermOffboarding: not all loans closed"
180:         ); // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L177-L180)

```181:         require( // <= FOUND
182:             GuildToken(guildToken).isDeprecatedGauge(term),
183:             "LendingTermOffboarding: re-onboarded"
184:         ); // <= FOUND
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L181-L184)

```109:         require( // <= FOUND
110:             implementations[implementation],
111:             "LendingTermOnboarding: invalid implementation"
112:         ); // <= FOUND
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L109-L112)

```117:         require( // <= FOUND
118:             success && returned.length == 32,
119:             "LendingTermOnboarding: invalid collateralToken"
120:         ); // <= FOUND
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L117-L120)

```122: 
123:         require( // <= FOUND
124:             params.maxDebtPerCollateralToken != 0, 
125:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
126:         ); // <= FOUND
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L122-L126)

```127: 
128:         require( // <= FOUND
129:             params.interestRate < 1e18, 
130:             "LendingTermOnboarding: invalid interestRate"
131:         ); // <= FOUND
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L127-L131)

```132: 
133:         require( // <= FOUND
134:             
135:             params.maxDelayBetweenPartialRepay < 31557601, 
136:             "LendingTermOnboarding: invalid maxDelayBetweenPartialRepay"
137:         ); // <= FOUND
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L132-L137)

```138: 
139:         require( // <= FOUND
140:             params.minPartialRepayPercent < 1e18, 
141:             "LendingTermOnboarding: invalid minPartialRepayPercent"
142:         ); // <= FOUND
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L138-L142)

```143: 
144:         require( // <= FOUND
145:             params.openingFee <= 0.1e18, 
146:             "LendingTermOnboarding: invalid openingFee"
147:         ); // <= FOUND
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L143-L147)

```148: 
149:         require( // <= FOUND
150:             params.hardCap != 0, 
151:             "LendingTermOnboarding: invalid hardCap"
152:         ); // <= FOUND
```

*GitHub* : [148](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L148-L152)

```185:         
186:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
```

*GitHub* : [185](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L185-L186)

```188: 
189:         
190:         require( // <= FOUND
191:             lastProposal[term] + MIN_DELAY_BETWEEN_PROPOSALS < block.timestamp,
192:             "LendingTermOnboarding: recently proposed"
193:         ); // <= FOUND
```

*GitHub* : [188](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L188-L193)

```200:         require(!isGauge, "LendingTermOnboarding: active term"); // <= FOUND
```

*GitHub* : [200](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L200-L200)

```203:             require(otherSplit == 0, "GuildToken: invalid config"); // <= FOUND
```

*GitHub* : [203](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L203-L203)

```205:             require(otherSplit != 0, "GuildToken: invalid config"); // <= FOUND
```

*GitHub* : [205](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L205-L205)

```207:         require( // <= FOUND
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         ); // <= FOUND
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L207-L210)

```204: 
205:         require( // <= FOUND
206:             !proposalvote.hasVoted[account],
207:             "GuildVetoGovernor: vote already cast"
208:         ); // <= FOUND
```

*GitHub* : [204](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L204-L208)

```319:         require( // <= FOUND
320:             timelockExecutionTime > 1,
321:             "GuildVetoGovernor: action must be pending"
322:         ); // <= FOUND
```

*GitHub* : [319](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L319-L322)

```223:         require(isGauge(gauge), "ERC20Gauges: invalid gauge"); // <= FOUND
```

*GitHub* : [223](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L223-L223)

```237:             require(canExceedMaxGauges[user], "ERC20Gauges: exceed max gauges"); // <= FOUND
```

*GitHub* : [237](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L237-L237)

```255:         
256:         require(newUserWeight <= balanceOf(user), "ERC20Gauges: overweight"); // <= FOUND
```

*GitHub* : [255](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L255-L256)

```274:         require(weights.length == size, "ERC20Gauges: size mismatch"); // <= FOUND
```

*GitHub* : [274](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L274-L274)

```285: 
286:             require(isGauge(gauge), "ERC20Gauges: invalid gauge"); // <= FOUND
```

*GitHub* : [285](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L285-L286)

```324:             
325:             require(_userGauges[user].remove(gauge)); // <= FOUND
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L324-L325)

```402:         
403:         require( // <= FOUND
404:             gauge != address(0) && (newAdd || previouslyDeprecated),
405:             "ERC20Gauges: invalid gauge"
406:         ); // <= FOUND
```

*GitHub* : [402](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L402-L406)

```412:             
413:             require(gaugeType[gauge] == _type, "ERC20Gauges: invalid type"); // <= FOUND
```

*GitHub* : [412](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L412-L413)

```427:         
428:         require( // <= FOUND
429:             _gauges.contains(gauge) && _deprecatedGauges.add(gauge),
430:             "ERC20Gauges: invalid gauge"
431:         ); // <= FOUND
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L427-L431)

```457:             require( // <= FOUND
458:                 account.code.length != 0,
459:                 "ERC20Gauges: not a smart contract"
460:             ); // <= FOUND
```

*GitHub* : [457](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L457-L460)

```95:         require( // <= FOUND
96:             blockNumber < block.number,
97:             "ERC20MultiVotes: not a past block"
98:         ); // <= FOUND
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L95-L98)

```159:         require( // <= FOUND
160:             !canExceedMax || account.code.length != 0,
161:             "ERC20MultiVotes: not a smart contract"
162:         );  // <= FOUND
```

*GitHub* : [159](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L159-L162)

```297: 
298:         
299:         require(count < 2, "ERC20MultiVotes: delegation error"); // <= FOUND
```

*GitHub* : [297](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L297-L299)

```324:         require( // <= FOUND
325:             delegatee != address(0) && free >= amount,
326:             "ERC20MultiVotes: delegation error"
327:         ); // <= FOUND
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L324-L327)

```330:         require( // <= FOUND
331:             !newDelegate ||
332:                 delegateCount(delegator) <= maxDelegates ||
333:                 canContractExceedMaxDelegates[delegator],
334:             "ERC20MultiVotes: delegation error"
335:         ); // <= FOUND
```

*GitHub* : [330](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L330-L335)

```353:             require(_delegates[delegator].remove(delegatee)); // <= FOUND
```

*GitHub* : [353](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L353-L353)

```451: 
452:                 require(_delegates[user].remove(delegatee));  // <= FOUND
```

*GitHub* : [451](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L451-L452)

```479:         require( // <= FOUND
480:             block.timestamp <= expiry,
481:             "ERC20MultiVotes: signature expired"
482:         ); // <= FOUND
```

*GitHub* : [479](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L479-L482)

```502:         require(nonce == _useNonce(signer), "ERC20MultiVotes: invalid nonce"); // <= FOUND
```

*GitHub* : [502](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L502-L502)

```503:         require(signer != address(0)); // <= FOUND
```

*GitHub* : [503](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L503-L503)

```282:         require( // <= FOUND
283:             rebasingState[msg.sender].isRebasing == 0,
284:             "ERC20RebaseDistributor: already rebasing"
285:         ); // <= FOUND
```

*GitHub* : [282](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L282-L285)

```304:         require( // <= FOUND
305:             rebasingState[msg.sender].isRebasing == 1,
306:             "ERC20RebaseDistributor: not rebasing"
307:         ); // <= FOUND
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L304-L307)

```339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero"); // <= FOUND
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L339-L339)

```61:         require( // <= FOUND
62:             rebasingState[account].isRebasing == 0,
63:             "CreditToken: already rebasing"
64:         ); // <= FOUND
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L61-L64)

```72:         require( // <= FOUND
73:             rebasingState[account].isRebasing == 1,
74:             "CreditToken: not rebasing"
75:         ); // <= FOUND
```

*GitHub* : [72](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L72-L75)

```124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L124)

```137:         require( // <= FOUND
138:             _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,
139:             "GuildToken: no loss to apply"
140:         ); // <= FOUND
```

*GitHub* : [137](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L137-L140)

```187:         require( // <= FOUND
188:             transferable || from == address(0) || to == address(0),
189:             "GuildToken: transfers disabled"
190:         ); // <= FOUND
```

*GitHub* : [187](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L187-L190)

```214:         require( // <= FOUND
215:             _lastGaugeLossApplied >= _lastGaugeLoss,
216:             "GuildToken: pending loss"
217:         ); // <= FOUND
```

*GitHub* : [214](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L214-L217)

```227:             require( // <= FOUND
228:                 issuance <= debtCeilingAfterDecrement,
229:                 "GuildToken: debt ceiling used"
230:             ); // <= FOUND
```

*GitHub* : [227](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L227-L230)

```252:             require( // <= FOUND
253:                 _lastGaugeLossApplied >= _lastGaugeLoss,
254:                 "GuildToken: pending loss"
255:             ); // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L252-L255)

```61:         require(_midPoint < _auctionDuration, "AuctionHouse: invalid params"); // <= FOUND
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L61-L61)

```77:         
78:         require( // <= FOUND
79:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
80:             "AuctionHouse: invalid caller"
81:         ); // <= FOUND
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L77-L81)

```84:         require( // <= FOUND
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         ); // <= FOUND
```

*GitHub* : [84](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L84-L87)

```90: 
91:         
92:         require( // <= FOUND
93:             auctions[loanId].startTime == 0,
94:             "AuctionHouse: auction exists"
95:         ); // <= FOUND
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L90-L95)

```123:         require(_startTime != 0, "AuctionHouse: invalid auction"); // <= FOUND
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L123-L123)

```126: 
127:         
128:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended"); // <= FOUND
```

*GitHub* : [126](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L126-L128)

```172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0"); // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L172-L172)

```206:         require(creditAsked == 0, "AuctionHouse: ongoing auction"); // <= FOUND
```

*GitHub* : [206](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L206-L206)

```344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0"); // <= FOUND
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L344-L344)

```345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0"); // <= FOUND
```

*GitHub* : [345](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L345-L345)

```352: 
353:         
354:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists"); // <= FOUND
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L352-L354)

```359:         require( // <= FOUND
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         ); // <= FOUND
```

*GitHub* : [359](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L359-L362)

```365: 
366:         
367:         require( // <= FOUND
368:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
369:             "LendingTerm: borrow amount too low"
370:         ); // <= FOUND
```

*GitHub* : [365](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L365-L370)

```373:         require( // <= FOUND
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         ); // <= FOUND
```

*GitHub* : [373](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L373-L376)

```392:             
393:             
394:             
395:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached"); // <= FOUND
```

*GitHub* : [392](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L392-L395)

```394:             require( // <= FOUND
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             ); // <= FOUND
```

*GitHub* : [394](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L394-L397)

```453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0"); // <= FOUND
```

*GitHub* : [453](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L453-L453)

```458: 
459:         
460:         require(loan.borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [458](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L458-L460)

```459:         require(loan.closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [459](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L459-L459)

```460:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L460)

```499:         require(borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [499](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L499-L499)

```500:         require( // <= FOUND
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         ); // <= FOUND
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L500-L503)

```509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment"); // <= FOUND
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L509-L509)

```519:         require( // <= FOUND
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         ); // <= FOUND
```

*GitHub* : [519](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L519-L522)

```523:         require( // <= FOUND
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         ); // <= FOUND
```

*GitHub* : [523](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L523-L526)

```527:         require( // <= FOUND
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         ); // <= FOUND
```

*GitHub* : [527](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L527-L531)

```458:         require(loan.borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [458](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L458-L458)

```459: 
460:         
461:         require(loan.closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [459](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L459-L461)

```460: 
461:         
462:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L462)

```652: 
653:         
654:         require( // <= FOUND
655:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) ||
656:                 partialRepayDelayPassed(loanId),
657:             "LendingTerm: cannot call"
658:         ); // <= FOUND
```

*GitHub* : [652](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L652-L658)

```500: 
501:         
502:         require( // <= FOUND
503:             borrowTime < block.timestamp,
504:             "LendingTerm: loan opened in same block"
505:         ); // <= FOUND
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L500-L505)

```733:         
734:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller"); // <= FOUND
```

*GitHub* : [733](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L733-L734)

```734:         require( // <= FOUND
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         ); // <= FOUND
```

*GitHub* : [734](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L734-L737)

```738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [738](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L738-L738)

```744:         require( // <= FOUND
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         ); // <= FOUND
```

*GitHub* : [744](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L744-L748)

```764:             require( // <= FOUND
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             ); // <= FOUND
```

*GitHub* : [764](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L764-L767)

```836:         
837:         
838:         
839:         
840:         require( // <= FOUND
841:             AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0,
842:             "LendingTerm: auctions in progress"
843:         ); // <= FOUND
```

*GitHub* : [836](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L836-L843)

```120:         require( // <= FOUND
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         ); // <= FOUND
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L120-L123)

```138:         require(!redemptionsPaused, "SimplePSM: redemptions paused"); // <= FOUND
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L138-L138)

```121: 
122:         require( // <= FOUND
123:             lastGaugeLoss != block.timestamp,
124:             "SurplusGuildMinter: loss in block"
125:         ); // <= FOUND
```

*GitHub* : [121](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L121-L125)

```125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake"); // <= FOUND
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L125-L125)

```169: 
170:         
171:         require( // <= FOUND
172:             amount != 0 && userStake.credit >= amount,
173:             "SurplusGuildMinter: invalid amount"
174:         ); // <= FOUND
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L169-L174)

```191:             
192:             
193:             require( // <= FOUND
194:                 userStake.credit >= MIN_STAKE,
195:                 "SurplusGuildMinter: remaining stake below min"
196:             ); // <= FOUND
```

*GitHub* : [191](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L191-L196)

```50: 
51:         require( // <= FOUND
52:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
53:             "RateLimited: rateLimitPerSecond too high"
54:         ); // <= FOUND
```

*GitHub* : [50](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L50-L54)

```64:         require( // <= FOUND
65:             newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,
66:             "RateLimited: rateLimitPerSecond too high"
67:         ); // <= FOUND
```

*GitHub* : [64](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L64-L67)

```96: 
97:         require(newBuffer != 0, "RateLimited: no rate limit buffer"); // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L96-L97)

```97:         require(amount <= newBuffer, "RateLimited: rate limit hit"); // <= FOUND
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L97-L97)
### [GAS-48]<a name="gas-48"></a> Consider not using libraries when implementing simple functionality.
When implementing certain functionalities in a smart contract, using libraries can sometimes incur additional costs compared to including the functionality directly within the contract. Libraries in Solidity are essentially contracts that get deployed separately and then linked to the main contract, so there's an overhead cost associated with calling them. If the functionality is relatively simple, this overhead can outweigh the benefits of code reuse and modularity provided by libraries. Thus, in such cases, implementing the functionality directly within the contract could be more gas-efficient. However, this approach should be balanced against considerations of code readability, maintainability, and the potential for code reuse.

*There are 1 instance(s) of this issue:*

```8: library CoreRoles  // <= FOUND
```

*GitHub* : [8](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRoles.sol#L8-L8)
### [GAS-49]<a name="gas-49"></a> Where a value is casted more than once, consider caching the result to save gas
Casting values multiple times in Solidity can be gas-inefficient. When a value undergoes repeated type conversions, the EVM must execute additional operations for each cast, consuming more gas than necessary. To optimize for gas efficiency, cache the result of the initial cast in a local variable and reuse it, rather than performing multiple casts. This not only conserves gas but also enhances code readability, reducing potential error points. For example, instead of repeatedly casting an `address` to `uint256`, cast once, store the result in a local variable, and reference that variable in subsequent operations.

*There are 1 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) * // <= FOUND
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) * // <= FOUND
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) * // <= FOUND
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) - // <= FOUND
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L355)
### [GAS-50]<a name="gas-50"></a> State variable can be updated more than once in a function
Updating a state variable multiple times within a function can lead to inefficiencies and unintended behaviors. Every state change in Ethereum consumes gas, increasing the transaction cost. Moreover, frequent state changes can introduce vulnerabilities if interim values can be externally observed or acted upon. To address this, one should consolidate updates to occur only once, at the end of the function. This minimizes gas usage and ensures consistent state.

*There are 3 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss; // <= FOUND
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0; // <= FOUND
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer; // <= FOUND
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L362)

```168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
196:             __unmintedRebaseRewards = InterpolatedValue({
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             });
202:             return;
203:         }
204: 
205:         
206:         
207:         
208:         
209:         
210:         InterpolatedValue memory val = __rebasingSharePrice;
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice +
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
218:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), 
221:                 targetTimestamp: val.targetTimestamp, 
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) 
223:             });
224:         }
225:     }
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L218)

```158:     function _updateBufferStored(uint128 newBufferCap) internal {
159:         uint224 newBufferStored = buffer().safeCastTo224();
160:         uint32 newBlockTimestamp = block.timestamp.safeCastTo32();
161: 
162:         if (newBufferStored > newBufferCap) {
163:             bufferStored = uint224(newBufferCap);  // <= FOUND
164:             lastBufferUsedTime = newBlockTimestamp; // <= FOUND
165:         } else {
166:             bufferStored = newBufferStored; // <= FOUND
167:             lastBufferUsedTime = newBlockTimestamp; // <= FOUND
168:         }
169:     }
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L167)
### [GAS-51]<a name="gas-51"></a> Use assembly to validate msg.sender
Utilizing assembly for validating `msg.sender` can potentially save gas as it allows for more direct and efficient access to Ethereum’s EVM opcodes, bypassing some of the overhead introduced by Solidity’s higher-level abstractions. However, this practice requires deep expertise in EVM, as incorrect implementation can introduce critical vulnerabilities. It is a trade-off between gas efficiency and code safety.

*There are 8 instance(s) of this issue:*

```25:         require(_core.hasRole(role, msg.sender), "UNAUTHORIZED"); // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L25-L25)

```131:         require( // <= FOUND
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0, // <= FOUND
133:             "LendingTermOffboarding: already voted"
134:         );
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L131-L132)

```282:         require( // <= FOUND
283:             rebasingState[msg.sender].isRebasing == 0, // <= FOUND
284:             "ERC20RebaseDistributor: already rebasing"
285:         );
```

*GitHub* : [282](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L282-L283)

```304:         require( // <= FOUND
305:             rebasingState[msg.sender].isRebasing == 1, // <= FOUND
306:             "ERC20RebaseDistributor: not rebasing"
307:         );
```

*GitHub* : [304](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L304-L305)

```124:         require(msg.sender == profitManager, "UNAUTHORIZED"); // <= FOUND
```

*GitHub* : [124](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L124-L124)

```77:         
78:         require( // <= FOUND
79:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender), // <= FOUND
80:             "AuctionHouse: invalid caller"
81:         );
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L77-L79)

```733:         
734:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller"); // <= FOUND
```

*GitHub* : [733](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L733-L734)

```120:         require( // <= FOUND
121:             !CreditToken(credit).isRebasing(msg.sender), // <= FOUND
122:             "SimplePSM: already rebasing"
123:         );
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L120-L121)
### [GAS-52]<a name="gas-52"></a> Simple checks for zero uint can be done using assembly to save gas
Using assembly for simple zero checks on unsigned integers can save gas due to lower-level, optimized operations. 

**Resolution**: Implement inline assembly with Solidity's `assembly` block to perform zero checks. Ensure thorough testing and verification, as assembly lacks the safety checks of high-level Solidity, potentially introducing vulnerabilities if not used carefully.

*There are 47 instance(s) of this issue:*

```90:         require(
91:             polls[block.number][term] == 0, // <= FOUND
92:             "LendingTermOffboarding: poll exists"
93:         );
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L90-L91)

```131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0, // <= FOUND
133:             "LendingTermOffboarding: already voted"
134:         );
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L131-L132)

```177:         require(
178:             LendingTerm(term).issuance() == 0, // <= FOUND
179:             "LendingTermOffboarding: not all loans closed"
180:         );
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L177-L178)

```203:             require(otherSplit == 0, "GuildToken: invalid config"); // <= FOUND
```

*GitHub* : [203](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L203-L203)

```189:         if (total == 0) return 0; // <= FOUND
```

*GitHub* : [189](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L189-L189)

```82:         return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes; // <= FOUND
```

*GitHub* : [82](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L82-L82)

```119: 
120:         return high == 0 ? 0 : ckpts[high - 1].votes; // <= FOUND
```

*GitHub* : [119](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L119-L120)

```371:         uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes; // <= FOUND
```

*GitHub* : [371](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L371-L371)

```172:         if (sharesDelta == 0) return; // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L172-L172)

```282:         require(
283:             rebasingState[msg.sender].isRebasing == 0, // <= FOUND
284:             "ERC20RebaseDistributor: already rebasing"
285:         );
```

*GitHub* : [282](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L282-L283)

```61:         require(
62:             rebasingState[account].isRebasing == 0, // <= FOUND
63:             "CreditToken: already rebasing"
64:         );
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L61-L62)

```90: 
91:         
92:         require(
93:             auctions[loanId].startTime == 0, // <= FOUND
94:             "AuctionHouse: auction exists"
95:         );
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L90-L93)

```126: 
127:         
128:         require(auctions[loanId].endTime == 0, "AuctionHouse: auction ended"); // <= FOUND
```

*GitHub* : [126](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L126-L128)

```206:         require(creditAsked == 0, "AuctionHouse: ongoing auction"); // <= FOUND
```

*GitHub* : [206](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L206-L206)

```241:         
242:         if (params.maxDelayBetweenPartialRepay == 0) return false; // <= FOUND
```

*GitHub* : [241](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L241-L242)

```244: 
245:         
246:         if (loans[loanId].borrowTime == 0) return false; // <= FOUND
```

*GitHub* : [244](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L244-L246)

```352: 
353:         
354:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists"); // <= FOUND
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L352-L354)

```459:         require(loan.closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [459](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L459-L459)

```460:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L460)

```459: 
460:         
461:         require(loan.closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [459](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L459-L461)

```460: 
461:         
462:         require(loan.callTime == 0, "LendingTerm: loan called"); // <= FOUND
```

*GitHub* : [460](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L460-L462)

```738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed"); // <= FOUND
```

*GitHub* : [738](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L738-L738)

```764:             require(
765:                 collateralToBorrower == 0, // <= FOUND
766:                 "LendingTerm: invalid collateral movement"
767:             );
```

*GitHub* : [764](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L764-L765)

```836:         
837:         
838:         
839:         
840:         require(
841:             AuctionHouse(refs.auctionHouse).nAuctionsInProgress() == 0, // <= FOUND
842:             "LendingTerm: auctions in progress"
843:         );
```

*GitHub* : [836](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L836-L841)

```235:         if (userStake.stakeTime == 0) // <= FOUND
236:             return (lastGaugeLoss, userStake, slashed);
```

*GitHub* : [235](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L235-L235)

```244: 
245:         if (_profitIndex == 0) _profitIndex = 1e18; // <= FOUND
```

*GitHub* : [244](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L244-L245)

```245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18; // <= FOUND
```

*GitHub* : [245](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L245-L245)

```125:         require(_weight != 0, "LendingTermOffboarding: poll not found"); // <= FOUND
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L125-L125)

```130:         require(userWeight != 0, "LendingTermOffboarding: zero weight"); // <= FOUND
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L130-L130)

```122: 
123:         require(
124:             params.maxDebtPerCollateralToken != 0,  // <= FOUND
125:             "LendingTermOnboarding: invalid maxDebtPerCollateralToken"
126:         );
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L122-L124)

```148: 
149:         require(
150:             params.hardCap != 0,  // <= FOUND
151:             "LendingTermOnboarding: invalid hardCap"
152:         );
```

*GitHub* : [148](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L148-L150)

```185:         
186:         require(created[term] != 0, "LendingTermOnboarding: invalid term"); // <= FOUND
```

*GitHub* : [185](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L185-L186)

```205:             require(otherSplit != 0, "GuildToken: invalid config"); // <= FOUND
```

*GitHub* : [205](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L205-L205)

```457:             require(
458:                 account.code.length != 0, // <= FOUND
459:                 "ERC20Gauges: not a smart contract"
460:             );
```

*GitHub* : [457](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L457-L458)

```339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero"); // <= FOUND
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L339-L339)

```123:         require(_startTime != 0, "AuctionHouse: invalid auction"); // <= FOUND
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L123-L123)

```172:         require(creditAsked != 0, "AuctionHouse: cannot bid 0"); // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L172-L172)

```247: 
248:         
249:         if (loans[loanId].closeTime != 0) return false; // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L247-L249)

```344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0"); // <= FOUND
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L344-L344)

```345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0"); // <= FOUND
```

*GitHub* : [345](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L345-L345)

```392:             
393:             
394:             
395:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached"); // <= FOUND
```

*GitHub* : [392](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L392-L395)

```453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0"); // <= FOUND
```

*GitHub* : [453](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L453-L453)

```458: 
459:         
460:         require(loan.borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [458](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L458-L460)

```499:         require(borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [499](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L499-L499)

```458:         require(loan.borrowTime != 0, "LendingTerm: loan not found"); // <= FOUND
```

*GitHub* : [458](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L458-L458)

```96: 
97:         require(newBuffer != 0, "RateLimited: no rate limit buffer"); // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L96-L97)

```143: 
144:         require(
145:             params.openingFee <= 0.1e18,  // <= FOUND
146:             "LendingTermOnboarding: invalid openingFee"
147:         );
```

*GitHub* : [143](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L143-L145)
### [GAS-53]<a name="gas-53"></a> Trade-offs Between Modifiers and Internal Functions
In Solidity, both modifiers and internal functions can be used to modularize and reuse code, but they have different trade-offs.

Modifiers are primarily used to augment the behavior of functions, often for checks or validations. They can access parameters of the function they modify and are integrated into the function’s code at compile time. This makes them syntactically cleaner for repetitive precondition checks. However, modifiers can sometimes lead to less readable code, especially when the logic is complex or when multiple modifiers are used on a single function.

Internal functions, on the other hand, offer more flexibility. They can contain complex logic, return values, and be called from other functions. This makes them more suitable for reusable chunks of business logic. Since internal functions are separate entities, they can be more readable and easier to test in isolation compared to modifiers.

Using internal functions can result in slightly more gas consumption, as it involves an internal function call. However, this cost is usually minimal and can be a worthwhile trade-off for increased code clarity and maintainability.

In summary, while modifiers offer a concise way to include checks and simple logic across multiple functions, internal functions provide more flexibility and are better suited for complex and reusable code. The choice between the two should be based on the specific use case, considering factors like code complexity, readability, and gas efficiency.

*There are 57 instance(s) of this issue:*

```49:     function _setCore(address newCore) internal  // <= FOUND
```

*GitHub* : [49](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L49-L49)

```68:     function _setQuorum(uint256 newQuorum) internal  // <= FOUND
```

*GitHub* : [68](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L68-L68)

```123:     function _cancel( // <= FOUND
124:         address[] memory targets, // <= FOUND
125:         uint256[] memory values, // <= FOUND
126:         bytes[] memory calldatas, // <= FOUND
127:         bytes32 descriptionHash // <= FOUND
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256)  // <= FOUND
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L128)

```132:     function _execute( // <= FOUND
133:         uint256 proposalId, // <= FOUND
134:         address[] memory targets, // <= FOUND
135:         uint256[] memory values, // <= FOUND
136:         bytes[] memory calldatas, // <= FOUND
137:         bytes32 descriptionHash // <= FOUND
138:     ) internal override(Governor, GovernorTimelockControl)  // <= FOUND
```

*GitHub* : [132](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L132-L138)

```142:     function _executor() // <= FOUND
143:         internal // <= FOUND
144:         view // <= FOUND
145:         override(Governor, GovernorTimelockControl) // <= FOUND
146:         returns (address) // <= FOUND
147:      // <= FOUND
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L142-L147)

```38:     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override  // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L38-L38)

```41:     function _grantRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```44:     function _revokeRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [44](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L44-L44)

```71:     function _setQuorum(uint256 newQuorum) internal virtual  // <= FOUND
```

*GitHub* : [71](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L71-L71)

```172:     function _quorumReached( // <= FOUND
173:         uint256 proposalId // <= FOUND
174:     ) internal view virtual override returns (bool)  // <= FOUND
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L174)

```186:     function _voteSucceeded( // <= FOUND
187:         uint256  // <= FOUND
188:     ) internal pure virtual override returns (bool)  // <= FOUND
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L186-L188)

```195:     function _countVote( // <= FOUND
196:         uint256 proposalId, // <= FOUND
197:         address account, // <= FOUND
198:         uint8 support, // <= FOUND
199:         uint256 weight, // <= FOUND
200:         bytes memory  // <= FOUND
201:     ) internal virtual override  // <= FOUND
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L195-L201)

```367:     function _getVetoCalls( // <= FOUND
368:         bytes32 timelockId // <= FOUND
369:     ) // <= FOUND
370:         internal // <= FOUND
371:         view // <= FOUND
372:         returns ( // <= FOUND
373:             address[] memory targets, // <= FOUND
374:             uint256[] memory values, // <= FOUND
375:             bytes[] memory calldatas, // <= FOUND
376:             string memory description // <= FOUND
377:         ) // <= FOUND
378:      // <= FOUND
```

*GitHub* : [367](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L367-L378)

```230:     function _incrementGaugeWeight( // <= FOUND
231:         address user, // <= FOUND
232:         address gauge, // <= FOUND
233:         uint256 weight // <= FOUND
234:     ) internal virtual  // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L230-L234)

```249:     function _incrementUserAndGlobalWeights( // <= FOUND
250:         address user, // <= FOUND
251:         uint256 weight // <= FOUND
252:     ) internal returns (uint256 newUserWeight)  // <= FOUND
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L249-L252)

```314:     function _decrementGaugeWeight( // <= FOUND
315:         address user, // <= FOUND
316:         address gauge, // <= FOUND
317:         uint256 weight // <= FOUND
318:     ) internal virtual  // <= FOUND
```

*GitHub* : [314](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L314-L318)

```395:     function _addGauge( // <= FOUND
396:         uint256 _type, // <= FOUND
397:         address gauge // <= FOUND
398:     ) internal returns (uint256 weight)  // <= FOUND
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L398)

```425:     function _removeGauge(address gauge) internal  // <= FOUND
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L425-L425)

```444:     function _setMaxGauges(uint256 newMax) internal  // <= FOUND
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L444-L444)

```452:     function _setCanExceedMaxGauges( // <= FOUND
453:         address account, // <= FOUND
454:         bool canExceedMax // <= FOUND
455:     ) internal  // <= FOUND
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L455)

```403:     function _burn(address from, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [403](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L403-L403)

```500:     function _decrementWeightUntilFree(address user, uint256 weight) internal  // <= FOUND
```

*GitHub* : [500](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L500-L500)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256)  // <= FOUND
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```147:     function _setMaxDelegates(uint256 newMax) internal  // <= FOUND
```

*GitHub* : [147](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L147-L147)

```155:     function _setContractExceedMaxDelegates( // <= FOUND
156:         address account, // <= FOUND
157:         bool canExceedMax // <= FOUND
158:     ) internal  // <= FOUND
```

*GitHub* : [155](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L155-L158)

```290:     function _delegate( // <= FOUND
291:         address delegator, // <= FOUND
292:         address newDelegatee // <= FOUND
293:     ) internal virtual  // <= FOUND
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L290-L293)

```317:     function _incrementDelegation( // <= FOUND
318:         address delegator, // <= FOUND
319:         address delegatee, // <= FOUND
320:         uint256 amount // <= FOUND
321:     ) internal virtual  // <= FOUND
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L317-L321)

```344:     function _undelegate( // <= FOUND
345:         address delegator, // <= FOUND
346:         address delegatee, // <= FOUND
347:         uint256 amount // <= FOUND
348:     ) internal virtual  // <= FOUND
```

*GitHub* : [344](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L344-L348)

```427:     function _decrementVotesUntilFree(address user, uint256 votes) internal  // <= FOUND
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L427-L427)

```131:     function interpolatedValue( // <= FOUND
132:         InterpolatedValue memory val // <= FOUND
133:     ) internal view returns (uint256)  // <= FOUND
```

*GitHub* : [131](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L131-L133)

```168:     function updateTotalRebasingShares( // <= FOUND
169:         uint256 currentRebasingSharePrice, // <= FOUND
170:         int256 sharesDelta // <= FOUND
171:     ) internal  // <= FOUND
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L171)

```228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal  // <= FOUND
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L228-L228)

```242:     function rebasingSharePrice() internal view returns (uint256)  // <= FOUND
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L242-L242)

```247:     function unmintedRebaseRewards() internal view returns (uint256)  // <= FOUND
```

*GitHub* : [247](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L247-L247)

```252:     function _balance2shares( // <= FOUND
253:         uint256 balance, // <= FOUND
254:         uint256 sharePrice // <= FOUND
255:     ) internal pure returns (uint256)  // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L252-L255)

```260:     function _shares2balance( // <= FOUND
261:         uint256 shares, // <= FOUND
262:         uint256 sharePrice, // <= FOUND
263:         uint256 deltaBalance, // <= FOUND
264:         uint256 minBalance // <= FOUND
265:     ) internal pure returns (uint256)  // <= FOUND
```

*GitHub* : [260](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L260-L265)

```289:     function _enterRebase(address account) internal  // <= FOUND
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L289)

```311:     function _exitRebase(address account) internal  // <= FOUND
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L311)

```461:     function _burn(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L461)

```509:     function _mint(address account, uint256 amount) internal virtual override  // <= FOUND
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L509)

```83:     function _mint( // <= FOUND
84:         address account, // <= FOUND
85:         uint256 amount // <= FOUND
86:     ) internal override(ERC20, ERC20RebaseDistributor)  // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L83-L86)

```90:     function _burn( // <= FOUND
91:         address account, // <= FOUND
92:         uint256 amount // <= FOUND
93:     ) internal override(ERC20, ERC20MultiVotes, ERC20RebaseDistributor)  // <= FOUND
```

*GitHub* : [90](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L90-L93)

```182:     function _beforeTokenTransfer( // <= FOUND
183:         address from, // <= FOUND
184:         address to, // <= FOUND
185:         uint256  // <= FOUND
186:     ) internal view override  // <= FOUND
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L186)

```207:     function _decrementGaugeWeight( // <= FOUND
208:         address user, // <= FOUND
209:         address gauge, // <= FOUND
210:         uint256 weight // <= FOUND
211:     ) internal override  // <= FOUND
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L207-L211)

```242:     function _incrementGaugeWeight( // <= FOUND
243:         address user, // <= FOUND
244:         address gauge, // <= FOUND
245:         uint256 weight // <= FOUND
246:     ) internal override  // <= FOUND
```

*GitHub* : [242](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L242-L246)

```279:     function _burn( // <= FOUND
280:         address from, // <= FOUND
281:         uint256 amount // <= FOUND
282:     ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes)  // <= FOUND
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L279-L282)

```339:     function _borrow( // <= FOUND
340:         address borrower, // <= FOUND
341:         uint256 borrowAmount, // <= FOUND
342:         uint256 collateralAmount // <= FOUND
343:     ) internal returns (bytes32 loanId)  // <= FOUND
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L343)

```448:     function _addCollateral( // <= FOUND
449:         address borrower, // <= FOUND
450:         bytes32 loanId, // <= FOUND
451:         uint256 collateralToAdd // <= FOUND
452:     ) internal  // <= FOUND
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L452)

```490:     function _partialRepay( // <= FOUND
491:         address repayer, // <= FOUND
492:         bytes32 loanId, // <= FOUND
493:         uint256 debtToRepay // <= FOUND
494:     ) internal  // <= FOUND
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L494)

```567:     function _repay(address repayer, bytes32 loanId) internal  // <= FOUND
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```634:     function _call( // <= FOUND
635:         address caller, // <= FOUND
636:         bytes32 loanId, // <= FOUND
637:         address _auctionHouse // <= FOUND
638:     ) internal  // <= FOUND
```

*GitHub* : [634](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L634-L638)

```93:     function _depleteBuffer(uint256 amount) internal  // <= FOUND
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L93-L93)

```111:     function _replenishBuffer(uint256 amount) internal  // <= FOUND
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L111-L111)

```138:     function _setRateLimitPerSecond(uint128 newRateLimitPerSecond) internal  // <= FOUND
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L138-L138)

```149:     function _setBufferCap(uint128 newBufferCap) internal  // <= FOUND
```

*GitHub* : [149](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L149-L149)

```158:     function _updateBufferStored(uint128 newBufferCap) internal  // <= FOUND
```

*GitHub* : [158](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L158-L158)

```24:     modifier onlyCoreRole(bytes32 role)  // <= FOUND
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L24-L24)
### [GAS-54]<a name="gas-54"></a> Using nested if to save gas
Using nested `if` statements instead of logical AND (`&&`) operators can potentially save gas in Solidity contracts. When a series of conditions are connected with `&&`, all conditions must be evaluated even if the first one fails. In contrast, nested `if` statements allow for short-circuiting; if the first condition fails, the rest are skipped, saving gas. This approach is more gas-efficient, especially when dealing with complex or gas-intensive conditions. However, it's crucial to balance gas savings with code readability and maintainability, ensuring that the code remains clear and easy to understand.

*There are 4 instance(s) of this issue:*

```191:         if (
192:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused() // <= FOUND
193:         ) {
194:             SimplePSM(psm).setRedemptionsPaused(false);
195:         }
```

*GitHub* : [192](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L192-L192)

```236:         if (added && _userGauges[user].length() > maxGauges) { // <= FOUND
237:             require(canExceedMaxGauges[user], "ERC20Gauges: exceed max gauges");
238:         }
```

*GitHub* : [236](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L236-L236)

```374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) { // <= FOUND
375:             ckpts[pos - 1].votes = newWeight.safeCastTo224();
376:         }
```

*GitHub* : [374](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L374-L374)

```298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) { // <= FOUND
299:             
300:             
301:             
302:             return
303:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
304:         }
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L298-L298)
### [GAS-55]<a name="gas-55"></a> Optimize Deployment Size by Fine-tuning IPFS Hash
Optimizing the deployment size of a smart contract is vital to minimize gas costs, and one way to achieve this is by fine-tuning the IPFS hash appended by the Solidity compiler as metadata. This metadata, consisting of 53 bytes, increases the gas required for contract deployment by approximately 10,600 gas due to bytecode costs, and additionally, up to 848 gas due to calldata costs, depending on the proportion of zero and non-zero bytes. Utilize the --no-cbor-metadata compiler flag to prevent the compiler from appending metadata. However, this approach has a drawback as it can complicate the contract verification process on block explorers like Etherscan, potentially reducing transparency.

*There are 14 instance(s) of this issue:*

```10: contract Core is AccessControlEnumerable  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L10-L10)

```16: contract GuildGovernor is // <= FOUND
17:     CoreRef,
18:     Governor,
19:     GovernorVotes,
20:     GovernorTimelockControl,
21:     GovernorSettings,
22:     GovernorCountingSimple
23: 
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L16-L16)

```14: contract GuildTimelockController is TimelockController, CoreRef  // <= FOUND
```

*GitHub* : [14](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L14-L14)

```16: contract LendingTermOffboarding is CoreRef  // <= FOUND
```

*GitHub* : [16](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L16-L16)

```23: contract LendingTermOnboarding is GuildGovernor  // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L23-L23)

```30: contract ProfitManager is CoreRef  // <= FOUND
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L30-L30)

```25: contract GuildVetoGovernor is CoreRef, Governor, GovernorVotes  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L25-L25)

```18: contract CreditToken is // <= FOUND
19:     CoreRef,
20:     ERC20Burnable,
21:     ERC20MultiVotes,
22:     ERC20RebaseDistributor
23: 
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L18-L18)

```37: contract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes  // <= FOUND
```

*GitHub* : [37](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L37-L37)

```10: contract AuctionHouse is CoreRef  // <= FOUND
```

*GitHub* : [10](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L10-L10)

```20: contract LendingTerm is CoreRef  // <= FOUND
```

*GitHub* : [20](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L20-L20)

```25: contract SimplePSM is CoreRef  // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L25-L25)

```24: contract SurplusGuildMinter is CoreRef  // <= FOUND
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L24-L24)

```17: contract RateLimitedMinter is RateLimitedV2  // <= FOUND
```

*GitHub* : [17](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L17-L17)
### [GAS-56]<a name="gas-56"></a> Avoid Unnecessary Public Variables
Public state variables in Solidity automatically generate getter functions, increasing contract size and potentially leading to higher deployment and interaction costs. To optimize gas usage and contract efficiency, minimize the use of public variables unless external access is necessary. Instead, use internal or private visibility combined with explicit getter functions when required. This practice not only reduces contract size but also provides better control over data access and manipulation, enhancing security and readability. Prioritize lean, efficient contracts to ensure cost-effectiveness and better performance on the blockchain.

*There are 47 instance(s) of this issue:*

```36: uint256 public constant POLL_DURATION_BLOCKS = 46523;  // <= FOUND
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L36-L36)

```39: uint256 public quorum; // <= FOUND
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L39-L39)

```32: address public immutable guildToken; // <= FOUND
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L32-L32)

```45: address public immutable psm; // <= FOUND
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L45-L45)

```64: uint256 public nOffboardingsInProgress; // <= FOUND
```

*GitHub* : [64](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L64-L64)

```25: uint256 public constant MIN_DELAY_BETWEEN_PROPOSALS = 7 days; // <= FOUND
```

*GitHub* : [25](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L25-L25)

```34: uint256 public immutable gaugeType; // <= FOUND
```

*GitHub* : [34](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L34-L34)

```56: address public immutable profitManager; // <= FOUND
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L56-L56)

```43: address public immutable auctionHouse; // <= FOUND
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L43-L43)

```45: address public immutable creditMinter; // <= FOUND
```

*GitHub* : [45](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L45-L45)

```47: address public immutable creditToken; // <= FOUND
```

*GitHub* : [47](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L47-L47)

```32: address public guild; // <= FOUND
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L32-L32)

```35: address public credit; // <= FOUND
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L35-L35)

```38: address public psm; // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L38-L38)

```70: uint256 public surplusBuffer; // <= FOUND
```

*GitHub* : [70](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L70-L70)

```87: uint256 public creditMultiplier = 1e18; // <= FOUND
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L87-L87)

```104: uint256 public gaugeWeightTolerance = 1.2e18;  // <= FOUND
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L104-L104)

```86: address public timelock; // <= FOUND
```

*GitHub* : [86](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L86-L86)

```41: address public profitManager; // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L41-L41)

```169: bool public transferable;  // <= FOUND
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L169-L169)

```31: uint256 public immutable midPoint; // <= FOUND
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L31-L31)

```38: uint256 public immutable auctionDuration; // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L38-L38)

```54: uint256 public nAuctionsInProgress; // <= FOUND
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L54-L54)

```29: uint256 public constant YEAR = 31557600; // <= FOUND
```

*GitHub* : [29](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L29-L29)

```95: uint256 public issuance; // <= FOUND
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L95-L95)

```59: address public immutable credit; // <= FOUND
```

*GitHub* : [59](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L59-L59)

```35: address public immutable pegToken; // <= FOUND
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L35-L35)

```39: uint256 public pegTokenBalance; // <= FOUND
```

*GitHub* : [39](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L39-L39)

```43: uint256 public immutable decimalCorrection; // <= FOUND
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L43-L43)

```46: bool public redemptionsPaused; // <= FOUND
```

*GitHub* : [46](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L46-L46)

```26: uint256 public constant MIN_STAKE = 1e18; // <= FOUND
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L26-L26)

```62: address public immutable guild; // <= FOUND
```

*GitHub* : [62](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L62-L62)

```65: address public immutable rlgm; // <= FOUND
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L65-L65)

```70: uint256 public mintRatio; // <= FOUND
```

*GitHub* : [70](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L70-L70)

```75: uint256 public rewardRatio; // <= FOUND
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L75-L75)

```19: address public immutable token; // <= FOUND
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L19-L19)

```22: bytes32 public immutable role; // <= FOUND
```

*GitHub* : [22](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L22-L22)

```77: uint256 public totalWeight; // <= FOUND
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L77-L77)

```390: uint256 public maxGauges; // <= FOUND
```

*GitHub* : [390](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L390-L390)

```141: uint256 public maxDelegates; // <= FOUND
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L141-L141)

```467: bytes32 public constant DELEGATION_TYPEHASH = // <= FOUND
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L467-L467)

```97: uint256 public constant DISTRIBUTION_PERIOD = 30 days; // <= FOUND
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L97-L97)

```18: uint256 public immutable MAX_RATE_LIMIT_PER_SECOND; // <= FOUND
```

*GitHub* : [18](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L18-L18)

```23: uint128 public rateLimitPerSecond; // <= FOUND
```

*GitHub* : [23](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L23-L23)

```26: uint128 public bufferCap; // <= FOUND
```

*GitHub* : [26](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L26-L26)

```31: uint32 public lastBufferUsedTime; // <= FOUND
```

*GitHub* : [31](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L31-L31)

```34: uint224 public bufferStored; // <= FOUND
```

*GitHub* : [34](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L34-L34)
### [GAS-57]<a name="gas-57"></a> Optimize Storage with Byte Truncation for Time Related State Variables
Storage optimization in Solidity contracts is vital for reducing gas costs, especially when storing time-related state variables. Using `uint32` for storing time values like timestamps is often sufficient, given it can represent dates up to the year 2106. By truncating larger default integer types to `uint32`, you significantly save on storage space and consequently on gas costs for deployment and state modifications. However, ensure that the truncation does not lead to overflow issues and that the variable's size is adequate for the application's expected lifespan and precision requirements. Adopting this optimization practice contributes to more efficient and cost-effective smart contract development.

*There are 3 instance(s) of this issue:*

```38: uint256 public immutable auctionDuration; // <= FOUND
```

*GitHub* : [38](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L38-L38)

```36: uint256 public constant POLL_DURATION_BLOCKS = 46523;  // <= FOUND
```

*GitHub* : [36](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L36-L36)

```468: keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)"); // <= FOUND
```

*GitHub* : [468](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L468-L468)
### [GAS-58]<a name="gas-58"></a> Stack variable cost less than state variables while used in emiting event
When emitting events in Solidity, using stack variables (local variables within a function) instead of state variables can lead to significant gas savings. Stack variables reside in memory only for the duration of the function execution and are less costly to access compared to state variables, which are stored on the blockchain. When an event is emitted, accessing these stack variables requires less gas than fetching data from state variables, which involves reading from the contract's storage - a more expensive operation. Thus, for efficiency, prefer using local variables within functions for event emission, especially in functions that are called frequently.

*There are 6 instance(s) of this issue:*

```81:         emit QuorumUpdated(quorum, _quorum); // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L81-L81)

```166:         emit TermCreated(block.timestamp, implementation, term, params); // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L166-L166)

```106: 
107:         emit BufferUsed(amount, bufferStored); // <= FOUND
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L106-L107)

```134: 
135:         emit BufferReplenished(amount, bufferStored); // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L134-L135)

```69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L69-L69)

```100:         emit TimelockChange(timelock, newTimelock); // <= FOUND
```

*GitHub* : [100](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L100-L100)
### [GAS-59]<a name="gas-59"></a> Use s.x = s.x + y instead of s.x += y for memory structs (same for -= etc)
In Solidity, optimizing gas usage is crucial, particularly for frequently executed operations. For memory structs, using explicit assignment (e.g., `s.x = s.x + y`) instead of shorthand operations (e.g., `s.x += y`) can result in a minor gas saving, around 100 gas. This difference arises from the way the Solidity compiler optimizes bytecode. While such savings might seem small, they can add up in contracts with high transaction volume. This optimization applies to other compound assignment operators like `-=` and `*=` as well. It's a subtle efficiency gain that developers can leverage, especially in complex contracts where every gas unit counts.

*There are 4 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer; // <= FOUND
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer; // <= FOUND
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9; // <= FOUND
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9; // <= FOUND
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9; // <= FOUND
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient, // <= FOUND
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L372)

```461:     function _burn(address account, uint256 amount) internal virtual override { // <= FOUND
462:         
463:         
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) { // <= FOUND
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares, // <= FOUND
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount; // <= FOUND
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         
486:         ERC20._burn(account, amount);
487: 
488:         
489:         if (_rebasingState.isRebasing == 1) { // <= FOUND
490:             uint256 balanceAfter = balanceBefore - amount;
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter; // <= FOUND
496:             rebasingState[account] = RebasingState({
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L495)

```553:     function transfer(
554:         address to,
555:         uint256 amount
556:     ) public virtual override returns (bool) {
557:         
558:         
559:         RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
560:         RebasingState memory rebasingStateTo = rebasingState[to];
561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
562:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 || // <= FOUND
563:             rebasingStateTo.isRebasing == 1) // <= FOUND
564:             ? rebasingSharePrice()
565:             : 0; 
566:         if (rebasingStateFrom.isRebasing == 1) { // <= FOUND
567:             uint256 shares = uint256(rebasingStateFrom.nShares); // <= FOUND
568:             uint256 rebasedBalance = _shares2balance(
569:                 shares,
570:                 _rebasingSharePrice,
571:                 0,
572:                 fromBalanceBefore
573:             );
574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
575:             if (mintAmount != 0) {
576:                 ERC20._mint(msg.sender, mintAmount);
577:                 fromBalanceBefore += mintAmount; // <= FOUND
578:                 decreaseUnmintedRebaseRewards(mintAmount);
579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount);
580:             }
581:         }
582: 
583:         
584:         bool success = ERC20.transfer(to, amount);
585: 
586:         
587:         int256 sharesDelta;
588:         if (rebasingStateFrom.isRebasing == 1) { // <= FOUND
589:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
590:             uint256 fromSharesAfter = _balance2shares(
591:                 fromBalanceAfter,
592:                 _rebasingSharePrice
593:             );
594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter; // <= FOUND
595:             sharesDelta -= int256(sharesSpent); // <= FOUND
596:             rebasingState[msg.sender] = RebasingState({
597:                 isRebasing: 1,
598:                 nShares: uint248(fromSharesAfter)
599:             });
600:         }
601: 
602:         
603:         if (rebasingStateTo.isRebasing == 1) { // <= FOUND
604:             
605:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
606:             uint256 toBalanceAfter = _shares2balance(
607:                 rebasingStateTo.nShares, // <= FOUND
608:                 _rebasingSharePrice,
609:                 amount,
610:                 rawToBalanceAfter
611:             );
612: 
613:             
614:             uint256 toSharesAfter = _balance2shares(
615:                 toBalanceAfter,
616:                 _rebasingSharePrice
617:             );
618:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares; // <= FOUND
619:             sharesDelta += int256(sharesReceived); // <= FOUND
620:             rebasingState[to] = RebasingState({
621:                 isRebasing: 1,
622:                 nShares: uint248(toSharesAfter)
623:             });
624: 
625:             
626:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
627:             if (mintAmount != 0) {
628:                 ERC20._mint(to, mintAmount);
629:                 decreaseUnmintedRebaseRewards(mintAmount);
630:                 emit RebaseReward(to, block.timestamp, mintAmount);
631:             }
632:         }
633: 
634:         
635:         if (
636:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1 // <= FOUND
637:         ) {
638:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
639:         }
640: 
641:         return success;
642:     }
```

*GitHub* : [553](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L553-L636)

```646:     function transferFrom(
647:         address from,
648:         address to,
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         
652:         
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 || // <= FOUND
657:             rebasingStateTo.isRebasing == 1) // <= FOUND
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) { // <= FOUND
661:             uint256 shares = uint256(rebasingStateFrom.nShares); // <= FOUND
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount; // <= FOUND
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         
678:         bool success = ERC20.transferFrom(from, to, amount);
679: 
680:         
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) { // <= FOUND
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter; // <= FOUND
689:             sharesDelta -= int256(sharesSpent); // <= FOUND
690:             rebasingState[from] = RebasingState({
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
696:         
697:         if (rebasingStateTo.isRebasing == 1) { // <= FOUND
698:             
699:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
700:             uint256 toBalanceAfter = _shares2balance(
701:                 rebasingStateTo.nShares, // <= FOUND
702:                 _rebasingSharePrice,
703:                 amount,
704:                 rawToBalanceAfter
705:             );
706: 
707:             
708:             uint256 toSharesAfter = _balance2shares(
709:                 toBalanceAfter,
710:                 _rebasingSharePrice
711:             );
712:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares; // <= FOUND
713:             sharesDelta += int256(sharesReceived); // <= FOUND
714:             rebasingState[to] = RebasingState({
715:                 isRebasing: 1,
716:                 nShares: uint248(toSharesAfter)
717:             });
718: 
719:             
720:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
721:             if (mintAmount != 0) {
722:                 ERC20._mint(to, mintAmount);
723:                 decreaseUnmintedRebaseRewards(mintAmount);
724:                 emit RebaseReward(to, block.timestamp, mintAmount);
725:             }
726:         }
727: 
728:         
729:         if (
730:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1 // <= FOUND
731:         ) {
732:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
733:         }
734: 
735:         return success;
736:     }
```

*GitHub* : [646](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L646-L730)
### [GAS-60]<a name="gas-60"></a> Time state variables can be truncated to uint32
Truncating time-related state variables to `uint32` can be a practical optimization in Solidity contracts. Since `uint32` can represent dates far into the future (over 100 years from now), it's often sufficient for time tracking purposes. This approach reduces the storage space required, thereby saving gas costs associated with larger data types like `uint256`. This form of optimization is especially beneficial in scenarios where space efficiency is a priority and the range of `uint32` meets the application's temporal needs.

*There are 1 instance(s) of this issue:*

```468: keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)"); // <= FOUND
```

*GitHub* : [468](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L468-L468)
### [GAS-61]<a name="gas-61"></a> Constants are cheaper than Enums
Using constants instead of enums in Solidity can lead to gas savings. Constants, particularly for primitive data types like `uint` or `bool`, are directly substituted by the Solidity compiler at compile time, effectively hardcoding their values into the bytecode. This means that accessing a constant does not incur any runtime gas costs, as no storage or memory access is needed. In contrast, enums, while useful for readability and ensuring valid value ranges, are stored in contract storage or memory, incurring gas costs for reads and writes. For scenarios where an enum's value range aligns with a simple constant (like true/false or small integer ranges), substituting with constants can be a more gas-efficient choice.

*There are 2 instance(s) of this issue:*

```111:     enum VoteType { // <= FOUND
112:         Against,
113:         For,
114:         Abstain
115:     }
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L111-L111)

```35:     enum LoanCloseType { // <= FOUND
36:         Repay,
37:         Call,
38:         Forgive
39:     }
```

*GitHub* : [35](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L35-L35)
### [GAS-62]<a name="gas-62"></a> ++X costs slightly less gas than X++ (same with --)
Move the ++/-- action to the left of the variable

*There are 6 instance(s) of this issue:*

```96:         for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```444:             i++ // <= FOUND
445:         ) {
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L444-L444)

```685:         for (uint256 i = 0; i < loanIds.length; i++) { // <= FOUND
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)

```162: 
163:         
164:         if (
165:             nOffboardingsInProgress++ == 0 && // <= FOUND
166:             !SimplePSM(psm).redemptionsPaused()
167:         ) {
```

*GitHub* : [165](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L165-L165)

```103:         nAuctionsInProgress++; // <= FOUND
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L103-L103)

```176:         nAuctionsInProgress--; // <= FOUND
```

*GitHub* : [176](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L176-L176)
### [GAS-63]<a name="gas-63"></a> Solidity versions 0.8.19 and above are more gas efficient
Solidity version 0.8.19 introduced a array of gas optimizations which make contracts which use it more efficient. Provided compatability it may be beneficial to upgrade to this version

*There are 1 instance(s) of this issue:*

```4: pragma solidity 0.8.13;
```

*GitHub* : [4](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L4-L4)
### [GAS-64]<a name="gas-64"></a> Variable declared within iteration
Please elaborate and generalise the following with detail and  feel free to use your own knowledge and lmit ur words to 100 words please:

*There are 4 instance(s) of this issue:*

```96:        for (uint256 i = 0; i < calls.length; i++) { // <= FOUND
97:             address payable target = payable(calls[i].target);
98:             uint256 value = calls[i].value; // <= FOUND
99:             bytes calldata callData = calls[i].callData; // <= FOUND
100: 
101:             (bool success, bytes memory returned) = target.call{value: value}(
102:                 callData
103:             );
104:             require(success, "CoreRef: underlying call reverted");
105:             returnData[i] = returned;
106:         }
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L99)

```467:        for (uint256 i = 0; i < gauges.length; ) { // <= FOUND
468:             address gauge = gauges[i];
469:             uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge]; // <= FOUND
470:             uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge]; // <= FOUND
471: 
472:             if (_gaugeProfitIndex == 0) {
473:                 _gaugeProfitIndex = 1e18;
474:             }
475:             if (_userGaugeProfitIndex == 0) {
476:                 _userGaugeProfitIndex = 1e18;
477:             }
478:             uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex; // <= FOUND
479:             if (deltaIndex != 0) {
480:                 uint256 _userGaugeWeight = uint256(
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge)
482:                 );
483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18;
484:                 totalCreditEarned += creditEarned[i];
485:             }
486: 
487:             unchecked {
488:                 ++i;
489:             }
490:         }
```

*GitHub* : [467](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L467-L478)

```280:        for (uint256 i = 0; i < size; ) { // <= FOUND
281:             address gauge = gaugeList[i];
282:             uint256 weight = weights[i]; // <= FOUND
283:             weightsSum += weight;
284: 
285:             require(isGauge(gauge), "ERC20Gauges: invalid gauge");
286: 
287:             _incrementGaugeWeight(msg.sender, gauge, weight);
288:             unchecked {
289:                 ++i;
290:             }
291:         }
```

*GitHub* : [280](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L280-L282)

```352:        for (uint256 i = 0; i < size; ) { // <= FOUND
353:             address gauge = gaugeList[i];
354:             uint256 weight = weights[i]; // <= FOUND
355: 
356:             _decrementGaugeWeight(msg.sender, gauge, weight);
357:             if (!_deprecatedGauges.contains(gauge)) {
358:                 totalTypeWeight[gaugeType[gauge]] -= weight;
359:                 weightsSum += weight;
360:             }
361:             unchecked {
362:                 ++i;
363:             }
364:         }
```

*GitHub* : [352](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L352-L354)
### [GAS-65]<a name="gas-65"></a> The use of a logical AND in place of double if is slightly less gas efficient in instances where there isn't a corresponding else statement for the given if statement
Using a double if statement instead of logical AND (&&) can provide similar short-circuiting behavior whereas double if is slightly more efficient.

*There are 17 instance(s) of this issue:*

```191: 
192:         
193:         if (
194:             --nOffboardingsInProgress == 0 && SimplePSM(psm).redemptionsPaused() // <= FOUND
195:         ) {
```

*GitHub* : [194](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L194-L194)

```117:         require(
118:             success && returned.length == 32, // <= FOUND
119:             "LendingTermOnboarding: invalid collateralToken"
120:         );
```

*GitHub* : [118](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L118-L118)

```161:         assert(
162:             credit == address(0) && guild == address(0) && psm == address(0) // <= FOUND
163:         );
```

*GitHub* : [162](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L162-L162)

```104:         return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge); // <= FOUND
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L104-L104)

```134:         for (uint256 i; i < allGauges.length && j < _liveGauges.length; ) { // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L134-L134)

```236:         if (added && _userGauges[user].length() > maxGauges) { // <= FOUND
```

*GitHub* : [236](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L236-L236)

```402:         
403:         require(
404:             gauge != address(0) && (newAdd || previouslyDeprecated), // <= FOUND
405:             "ERC20Gauges: invalid gauge"
406:         );
```

*GitHub* : [404](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L404-L404)

```427:         
428:         require(
429:             _gauges.contains(gauge) && _deprecatedGauges.add(gauge), // <= FOUND
430:             "ERC20Gauges: invalid gauge"
431:         );
```

*GitHub* : [429](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L429-L429)

```517:             i < size && (userFreeWeight + userFreed) < weight; // <= FOUND
```

*GitHub* : [517](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L517-L517)

```324:         require(
325:             delegatee != address(0) && free >= amount, // <= FOUND
326:             "ERC20MultiVotes: delegation error"
327:         );
```

*GitHub* : [325](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L325-L325)

```374: 
375:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) { // <= FOUND
```

*GitHub* : [375](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L375-L375)

```443:             i < size && (userFreeVotes + totalFreed) < votes; // <= FOUND
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L443-L443)

```137:         require(
138:             _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss, // <= FOUND
139:             "GuildToken: no loss to apply"
140:         );
```

*GitHub* : [138](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L138-L138)

```298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) { // <= FOUND
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L298-L298)

```519:         require(
520:             principalRepaid != 0 && interestRepaid != 0, // <= FOUND
521:             "LendingTerm: repay too small"
522:         );
```

*GitHub* : [520](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L520-L520)

```734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0, // <= FOUND
736:             "LendingTerm: loan not called"
737:         );
```

*GitHub* : [735](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L735-L735)

```169: 
170:         
171:         require(
172:             amount != 0 && userStake.credit >= amount, // <= FOUND
173:             "SurplusGuildMinter: invalid amount"
174:         );
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L172-L172)
### [GAS-66]<a name="gas-66"></a> Calling .length in a for loop wastes gas
Rather than calling .length for an array in a for loop declaration, it is far more gas efficient to cache this length before and use that instead. This will prevent the array length from being called every loop iteration

*There are 4 instance(s) of this issue:*

```96: for (uint256 i = 0; i < calls.length; i++)  // <= FOUND
```

*GitHub* : [96](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L96-L96)

```443: for (uint256 i = 0; i < gauges.length; )  // <= FOUND
```

*GitHub* : [443](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L443-L443)

```134: for (uint256 i; i < allGauges.length && j < _liveGauges.length; )  // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L134-L134)

```685: for (uint256 i = 0; i < loanIds.length; i++)  // <= FOUND
```

*GitHub* : [685](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L685-L685)
### [GAS-67]<a name="gas-67"></a> Internal functions only used once can be inlined so save gas
If a internal function is only used once it doesn't make sense to modularise it unless the function which does call the function would be overly long and complex otherwise

*There are 14 instance(s) of this issue:*

```123:     function _cancel( // <= FOUND
124:         address[] memory targets,
125:         uint256[] memory values,
126:         bytes[] memory calldatas,
127:         bytes32 descriptionHash
128:     ) internal override(Governor, GovernorTimelockControl) returns (uint256) 
```

*GitHub* : [123](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L123-L123)

```41:     function _grantRole(bytes32 role, address account) internal override  // <= FOUND
```

*GitHub* : [41](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L41-L41)

```172:     function _quorumReached( // <= FOUND
173:         uint256 proposalId
174:     ) internal view virtual override returns (bool) 
```

*GitHub* : [172](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L172-L172)

```395:     function _addGauge( // <= FOUND
396:         uint256 _type,
397:         address gauge
398:     ) internal returns (uint256 weight) 
```

*GitHub* : [395](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L395-L395)

```425:     function _removeGauge(address gauge) internal  // <= FOUND
```

*GitHub* : [425](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L425-L425)

```444:     function _setMaxGauges(uint256 newMax) internal  // <= FOUND
```

*GitHub* : [444](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L444-L444)

```452:     function _setCanExceedMaxGauges( // <= FOUND
453:         address account,
454:         bool canExceedMax
455:     ) internal 
```

*GitHub* : [452](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L452-L452)

```122:     function average(uint256 a, uint256 b) internal pure returns (uint256)  // <= FOUND
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L122-L122)

```339:     function _borrow( // <= FOUND
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) 
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L339)

```448:     function _addCollateral( // <= FOUND
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal 
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```490:     function _partialRepay( // <= FOUND
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal 
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal  // <= FOUND
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```93:     function _depleteBuffer(uint256 amount) internal  // <= FOUND
```

*GitHub* : [93](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L93-L93)

```111:     function _replenishBuffer(uint256 amount) internal  // <= FOUND
```

*GitHub* : [111](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L111-L111)
### [GAS-68]<a name="gas-68"></a> Constructors can be marked as payable to save deployment gas

*There are 15 instance(s) of this issue:*

```12:     constructor() {
13:         
14:         
15:         _grantRole(CoreRoles.GOVERNOR, msg.sender);
16: 
17:         
18:         _setRoleAdmin(CoreRoles.GOVERNOR, CoreRoles.GOVERNOR);
19:         _setRoleAdmin(CoreRoles.GUARDIAN, CoreRoles.GOVERNOR);
20:         _setRoleAdmin(CoreRoles.CREDIT_MINTER, CoreRoles.GOVERNOR);
21:         _setRoleAdmin(CoreRoles.RATE_LIMITED_CREDIT_MINTER, CoreRoles.GOVERNOR);
22:         _setRoleAdmin(CoreRoles.GUILD_MINTER, CoreRoles.GOVERNOR);
23:         _setRoleAdmin(CoreRoles.RATE_LIMITED_GUILD_MINTER, CoreRoles.GOVERNOR);
24:         _setRoleAdmin(CoreRoles.GAUGE_ADD, CoreRoles.GOVERNOR);
25:         _setRoleAdmin(CoreRoles.GAUGE_REMOVE, CoreRoles.GOVERNOR);
26:         _setRoleAdmin(CoreRoles.GAUGE_PARAMETERS, CoreRoles.GOVERNOR);
27:         _setRoleAdmin(CoreRoles.GAUGE_PNL_NOTIFIER, CoreRoles.GOVERNOR);
28:         _setRoleAdmin(
29:             CoreRoles.GUILD_GOVERNANCE_PARAMETERS,
30:             CoreRoles.GOVERNOR
31:         );
32:         _setRoleAdmin(
33:             CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW,
34:             CoreRoles.GOVERNOR
35:         );
36:         _setRoleAdmin(
37:             CoreRoles.CREDIT_GOVERNANCE_PARAMETERS,
38:             CoreRoles.GOVERNOR
39:         );
40:         _setRoleAdmin(CoreRoles.CREDIT_REBASE_PARAMETERS, CoreRoles.GOVERNOR);
41:         _setRoleAdmin(CoreRoles.TIMELOCK_PROPOSER, CoreRoles.GOVERNOR);
42:         _setRoleAdmin(CoreRoles.TIMELOCK_EXECUTOR, CoreRoles.GOVERNOR);
43:         _setRoleAdmin(CoreRoles.TIMELOCK_CANCELLER, CoreRoles.GOVERNOR);
44:     }
```

*GitHub* : [12](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L12-L12)

```19:     constructor(address coreAddress) {
20:         _core = Core(coreAddress);
21:     }
```

*GitHub* : [19](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L19-L19)

```15:     constructor(
16:         address _core,
17:         uint256 _minDelay
18:     )
19:         CoreRef(_core)
20:         TimelockController(
21:             _minDelay,
22:             new address[](0),
23:             new address[](0),
24:             address(0)
25:         )
26:     {}
```

*GitHub* : [15](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildTimelockController.sol#L15-L15)

```66:     constructor(
67:         address _core,
68:         address _guildToken,
69:         address _psm,
70:         uint256 _quorum
71:     ) CoreRef(_core) {
72:         guildToken = _guildToken;
73:         psm = _psm;
74:         quorum = _quorum;
75:     }
```

*GitHub* : [66](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L66-L66)

```63:     constructor(
64:         LendingTerm.LendingTermReferences memory _lendingTermReferences,
65:         uint256 _gaugeType,
66:         address _core,
67:         address _timelock,
68:         uint256 initialVotingDelay,
69:         uint256 initialVotingPeriod,
70:         uint256 initialProposalThreshold,
71:         uint256 initialQuorum
72:     )
73:         GuildGovernor(
74:             _core,
75:             _timelock,
76:             _lendingTermReferences.guildToken,
77:             initialVotingDelay,
78:             initialVotingPeriod,
79:             initialProposalThreshold,
80:             initialQuorum
81:         )
82:     {
83:         guildToken = _lendingTermReferences.guildToken;
84:         gaugeType = _gaugeType;
85:         profitManager = _lendingTermReferences.profitManager;
86:         auctionHouse = _lendingTermReferences.auctionHouse;
87:         creditMinter = _lendingTermReferences.creditMinter;
88:         creditToken = _lendingTermReferences.creditToken;
89:     }
```

*GitHub* : [63](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L63-L63)

```106:     constructor(address _core) CoreRef(_core) {
107:         emit MinBorrowUpdate(block.timestamp, 100e18);
108:     }
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L106-L106)

```32:     constructor(
33:         address _core,
34:         address initialTimelock,
35:         address _token,
36:         uint256 initialQuorum
37:     )
38:         CoreRef(_core)
39:         Governor("ECG Veto Governor")
40:         GovernorVotes(IVotes(_token))
41:     {
42:         _setQuorum(initialQuorum);
43:         _updateTimelock(initialTimelock);
44:     }
```

*GitHub* : [32](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L32-L32)

```24:     constructor(
25:         address _core,
26:         string memory _name,
27:         string memory _symbol
28:     )
29:         CoreRef(_core)
30:         ERC20(_name, _symbol)
31:         ERC20Permit(_name)
32:     {}
```

*GitHub* : [24](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L24-L24)

```43:     constructor(
44:         address _core,
45:         address _profitManager
46:     )
47:         CoreRef(_core)
48:         ERC20("Ethereum Credit Guild - GUILD", "GUILD")
49:         ERC20Permit("Ethereum Credit Guild - GUILD")
50:     {
51:         profitManager = _profitManager;
52:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L43-L43)

```56:     constructor(
57:         address _core,
58:         uint256 _midPoint,
59:         uint256 _auctionDuration
60:     ) CoreRef(_core) {
61:         require(_midPoint < _auctionDuration, "AuctionHouse: invalid params");
62:         midPoint = _midPoint;
63:         auctionDuration = _auctionDuration;
64:     }
```

*GitHub* : [56](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L56-L56)

```153:     constructor() CoreRef(address(1)) {
154:         
155:         
156:     }
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L153-L153)

```65:     constructor(
66:         address _core,
67:         address _profitManager,
68:         address _credit,
69:         address _pegToken
70:     ) CoreRef(_core) {
71:         profitManager = _profitManager;
72:         credit = _credit;
73:         pegToken = _pegToken;
74: 
75:         uint256 decimals = uint256(ERC20(_pegToken).decimals());
76:         decimalCorrection = 10 ** (18 - decimals);
77:     }
```

*GitHub* : [65](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L65-L65)

```88:     constructor(
89:         address _core,
90:         address _profitManager,
91:         address _credit,
92:         address _guild,
93:         address _rlgm,
94:         uint256 _mintRatio,
95:         uint256 _rewardRatio
96:     ) CoreRef(_core) {
97:         profitManager = _profitManager;
98:         credit = _credit;
99:         guild = _guild;
100:         rlgm = _rlgm;
101:         mintRatio = _mintRatio;
102:         rewardRatio = _rewardRatio;
103:     }
```

*GitHub* : [88](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L88-L88)

```30:     constructor(
31:         address _core,
32:         address _token,
33:         bytes32 _role,
34:         uint256 _maxRateLimitPerSecond,
35:         uint128 _rateLimitPerSecond,
36:         uint128 _bufferCap
37:     )
38:         CoreRef(_core)
39:         RateLimitedV2(_maxRateLimitPerSecond, _rateLimitPerSecond, _bufferCap)
40:     {
41:         token = _token;
42:         role = _role;
43:     }
```

*GitHub* : [30](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L30-L30)

```40:     constructor(
41:         uint256 _maxRateLimitPerSecond,
42:         uint128 _rateLimitPerSecond,
43:         uint128 _bufferCap
44:     ) {
45:         lastBufferUsedTime = block.timestamp.safeCastTo32();
46: 
47:         _setBufferCap(_bufferCap);
48:         bufferStored = _bufferCap;
49: 
50:         require(
51:             _rateLimitPerSecond <= _maxRateLimitPerSecond,
52:             "RateLimited: rateLimitPerSecond too high"
53:         );
54:         _setRateLimitPerSecond(_rateLimitPerSecond);
55: 
56:         MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;
57:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L40-L40)
### [GAS-69]<a name="gas-69"></a> Order struct members to reduce size
Utilizing a struct in Solidity involves laying out its members in storage. Arranging these members from largest to smallest can significantly minimize gas costs by optimizing storage packing. This tactic ensures that larger members align with Solidity's 32-byte storage word boundaries, reducing padding and the number of storage slots required. This efficient use of storage slots translates directly into gas savings, particularly when struct instances are frequently read from or written to storage. Developers should prioritize this struct arrangement in their contracts to optimize for gas efficiency.

*There are 12 instance(s) of this issue:*

```74:     struct Call { // <= FOUND
75:         
76:         address target;
77:         
78:         uint256 value;
79:         
80:         bytes callData;
81:     }
```

*GitHub* : [74](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L74-L74)

```48:     struct ProfitSharingConfig { // <= FOUND
49:         uint32 surplusBufferSplit; 
50:         uint32 guildSplit; 
51:         uint32 otherSplit; 
52:         address otherRecipient; 
53:     }
```

*GitHub* : [48](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L48-L48)

```117:     struct ProposalVote { // <= FOUND
118:         uint256 againstVotes;
119:         uint256 forVotes;
120:         uint256 abstainVotes;
121:         mapping(address => bool) hasVoted;
122:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L117-L117)

```43:     struct Checkpoint { // <= FOUND
44:         uint32 fromBlock;
45:         uint224 votes;
46:     }
```

*GitHub* : [43](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L43-L43)

```77:     struct RebasingState { // <= FOUND
78:         uint8 isRebasing;
79:         uint248 nShares;
80:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L77-L77)

```99:     struct InterpolatedValue { // <= FOUND
100:         uint32 lastTimestamp;
101:         uint224 lastValue;
102:         uint32 targetTimestamp;
103:         uint224 targetValue;
104:     }
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L99-L99)

```40:     struct Auction { // <= FOUND
41:         uint256 startTime;
42:         uint256 endTime;
43:         address lendingTerm;
44:         uint256 collateralAmount;
45:         uint256 callDebt;
46:     }
```

*GitHub* : [40](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L40-L40)

```61:     struct Signature { // <= FOUND
62:         uint8 v;
63:         bytes32 r;
64:         bytes32 s;
65:     }
```

*GitHub* : [61](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L61-L61)

```75:     struct Loan { // <= FOUND
76:         address borrower; 
77:         uint256 borrowTime; 
78:         uint256 borrowAmount; 
79:         uint256 borrowCreditMultiplier; 
80:         uint256 collateralAmount; 
81:         address caller; 
82:         uint256 callTime; 
83:         uint256 callDebt; 
84:         uint256 closeTime; 
85:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L75-L75)

```97:     struct LendingTermReferences { // <= FOUND
98:         
99:         address profitManager;
100:         
101:         address guildToken;
102:         
103:         
104:         address auctionHouse;
105:         
106:         address creditMinter;
107:         
108:         address creditToken;
109:     }
```

*GitHub* : [97](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L97-L97)

```114:     struct LendingTermParams { // <= FOUND
115:         
116:         address collateralToken;
117:         
118:         
119:         
120:         
121:         
122:         
123:         
124:         
125:         uint256 maxDebtPerCollateralToken;
126:         
127:         
128:         uint256 interestRate;
129:         
130:         
131:         
132:         
133:         uint256 maxDelayBetweenPartialRepay;
134:         
135:         
136:         
137:         uint256 minPartialRepayPercent;
138:         
139:         
140:         
141:         
142:         
143:         
144:         uint256 openingFee;
145:         
146:         
147:         uint256 hardCap;
148:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L114-L114)

```77:     struct UserStake { // <= FOUND
78:         uint48 stakeTime;
79:         uint48 lastGaugeLoss;
80:         uint160 profitIndex;
81:         uint128 credit;
82:         uint128 guild;
83:     }
```

*GitHub* : [77](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L77-L77)
### [GAS-70]<a name="gas-70"></a> Use assembly scratch space to build calldata for external calls
Using Solidity's assembly scratch space for constructing calldata in external calls with one or two arguments can be a gas-efficient approach. This method leverages the designated memory area (the first 64 bytes of memory) for temporary data storage during assembly operations. By directly writing arguments into this scratch space, it eliminates the need for additional memory allocation typically required for calldata preparation. This technique can lead to notable gas savings, especially in high-frequency or gas-sensitive operations. However, it requires careful implementation to avoid data corruption and should be used with a thorough understanding of low-level EVM operations and memory handling. Proper testing and validation are crucial when employing such optimizations.

*There are 131 instance(s) of this issue:*

```99:         
100:         require( // <= FOUND
101:             GuildToken(guildToken).isGauge(term), // <= FOUND
102:             "LendingTermOffboarding: not an active term"
103:         );
```

*GitHub* : [99](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L99-L101)

```126:         uint256 userWeight = GuildToken(guildToken).getPastVotes( // <= FOUND
127:             msg.sender, // <= FOUND
128:             snapshotBlock
129:         );
```

*GitHub* : [126](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L126-L127)

```181:         require( // <= FOUND
182:             GuildToken(guildToken).isDeprecatedGauge(term), // <= FOUND
183:             "LendingTermOffboarding: re-onboarded"
184:         );
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L181-L182)

```273:         CreditToken(credit).transfer(to, amount); // <= FOUND
```

*GitHub* : [273](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L273-L273)

```371:                 CreditToken(_credit).transfer( // <= FOUND
372:                     _profitSharingConfig.otherRecipient, // <= FOUND
373:                     amountForOther
374:                 );
```

*GitHub* : [371](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L371-L372)

```413:         uint256 _userGaugeWeight = uint256( // <= FOUND
414:             GuildToken(guild).getUserGaugeWeight(user, gauge) // <= FOUND
415:         );
```

*GitHub* : [413](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L413-L414)

```434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
```

*GitHub* : [434](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L434-L434)

```480:                 uint256 _userGaugeWeight = uint256( // <= FOUND
481:                     GuildToken(_guild).getUserGaugeWeight(user, gauge) // <= FOUND
482:                 );
```

*GitHub* : [480](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L480-L481)

```427:         
428:         require( // <= FOUND
429:             _gauges.contains(gauge) && _deprecatedGauges.add(gauge), // <= FOUND
430:             "ERC20Gauges: invalid gauge"
431:         );
```

*GitHub* : [427](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L427-L429)

```405:         super._burn(from, amount); // <= FOUND
```

*GitHub* : [405](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L405-L405)

```413:         return super.transfer(to, amount); // <= FOUND
```

*GitHub* : [413](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L413-L413)

```324:             ERC20._mint(account, mintAmount); // <= FOUND
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L324-L324)

```478:                 ERC20._mint(account, mintAmount); // <= FOUND
```

*GitHub* : [478](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L478-L478)

```486: 
487:         
488:         ERC20._burn(account, amount); // <= FOUND
```

*GitHub* : [486](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L486-L488)

```511:         
512:         ERC20._mint(account, amount); // <= FOUND
```

*GitHub* : [511](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L511-L512)

```576:                 ERC20._mint(msg.sender, mintAmount); // <= FOUND
```

*GitHub* : [576](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L576-L576)

```584: 
585:         
586:         bool success = ERC20.transfer(to, amount); // <= FOUND
```

*GitHub* : [584](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L584-L586)

```628:                 ERC20._mint(to, mintAmount); // <= FOUND
```

*GitHub* : [628](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L628-L628)

```670:                 ERC20._mint(from, mintAmount); // <= FOUND
```

*GitHub* : [670](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L670-L670)

```87:         ERC20RebaseDistributor._mint(account, amount); // <= FOUND
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L87-L87)

```95:         ERC20RebaseDistributor._burn(account, amount); // <= FOUND
```

*GitHub* : [95](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L95-L95)

```122:         return ERC20RebaseDistributor.transfer(to, amount); // <= FOUND
```

*GitHub* : [122](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L122-L122)

```220: 
221:         
222:         ProfitManager(profitManager).claimGaugeRewards(user, gauge); // <= FOUND
```

*GitHub* : [220](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L220-L222)

```220: 
221:         ProfitManager(profitManager).claimGaugeRewards(user, gauge); // <= FOUND
```

*GitHub* : [220](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L220-L221)

```285:         ERC20._burn(from, amount); // <= FOUND
```

*GitHub* : [285](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L285-L285)

```299:         return ERC20.transfer(to, amount); // <= FOUND
```

*GitHub* : [299](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L299-L299)

```383:         uint256 _debtCeiling = (GuildToken(refs.guildToken) // <= FOUND
384:             .calculateGaugeAllocation( // <= FOUND
385:                 address(this), // <= FOUND
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
```

*GitHub* : [383](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L383-L385)

```418: 
419:         
420:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount); // <= FOUND
```

*GitHub* : [418](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L418-L420)

```546: 
547:         
548:         CreditToken(refs.creditToken).transfer( // <= FOUND
549:             refs.profitManager, // <= FOUND
550:             interestRepaid
551:         );
```

*GitHub* : [546](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L546-L549)

```550:         ProfitManager(refs.profitManager).notifyPnL( // <= FOUND
551:             address(this), // <= FOUND
552:             int256(interestRepaid) // <= FOUND
553:         );
```

*GitHub* : [550](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L550-L552)

```597:             
598:             CreditToken(refs.creditToken).transfer( // <= FOUND
599:                 refs.profitManager, // <= FOUND
600:                 interest
601:             );
```

*GitHub* : [597](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L597-L599)

```603: 
604:             
605:             ProfitManager(refs.profitManager).notifyPnL( // <= FOUND
606:                 address(this), // <= FOUND
607:                 int256(interest) // <= FOUND
608:             );
```

*GitHub* : [603](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L603-L607)

```618: 
619:         
620:         IERC20(params.collateralToken).safeTransfer( // <= FOUND
621:             loan.borrower, // <= FOUND
622:             loan.collateralAmount // <= FOUND
623:         );
```

*GitHub* : [618](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L618-L622)

```652: 
653:         
654:         require( // <= FOUND
655:             GuildToken(refs.guildToken).isDeprecatedGauge(address(this)) || // <= FOUND
656:                 partialRepayDelayPassed(loanId), // <= FOUND
657:             "LendingTerm: cannot call"
658:         );
```

*GitHub* : [652](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L652-L656)

```671: 
672:         
673:         AuctionHouse(_auctionHouse).startAuction(loanId, loanDebt); // <= FOUND
```

*GitHub* : [671](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L671-L673)

```715:         ProfitManager(refs.profitManager).notifyPnL(address(this), pnl); // <= FOUND
```

*GitHub* : [715](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L715-L715)

```792:                 CreditToken(refs.creditToken).transfer( // <= FOUND
793:                     refs.profitManager, // <= FOUND
794:                     interest
795:                 );
```

*GitHub* : [792](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L792-L793)

```797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl); // <= FOUND
```

*GitHub* : [797](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L797-L797)

```805:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
806:                 loans[loanId].borrower, // <= FOUND
807:                 collateralToBorrower
808:             );
```

*GitHub* : [805](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L805-L806)

```813:             IERC20(params.collateralToken).safeTransfer( // <= FOUND
814:                 bidder, // <= FOUND
815:                 collateralToBidder
816:             );
```

*GitHub* : [813](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L813-L814)

```110:         CreditToken(credit).mint(to, amountOut); // <= FOUND
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L110-L110)

```120:         require( // <= FOUND
121:             !CreditToken(credit).isRebasing(msg.sender), // <= FOUND
122:             "SimplePSM: already rebasing"
123:         );
```

*GitHub* : [120](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L120-L121)

```127:         CreditToken(credit).mint(msg.sender, amountOut); // <= FOUND
```

*GitHub* : [127](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L127-L127)

```140:         CreditToken(credit).burnFrom(msg.sender, amountIn); // <= FOUND
```

*GitHub* : [140](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L140-L140)

```142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L142-L142)

```129:         CreditToken(credit).approve(address(profitManager), amount); // <= FOUND
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L129-L129)

```130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount); // <= FOUND
```

*GitHub* : [130](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L130-L130)

```135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount); // <= FOUND
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L135-L135)

```136:         GuildToken(guild).incrementGauge(term, guildAmount); // <= FOUND
```

*GitHub* : [136](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L136-L136)

```206: 
207:         
208:         GuildToken(guild).decrementGauge(term, guildAmount); // <= FOUND
```

*GitHub* : [206](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L206-L208)

```240:         uint256 _profitIndex = ProfitManager(profitManager) // <= FOUND
241:             .userGaugeProfitIndex(address(this), term); // <= FOUND
```

*GitHub* : [240](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L240-L241)

```259:                 RateLimitedMinter(rlgm).mint(user, guildReward); // <= FOUND
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L259-L259)

```263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
```

*GitHub* : [263](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L263-L263)

```305:             RateLimitedMinter(rlgm).mint(address(this), guildAmount); // <= FOUND
```

*GitHub* : [305](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L305-L305)

```306:             GuildToken(guild).incrementGauge(term, guildAmount); // <= FOUND
```

*GitHub* : [306](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L306-L306)

```310:             GuildToken(guild).decrementGauge(term, guildAmount); // <= FOUND
```

*GitHub* : [310](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L310-L310)

```54:         IERC20Mintable(token).mint(to, amount);  // <= FOUND
```

*GitHub* : [54](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/rate-limits/RateLimitedMinter.sol#L54-L54)

```85:         return
86:             Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap); // <= FOUND
```

*GitHub* : [85](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L85-L86)

```87: 
92:     function emergencyAction( // <= FOUND
93:         Call[] calldata calls
94:     )
95:         external
96:         payable
97:         onlyCoreRole(CoreRoles.GOVERNOR) // <= FOUND
98:         returns (bytes[] memory returnData) // <= FOUND
99:     {
```

*GitHub* : [87](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L87-L98)

```101: 
102:             (bool success, bytes memory returned) = target.call{value: value}( // <= FOUND
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L101-L102)

```110: 
116:     function guardianCancel( // <= FOUND
117:         address[] memory targets, // <= FOUND
118:         uint256[] memory values, // <= FOUND
119:         bytes[] memory calldatas, // <= FOUND
120:         bytes32 descriptionHash
121:     ) public onlyCoreRole(CoreRoles.GUARDIAN) returns (uint256) { // <= FOUND
```

*GitHub* : [110](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L110-L121)

```168:         return super.state(proposalId); // <= FOUND
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L168-L168)

```174:         return super.supportsInterface(interfaceId); // <= FOUND
```

*GitHub* : [174](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L174-L174)

```159: 
160:         
161:         
162:         
163:         GuildToken(guildToken).removeGauge(term); // <= FOUND
```

*GitHub* : [159](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L159-L163)

```166:             SimplePSM(psm).setRedemptionsPaused(true); // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L166-L166)

```194:             SimplePSM(psm).setRedemptionsPaused(false); // <= FOUND
```

*GitHub* : [194](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L194-L194)

```105: 
107:     function createTerm( // <= FOUND
108:         address implementation, // <= FOUND
109:         LendingTerm.LendingTermParams calldata params // <= FOUND
110:     ) external returns (address) { // <= FOUND
```

*GitHub* : [105](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L105-L110)

```153: 
154:         address term = Clones.clone(implementation); // <= FOUND
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L153-L154)

```199: 
200:         
201:         
202:         
203:         
204:         
205:         bool isGauge = GuildToken(guildToken).isGauge(term); // <= FOUND
```

*GitHub* : [199](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOnboarding.sol#L199-L205)

```305: 
306:             
307:             GuildToken(guild).notifyGaugeLoss(gauge); // <= FOUND
```

*GitHub* : [305](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L305-L307)

```322:                 CreditToken(_credit).burn(loss); // <= FOUND
```

*GitHub* : [322](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L322-L322)

```327:                 CreditToken(_credit).burn(_surplusBuffer); // <= FOUND
```

*GitHub* : [327](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L327-L327)

```379:                 CreditToken(_credit).distribute(amountForCredit); // <= FOUND
```

*GitHub* : [379](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L379-L379)

```388:                 
389:                 
390:                 
391:                 
392:                 uint256 _gaugeWeight = uint256( // <= FOUND
393:                     GuildToken(guild).getGaugeWeight(gauge) // <= FOUND
394:                 );
```

*GitHub* : [388](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L388-L393)

```442:         address[] memory gauges = GuildToken(guild).userGauges(user); // <= FOUND
```

*GitHub* : [442](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L442-L442)

```464:         gauges = GuildToken(_guild).userGauges(user); // <= FOUND
```

*GitHub* : [464](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L464-L464)

```249:         ProposalState status = super.state(proposalId); // <= FOUND
```

*GitHub* : [249](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L249-L249)

```269: 
270:         
271:         
272:         uint256 timelockOperationTimestamp = TimelockController( // <= FOUND
273:             payable(timelock) // <= FOUND
274:         ).getTimestamp(queueid); // <= FOUND
```

*GitHub* : [269](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L269-L274)

```317:         
318:         uint256 timelockExecutionTime = TimelockController(payable(timelock)) // <= FOUND
319:             .getTimestamp(timelockId); // <= FOUND
```

*GitHub* : [317](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L317-L319)

```104:         return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge); // <= FOUND
```

*GitHub* : [104](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L104-L104)

```109:         return _deprecatedGauges.contains(gauge); // <= FOUND
```

*GitHub* : [109](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L109-L109)

```135:             if (!_deprecatedGauges.contains(allGauges[i])) { // <= FOUND
```

*GitHub* : [135](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L135-L135)

```163:         return _userGauges[user].contains(gauge); // <= FOUND
```

*GitHub* : [163](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L163-L163)

```186:         if (_deprecatedGauges.contains(gauge)) return 0; // <= FOUND
```

*GitHub* : [186](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L186-L186)

```235:         bool added = _userGauges[user].add(gauge);  // <= FOUND
```

*GitHub* : [235](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L235-L235)

```148:         if (!_deprecatedGauges.contains(gauge)) { // <= FOUND
```

*GitHub* : [148](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L148-L148)

```324:             
325:             require(_userGauges[user].remove(gauge)); // <= FOUND
```

*GitHub* : [324](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L324-L325)

```357:             if (!_deprecatedGauges.contains(gauge)) { // <= FOUND
```

*GitHub* : [357](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L357-L357)

```399:         bool newAdd = _gauges.add(gauge); // <= FOUND
```

*GitHub* : [399](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L399-L399)

```400:         bool previouslyDeprecated = _deprecatedGauges.remove(gauge); // <= FOUND
```

*GitHub* : [400](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L400-L400)

```527: 
528:                 
529:                 if (!_deprecatedGauges.contains(gauge)) { // <= FOUND
```

*GitHub* : [527](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L527-L529)

```246:         return _delegates[delegator].contains(delegatee); // <= FOUND
```

*GitHub* : [246](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L246-L246)

```329: 
330:         bool newDelegate = _delegates[delegator].add(delegatee);  // <= FOUND
```

*GitHub* : [329](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L329-L330)

```353:             require(_delegates[delegator].remove(delegatee)); // <= FOUND
```

*GitHub* : [353](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L353-L353)

```377:             ckpts.push( // <= FOUND
378:                 Checkpoint({ // <= FOUND
```

*GitHub* : [377](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L377-L378)

```451: 
452:                 require(_delegates[user].remove(delegatee));  // <= FOUND
```

*GitHub* : [451](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L451-L452)

```290:         uint256 balance = ERC20.balanceOf(account); // <= FOUND
```

*GitHub* : [290](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L290-L290)

```312:         uint256 rawBalance = ERC20.balanceOf(account); // <= FOUND
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L312-L312)

```431:             return ERC20.balanceOf(account); // <= FOUND
```

*GitHub* : [431](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L431-L431)

```468:             balanceBefore = ERC20.balanceOf(account); // <= FOUND
```

*GitHub* : [468](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L468-L468)

```518:             uint256 rawBalance = ERC20.balanceOf(account); // <= FOUND
```

*GitHub* : [518](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L518-L518)

```561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender); // <= FOUND
```

*GitHub* : [561](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L561-L561)

```596:             rebasingState[msg.sender] = RebasingState({ // <= FOUND
```

*GitHub* : [596](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L596-L596)

```605:             
606:             uint256 rawToBalanceAfter = ERC20.balanceOf(to); // <= FOUND
```

*GitHub* : [605](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L605-L606)

```655:         uint256 fromBalanceBefore = ERC20.balanceOf(from); // <= FOUND
```

*GitHub* : [655](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L655-L655)

```101:         return ERC20RebaseDistributor.balanceOf(account); // <= FOUND
```

*GitHub* : [101](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/CreditToken.sol#L101-L101)

```76: 
80:     function addGauge( // <= FOUND
81:         uint256 _type, // <= FOUND
82:         address gauge
83:     ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) { // <= FOUND
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L76-L83)

```226:             uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight)); // <= FOUND
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L226-L226)

```83: 
84:         
85:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId); // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L83-L85)

```218:         uint256 interest = (borrowAmount * // <= FOUND
219:             params.interestRate * // <= FOUND
220:             (block.timestamp - borrowTime)) / // <= FOUND
221:             YEAR /
222:             1e18;
```

*GitHub* : [218](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L218-L220)

```274:         uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight( // <= FOUND
275:             address(this) // <= FOUND
276:         );
```

*GitHub* : [274](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L274-L275)

```278:         uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this)); // <= FOUND
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L278-L278)

```279:         uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight( // <= FOUND
280:             gaugeType
281:         );
```

*GitHub* : [279](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L279-L279)

```554:         CreditToken(refs.creditToken).burn(principalRepaid); // <= FOUND
```

*GitHub* : [554](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L554-L554)

```555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid); // <= FOUND
```

*GitHub* : [555](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L555-L555)

```610: 
611:         
612:         CreditToken(refs.creditToken).burn(principal); // <= FOUND
```

*GitHub* : [610](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L610-L612)

```611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal); // <= FOUND
```

*GitHub* : [611](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L611-L611)

```784:             CreditToken(refs.creditToken).burn(principal); // <= FOUND
```

*GitHub* : [784](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L784-L784)

```785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal); // <= FOUND
```

*GitHub* : [785](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L785-L785)

```128:         CreditToken(credit).forceEnterRebase(msg.sender); // <= FOUND
```

*GitHub* : [128](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L128-L128)

```181: 
182:         userStake.credit -= SafeCastLib.safeCastTo128(amount); // <= FOUND
```

*GitHub* : [181](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L181-L182)

```182:         userStake.guild -= SafeCastLib.safeCastTo128(guildAmount); // <= FOUND
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L182-L182)

```207:         RateLimitedMinter(rlgm).replenishBuffer(guildAmount); // <= FOUND
```

*GitHub* : [207](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L207-L207)

```208:         GuildToken(guild).burn(guildAmount); // <= FOUND
```

*GitHub* : [208](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L208-L208)

```228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term); // <= FOUND
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L228-L228)

```239: 
240:         
241:         ProfitManager(profitManager).claimRewards(address(this));  // <= FOUND
```

*GitHub* : [239](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L239-L241)

```267: 
268:             
269:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex); // <= FOUND
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L267-L269)

```275:             emit Unstake(block.timestamp, term, uint256(userStake.credit)); // <= FOUND
```

*GitHub* : [275](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L275-L275)

```307:             _stakes[user][term].guild = SafeCastLib.safeCastTo128(guildAfter); // <= FOUND
```

*GitHub* : [307](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L307-L307)

```311:             RateLimitedMinter(rlgm).replenishBuffer(guildAmount); // <= FOUND
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L311-L311)

```312:             GuildToken(guild).burn(guildAmount); // <= FOUND
```

*GitHub* : [312](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L312-L312)
### [GAS-71]<a name="gas-71"></a> Use assembly scratch space to build calldata for event emits
Utilizing Solidity's assembly scratch space to build calldata for emitting events with just one or two arguments can optimize gas usage. The scratch space, a designated area in the first 64 bytes of memory, is ideal for temporary storage during assembly-level operations. By directly writing the event arguments into this area, developers can bypass the standard memory allocation process required for event emission. This approach results in gas savings, particularly for contracts where events are frequently emitted. However, such low-level optimization requires a deep understanding of Ethereum Virtual Machine (EVM) mechanics and careful coding to prevent data mishandling. Rigorous testing is essential to ensure the integrity and correct functionality of the contract.

*There are 33 instance(s) of this issue:*

```439: 
440:         emit RemoveGauge(gauge); // <= FOUND
```

*GitHub* : [439](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L439-L440)

```53: 
54:         emit CoreUpdate(oldCore, newCore); // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/CoreRef.sol#L53-L54)

```69:         emit QuorumUpdated(_quorum, newQuorum); // <= FOUND
```

*GitHub* : [69](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildGovernor.sol#L69-L69)

```81:         emit QuorumUpdated(quorum, _quorum); // <= FOUND
```

*GitHub* : [81](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L81-L81)

```169: 
170:         emit Offboard(block.timestamp, term); // <= FOUND
```

*GitHub* : [169](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L169-L170)

```198:         emit Cleanup(block.timestamp, term); // <= FOUND
```

*GitHub* : [198](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L198-L198)

```107:         emit MinBorrowUpdate(block.timestamp, 100e18); // <= FOUND
```

*GitHub* : [107](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L107-L107)

```183:         emit MinBorrowUpdate(block.timestamp, newValue); // <= FOUND
```

*GitHub* : [183](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L183-L183)

```191:         emit GaugeWeightToleranceUpdate(block.timestamp, newValue); // <= FOUND
```

*GitHub* : [191](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L191-L191)

```255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer); // <= FOUND
```

*GitHub* : [255](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L255-L255)

```318:                 emit SurplusBufferUpdate( // <= FOUND
319:                     block.timestamp, // <= FOUND
320:                     _surplusBuffer - loss
321:                 );
```

*GitHub* : [318](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L318-L319)

```328:                 emit SurplusBufferUpdate(block.timestamp, 0); // <= FOUND
```

*GitHub* : [328](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L328-L328)

```335:                 emit CreditMultiplierUpdate( // <= FOUND
336:                     block.timestamp, // <= FOUND
337:                     newCreditMultiplier
338:                 );
```

*GitHub* : [335](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L335-L336)

```363:                 emit SurplusBufferUpdate( // <= FOUND
364:                     block.timestamp, // <= FOUND
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L363-L364)

```100:         emit TimelockChange(timelock, newTimelock); // <= FOUND
```

*GitHub* : [100](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/GuildVetoGovernor.sol#L100-L100)

```422: 
423:         emit AddGauge(gauge, _type); // <= FOUND
```

*GitHub* : [422](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L422-L423)

```448: 
449:         emit MaxGaugesUpdate(oldMax, newMax); // <= FOUND
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L448-L449)

```465: 
466:         emit CanExceedMaxGaugesUpdate(account, canExceedMax); // <= FOUND
```

*GitHub* : [465](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L465-L466)

```151: 
152:         emit MaxDelegatesUpdate(oldMax, newMax); // <= FOUND
```

*GitHub* : [151](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L151-L152)

```166: 
167:         emit CanContractExceedMaxDelegatesUpdate(account, canExceedMax); // <= FOUND
```

*GitHub* : [166](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L166-L167)

```298:         emit RebaseEnter(account, block.timestamp); // <= FOUND
```

*GitHub* : [298](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L298-L298)

```332: 
333:         emit RebaseExit(account, block.timestamp); // <= FOUND
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L332-L333)

```128:         emit GaugeLoss(gauge, block.timestamp); // <= FOUND
```

*GitHub* : [128](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L128-L128)

```177:         emit TransfersEnabled(block.number, block.timestamp); // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L177-L177)

```199:         emit ProfitManagerUpdated(block.timestamp, _newProfitManager); // <= FOUND
```

*GitHub* : [199](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L199-L199)

```674: 
675:         
676:         emit LoanCall(block.timestamp, loanId); // <= FOUND
```

*GitHub* : [674](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L674-L676)

```153:         emit RedemptionsPaused(block.timestamp, paused); // <= FOUND
```

*GitHub* : [153](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L153-L153)

```323:         emit MintRatioUpdate(block.timestamp, _mintRatio); // <= FOUND
```

*GitHub* : [323](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L323-L323)

```332:         emit RewardRatioUpdate(block.timestamp, _rewardRatio); // <= FOUND
```

*GitHub* : [332](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L332-L332)

```106: 
107:         emit BufferUsed(amount, bufferStored); // <= FOUND
```

*GitHub* : [106](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L106-L107)

```134: 
135:         emit BufferReplenished(amount, bufferStored); // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L134-L135)

```142: 
143:         emit RateLimitPerSecondUpdate( // <= FOUND
144:             oldRateLimitPerSecond, // <= FOUND
145:             newRateLimitPerSecond
146:         );
```

*GitHub* : [142](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L142-L144)

```155: 
156:         emit BufferCapUpdate(oldBufferCap, newBufferCap); // <= FOUND
```

*GitHub* : [155](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/utils/RateLimitedV2.sol#L155-L156)
### [GAS-72]<a name="gas-72"></a> Consider using solady's `FixedPointMathLib`
Using Solady's `FixedPointMathLib` for multiplication or division operations in Solidity can lead to significant gas savings. This library is designed to optimize fixed-point arithmetic operations, which are common in financial calculations involving tokens or currencies. By implementing more efficient algorithms and assembly optimizations, `FixedPointMathLib` minimizes the computational resources required for these operations. For contracts that frequently perform such calculations, integrating this library can reduce transaction costs, thereby enhancing overall performance and cost-effectiveness. However, developers must ensure compatibility with their existing codebase and thoroughly test for accuracy and expected behavior to avoid any unintended consequences.

*There are 31 instance(s) of this issue:*

```76:         decimalCorrection = 10 ** (18 - decimals); // <= FOUND
```

*GitHub* : [76](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L76-L76)

```152:         return (_minBorrow * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L152-L152)

```213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9), // <= FOUND
214:             guildSplit: uint32(guildSplit / 1e9), // <= FOUND
215:             otherSplit: uint32(otherSplit / 1e9), // <= FOUND
216:             otherRecipient: otherRecipient
217:         });
```

*GitHub* : [213](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L213-L215)

```332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply; // <= FOUND
```

*GitHub* : [333](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L333-L333)

```346: 
347:             uint256 amountForSurplusBuffer = (uint256(amount) *
348:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9; // <= FOUND
```

*GitHub* : [348](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L348-L348)

```349: 
350:             uint256 amountForGuild = (uint256(amount) *
351:                 uint256(_profitSharingConfig.guildSplit)) / 1e9; // <= FOUND
```

*GitHub* : [351](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L351-L351)

```352: 
353:             uint256 amountForOther = (uint256(amount) *
354:                 uint256(_profitSharingConfig.otherSplit)) / 1e9; // <= FOUND
```

*GitHub* : [354](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L354-L354)

```429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [429](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L429-L429)

```483:                 creditEarned[i] = (_userGaugeWeight * deltaIndex) / 1e18; // <= FOUND
```

*GitHub* : [483](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L483-L483)

```192: 
193:         return (quantity * weight) / total; // <= FOUND
```

*GitHub* : [193](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20Gauges.sol#L193-L193)

```124:         
125:         return (a & b) + (a ^ b) / 2; // <= FOUND
```

*GitHub* : [125](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L125-L125)

```256:         return (balance * START_REBASING_SHARE_PRICE) / sharePrice; // <= FOUND
```

*GitHub* : [256](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L256-L256)

```365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares; // <= FOUND
```

*GitHub* : [368](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L368-L368)

```141:             collateralReceived = (_collateralAmount * elapsed) / midPoint; // <= FOUND
```

*GitHub* : [141](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L141-L141)

```152:             creditAsked = _callDebt - (_callDebt * elapsed) / PHASE_2_DURATION; // <= FOUND
```

*GitHub* : [152](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L152-L152)

```226:             loanDebt += (borrowAmount * _openingFee) / 1e18; // <= FOUND
```

*GitHub* : [226](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L226-L226)

```230:         loanDebt = (loanDebt * loan.borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [230](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L230-L230)

```307:         uint256 debtCeilingBefore = (totalBorrowedCredit *
308:             toleratedGaugeWeight) / totalWeight; // <= FOUND
```

*GitHub* : [308](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L308-L308)

```357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier; // <= FOUND
```

*GitHub* : [358](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L358-L358)

```383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18; // <= FOUND
```

*GitHub* : [387](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L387-L387)

```510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt;  // <= FOUND
```

*GitHub* : [510](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L510-L510)

```516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [516](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L516-L516)

```518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18; // <= FOUND
```

*GitHub* : [518](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L518-L518)

```523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18, // <= FOUND
525:             "LendingTerm: repay below min"
526:         );
```

*GitHub* : [524](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L524-L524)

```712:         uint256 principal = (borrowAmount *
713:             loans[loanId].borrowCreditMultiplier) / creditMultiplier; // <= FOUND
```

*GitHub* : [713](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L713-L713)

```83:         return (amountIn * decimalCorrection * 1e18) / creditMultiplier; // <= FOUND
```

*GitHub* : [83](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L83-L83)

```92:         return (amountIn * creditMultiplier) / 1e18 / decimalCorrection; // <= FOUND
```

*GitHub* : [92](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L92-L92)

```134:         uint256 guildAmount = (_mintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L134-L134)

```177:         uint256 guildAmount = (userMintRatio * amount) / 1e18; // <= FOUND
```

*GitHub* : [177](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L177-L177)

```252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18; // <= FOUND
```

*GitHub* : [252](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L252-L252)

```302:         uint256 guildAfter = (mintRatio * uint256(userStake.credit)) / 1e18; // <= FOUND
```

*GitHub* : [302](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L302-L302)
### [GAS-73]<a name="gas-73"></a> Same cast is done multiple times
Repeatedly casting the same variable to the same type within a function is redundant and can be optimized for better gas efficiency and code readability. Each unnecessary cast operation, while minor, adds to the gas cost and clutters the code. To optimize, the best practice is to perform the cast once and store the result in a temporary variable, which can then be used wherever needed in the function.

*There are 11 instance(s) of this issue:*

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) * // <= FOUND 'int256(amount)'
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) * // <= FOUND 'int256(amount)'
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) * // <= FOUND 'int256(amount)'
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) - // <= FOUND 'int256(amount)'
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L355)

```133:     function applyGaugeLoss(address gauge, address who) external {
134:         
135:         uint256 _lastGaugeLoss = lastGaugeLoss[gauge];
136:         uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];
137:         require(
138:             _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,
139:             "GuildToken: no loss to apply"
140:         );
141: 
142:         
143:         uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];
144: 
145:         
146:         lastGaugeLossApplied[gauge][who] = block.timestamp;
147:         _decrementGaugeWeight(who, gauge, _userGaugeWeight);
148:         if (!_deprecatedGauges.contains(gauge)) {
149:             totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;
150:             totalWeight -= _userGaugeWeight;
151:         }
152: 
153:         
154:         _burn(who, uint256(_userGaugeWeight)); // <= FOUND 'int256(_userGaugeWeight)'
155:         emit GaugeLossApply(
156:             gauge,
157:             who,
158:             uint256(_userGaugeWeight), // <= FOUND 'int256(_userGaugeWeight)'
159:             block.timestamp
160:         );
161:     }
```

*GitHub* : [133](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L133-L158)

```156:     function initializeReferences(
157:         address _credit,
158:         address _guild,
159:         address _psm
160:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
161:         assert(
162:             credit == address(0) && guild == address(0) && psm == address(0) // <= FOUND 'address(0)'
163:         );
164:         credit = _credit;
165:         guild = _guild;
166:         psm = _psm;
167:     }
```

*GitHub* : [156](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L156-L162)

```182:     function _beforeTokenTransfer(
183:         address from,
184:         address to,
185:         uint256 
186:     ) internal view override {
187:         require(
188:             transferable || from == address(0) || to == address(0), // <= FOUND 'address(0)'
189:             "GuildToken: transfers disabled"
190:         );
191:     }
```

*GitHub* : [182](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/GuildToken.sol#L182-L188)

```160:     function initialize(
161:         address _core,
162:         LendingTermReferences calldata _refs,
163:         LendingTermParams calldata _params
164:     ) external {
165:         
166:         assert(address(core()) == address(0)); // <= FOUND 'address(0)'
167:         assert(_core != address(0)); // <= FOUND 'address(0)'
168: 
169:         
170:         _setCore(_core);
171:         refs = _refs;
172:         params = _params;
173:     }
```

*GitHub* : [160](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L160-L167)

```270:     function debtCeiling(
271:         int256 gaugeWeightDelta
272:     ) public view returns (uint256) {
273:         address _guildToken = refs.guildToken; 
274:         uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(
275:             address(this) // <= FOUND 'address(this)'
276:         );
277:         gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);
278:         uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this)); // <= FOUND 'address(this)'
279:         uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(
280:             gaugeType
281:         );
282:         uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)
283:             .buffer();
284:         uint256 _hardCap = params.hardCap; 
285:         if (gaugeWeight == 0) {
286:             return 0; 
287:         } else if (gaugeWeight == totalWeight) {
288:             
289:             
290:             return
291:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
292:         }
293:         uint256 _issuance = issuance; 
294:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
295:             .totalBorrowedCredit();
296:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
297:             .gaugeWeightTolerance();
298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) {
299:             
300:             
301:             
302:             return
303:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
304:         }
305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /
306:             1e18;
307:         uint256 debtCeilingBefore = (totalBorrowedCredit *
308:             toleratedGaugeWeight) / totalWeight;
309:         if (_issuance >= debtCeilingBefore) {
310:             return debtCeilingBefore; 
311:         }
312:         uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; 
313:         if (toleratedGaugeWeight >= totalWeight) {
314:             
315:             
316:             return
317:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
318:         }
319:         uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; 
320:         uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /
321:             otherGaugesWeight;
322:         uint256 _debtCeiling = _issuance + maxBorrow;
323:         
324:         if (creditMinterBuffer < _debtCeiling) {
325:             return creditMinterBuffer;
326:         }
327:         if (_hardCap < _debtCeiling) {
```

*GitHub* : [270](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270-L278)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp) // <= FOUND 'address(this)'
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this), // <= FOUND 'address(this)'
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0), // <= FOUND 'address(0)'
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this), // <= FOUND 'address(this)'
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L423)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this), // <= FOUND 'address(this)'
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this), // <= FOUND 'address(this)'
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L551)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this), // <= FOUND 'address(this)'
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this), // <= FOUND 'address(this)'
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L604)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this), // <= FOUND 'address(this)'
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl); // <= FOUND 'address(this)'
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L797)

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND 'address(this)'
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount); // <= FOUND 'address(this)'
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this), // <= FOUND 'address(this)'
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L144)
### [GAS-74]<a name="gas-74"></a> Assigning to structs can be more efficient
Rather defining the struct in a single line, it is more efficient to declare an empty struct and then assign each struct element individually. This can net quite a large gas saving of 130 per instance.

*There are 14 instance(s) of this issue:*

```195:     function setProfitSharingConfig(
196:         uint256 surplusBufferSplit,
197:         uint256 creditSplit,
198:         uint256 guildSplit,
199:         uint256 otherSplit,
200:         address otherRecipient
201:     ) external onlyCoreRole(CoreRoles.GOVERNOR) {
202:         if (otherRecipient == address(0)) {
203:             require(otherSplit == 0, "GuildToken: invalid config");
204:         } else {
205:             require(otherSplit != 0, "GuildToken: invalid config");
206:         }
207:         require(
208:             surplusBufferSplit + otherSplit + guildSplit + creditSplit == 1e18,
209:             "GuildToken: invalid config"
210:         );
211: 
212:         profitSharingConfig = ProfitSharingConfig({
213:             surplusBufferSplit: uint32(surplusBufferSplit / 1e9),
214:             guildSplit: uint32(guildSplit / 1e9),
215:             otherSplit: uint32(otherSplit / 1e9),
216:             otherRecipient: otherRecipient
217:         });
218: 
219:         emit ProfitSharingConfigUpdate(
220:             block.timestamp,
221:             surplusBufferSplit,
222:             creditSplit,
223:             guildSplit,
224:             otherSplit,
225:             otherRecipient
226:         );
227:     }
```

*GitHub* : [195](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L195-L195)

```168:     function updateTotalRebasingShares(
169:         uint256 currentRebasingSharePrice,
170:         int256 sharesDelta
171:     ) internal {
172:         if (sharesDelta == 0) return;
173:         uint256 sharesBefore = totalRebasingShares;
174:         uint256 sharesAfter;
175:         if (sharesDelta > 0) {
176:             sharesAfter = sharesBefore + uint256(sharesDelta);
177:         } else {
178:             uint256 shareDecrease = uint256(-sharesDelta);
179:             if (shareDecrease < sharesBefore) {
180:                 unchecked {
181:                     sharesAfter = sharesBefore - shareDecrease;
182:                 }
183:             }
184:             
185:         }
186:         totalRebasingShares = sharesAfter;
187: 
188:         
189:         if (sharesAfter == 0) {
190:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
191:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
192:                 lastValue: uint224(START_REBASING_SHARE_PRICE), 
193:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
194:                 targetValue: uint224(START_REBASING_SHARE_PRICE) 
195:             });
196:             __unmintedRebaseRewards = InterpolatedValue({ // <= FOUND
197:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
198:                 lastValue: 0,
199:                 targetTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
200:                 targetValue: 0
201:             });
202:             return;
203:         }
204: 
205:         
206:         
207:         
208:         
209:         
210:         InterpolatedValue memory val = __rebasingSharePrice;
211:         uint256 delta = uint256(val.targetValue) - currentRebasingSharePrice;
212:         if (delta != 0) {
213:             uint256 percentChange = (sharesAfter * START_REBASING_SHARE_PRICE) /
214:                 sharesBefore;
215:             uint256 targetNewSharePrice = currentRebasingSharePrice +
216:                 (delta * START_REBASING_SHARE_PRICE) /
217:                 percentChange;
218:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
219:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
220:                 lastValue: SafeCastLib.safeCastTo224(currentRebasingSharePrice), 
221:                 targetTimestamp: val.targetTimestamp, 
222:                 targetValue: SafeCastLib.safeCastTo224(targetNewSharePrice) 
223:             });
224:         }
225:     }
```

*GitHub* : [168](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L168-L218)

```228:     function decreaseUnmintedRebaseRewards(uint256 amount) internal { // <= FOUND
229:         InterpolatedValue memory val = __unmintedRebaseRewards;
230:         uint256 _unmintedRebaseRewards = interpolatedValue(val);
231:         __unmintedRebaseRewards = InterpolatedValue({ // <= FOUND
232:             lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp), 
233:             lastValue: SafeCastLib.safeCastTo224(
234:                 _unmintedRebaseRewards - amount
235:             ), 
236:             targetTimestamp: val.targetTimestamp, 
237:             targetValue: val.targetValue - SafeCastLib.safeCastTo224(amount) 
238:         });
239:     }
```

*GitHub* : [228](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L228-L231)

```289:     function _enterRebase(address account) internal { // <= FOUND
290:         uint256 balance = ERC20.balanceOf(account);
291:         uint256 currentRebasingSharePrice = rebasingSharePrice();
292:         uint256 shares = _balance2shares(balance, currentRebasingSharePrice);
293:         rebasingState[account] = RebasingState({ // <= FOUND
294:             isRebasing: 1,
295:             nShares: uint248(shares)
296:         });
297:         updateTotalRebasingShares(currentRebasingSharePrice, int256(shares));
298:         emit RebaseEnter(account, block.timestamp);
299:     }
```

*GitHub* : [289](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L289-L293)

```311:     function _exitRebase(address account) internal { // <= FOUND
312:         uint256 rawBalance = ERC20.balanceOf(account);
313:         RebasingState memory _rebasingState = rebasingState[account];
314:         uint256 shares = uint256(_rebasingState.nShares);
315:         uint256 currentRebasingSharePrice = rebasingSharePrice();
316:         uint256 rebasedBalance = _shares2balance(
317:             shares,
318:             currentRebasingSharePrice,
319:             0,
320:             rawBalance
321:         );
322:         uint256 mintAmount = rebasedBalance - rawBalance;
323:         if (mintAmount != 0) {
324:             ERC20._mint(account, mintAmount);
325:             decreaseUnmintedRebaseRewards(mintAmount);
326:             emit RebaseReward(account, block.timestamp, mintAmount);
327:         }
328: 
329:         rebasingState[account] = RebasingState({isRebasing: 0, nShares: 0}); // <= FOUND
330:         updateTotalRebasingShares(currentRebasingSharePrice, -int256(shares));
331: 
332:         emit RebaseExit(account, block.timestamp);
333:     }
```

*GitHub* : [311](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L311-L329)

```338:     function distribute(uint256 amount) external { // <= FOUND
339:         require(amount != 0, "ERC20RebaseDistributor: cannot distribute zero");
340: 
341:         
342:         _burn(msg.sender, amount);
343: 
344:         
345:         uint256 _rebasingSharePrice = rebasingSharePrice();
346:         uint256 _totalRebasingShares = totalRebasingShares;
347:         uint256 _rebasingSupply = _shares2balance(
348:             _totalRebasingShares,
349:             _rebasingSharePrice,
350:             0,
351:             0
352:         );
353:         emit RebaseDistribution(
354:             msg.sender,
355:             block.timestamp,
356:             amount,
357:             _rebasingSupply
358:         );
359: 
360:         
361:         
362:         if (_rebasingSupply != 0) {
363:             
364:             uint256 endTimestamp = block.timestamp + DISTRIBUTION_PERIOD;
365:             uint256 newTargetSharePrice = (amount *
366:                 START_REBASING_SHARE_PRICE +
367:                 __rebasingSharePrice.targetValue *
368:                 _totalRebasingShares) / _totalRebasingShares;
369:             __rebasingSharePrice = InterpolatedValue({ // <= FOUND
370:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
371:                 lastValue: SafeCastLib.safeCastTo224(_rebasingSharePrice),
372:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
373:                 targetValue: SafeCastLib.safeCastTo224(newTargetSharePrice)
374:             });
375: 
376:             
377:             uint256 _unmintedRebaseRewards = unmintedRebaseRewards();
378:             __unmintedRebaseRewards = InterpolatedValue({ // <= FOUND
379:                 lastTimestamp: SafeCastLib.safeCastTo32(block.timestamp),
380:                 lastValue: SafeCastLib.safeCastTo224(_unmintedRebaseRewards),
381:                 targetTimestamp: SafeCastLib.safeCastTo32(endTimestamp),
382:                 targetValue: __unmintedRebaseRewards.targetValue +
383:                     SafeCastLib.safeCastTo224(amount)
384:             });
385:         }
386:     }
```

*GitHub* : [338](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L338-L378)

```461:     function _burn(address account, uint256 amount) internal virtual override { // <= FOUND
462:         
463:         
464:         RebasingState memory _rebasingState = rebasingState[account];
465:         uint256 balanceBefore;
466:         uint256 _rebasingSharePrice;
467:         if (_rebasingState.isRebasing == 1) {
468:             balanceBefore = ERC20.balanceOf(account);
469:             _rebasingSharePrice = rebasingSharePrice();
470:             uint256 rebasedBalance = _shares2balance(
471:                 _rebasingState.nShares,
472:                 _rebasingSharePrice,
473:                 0,
474:                 balanceBefore
475:             );
476:             uint256 mintAmount = rebasedBalance - balanceBefore;
477:             if (mintAmount != 0) {
478:                 ERC20._mint(account, mintAmount);
479:                 balanceBefore += mintAmount;
480:                 decreaseUnmintedRebaseRewards(mintAmount);
481:                 emit RebaseReward(account, block.timestamp, mintAmount);
482:             }
483:         }
484: 
485:         
486:         ERC20._burn(account, amount);
487: 
488:         
489:         if (_rebasingState.isRebasing == 1) {
490:             uint256 balanceAfter = balanceBefore - amount;
491:             uint256 sharesAfter = _balance2shares(
492:                 balanceAfter,
493:                 _rebasingSharePrice
494:             );
495:             uint256 sharesBurnt = _rebasingState.nShares - sharesAfter;
496:             rebasingState[account] = RebasingState({ // <= FOUND
497:                 isRebasing: 1,
498:                 nShares: uint248(sharesAfter)
499:             });
500:             updateTotalRebasingShares(
501:                 _rebasingSharePrice,
502:                 -int256(sharesBurnt)
503:             );
504:         }
505:     }
```

*GitHub* : [461](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L461-L496)

```509:     function _mint(address account, uint256 amount) internal virtual override { // <= FOUND
510:         
511:         ERC20._mint(account, amount);
512: 
513:         
514:         RebasingState memory _rebasingState = rebasingState[account];
515:         if (_rebasingState.isRebasing == 1) {
516:             
517:             uint256 _rebasingSharePrice = rebasingSharePrice();
518:             uint256 rawBalance = ERC20.balanceOf(account);
519:             uint256 rebasedBalance = _shares2balance(
520:                 _rebasingState.nShares,
521:                 _rebasingSharePrice,
522:                 amount,
523:                 rawBalance
524:             );
525: 
526:             
527:             uint256 sharesAfter = _balance2shares(
528:                 rebasedBalance,
529:                 _rebasingSharePrice
530:             );
531:             uint256 sharesReceived = sharesAfter - _rebasingState.nShares;
532:             rebasingState[account] = RebasingState({ // <= FOUND
533:                 isRebasing: 1,
534:                 nShares: uint248(sharesAfter)
535:             });
536:             updateTotalRebasingShares(
537:                 _rebasingSharePrice,
538:                 int256(sharesReceived)
539:             );
540: 
541:             
542:             uint256 mintAmount = rebasedBalance - rawBalance;
543:             if (mintAmount != 0) {
544:                 ERC20._mint(account, mintAmount);
545:                 decreaseUnmintedRebaseRewards(mintAmount);
546:                 emit RebaseReward(account, block.timestamp, mintAmount);
547:             }
548:         }
549:     }
```

*GitHub* : [509](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L509-L532)

```553:     function transfer(
554:         address to,
555:         uint256 amount
556:     ) public virtual override returns (bool) {
557:         
558:         
559:         RebasingState memory rebasingStateFrom = rebasingState[msg.sender];
560:         RebasingState memory rebasingStateTo = rebasingState[to];
561:         uint256 fromBalanceBefore = ERC20.balanceOf(msg.sender);
562:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
563:             rebasingStateTo.isRebasing == 1)
564:             ? rebasingSharePrice()
565:             : 0; 
566:         if (rebasingStateFrom.isRebasing == 1) {
567:             uint256 shares = uint256(rebasingStateFrom.nShares);
568:             uint256 rebasedBalance = _shares2balance(
569:                 shares,
570:                 _rebasingSharePrice,
571:                 0,
572:                 fromBalanceBefore
573:             );
574:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
575:             if (mintAmount != 0) {
576:                 ERC20._mint(msg.sender, mintAmount);
577:                 fromBalanceBefore += mintAmount;
578:                 decreaseUnmintedRebaseRewards(mintAmount);
579:                 emit RebaseReward(msg.sender, block.timestamp, mintAmount);
580:             }
581:         }
582: 
583:         
584:         bool success = ERC20.transfer(to, amount);
585: 
586:         
587:         int256 sharesDelta;
588:         if (rebasingStateFrom.isRebasing == 1) {
589:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
590:             uint256 fromSharesAfter = _balance2shares(
591:                 fromBalanceAfter,
592:                 _rebasingSharePrice
593:             );
594:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
595:             sharesDelta -= int256(sharesSpent);
596:             rebasingState[msg.sender] = RebasingState({ // <= FOUND
597:                 isRebasing: 1,
598:                 nShares: uint248(fromSharesAfter)
599:             });
600:         }
601: 
602:         
603:         if (rebasingStateTo.isRebasing == 1) {
604:             
605:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
606:             uint256 toBalanceAfter = _shares2balance(
607:                 rebasingStateTo.nShares,
608:                 _rebasingSharePrice,
609:                 amount,
610:                 rawToBalanceAfter
611:             );
612: 
613:             
614:             uint256 toSharesAfter = _balance2shares(
615:                 toBalanceAfter,
616:                 _rebasingSharePrice
617:             );
618:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
619:             sharesDelta += int256(sharesReceived);
620:             rebasingState[to] = RebasingState({ // <= FOUND
621:                 isRebasing: 1,
622:                 nShares: uint248(toSharesAfter)
623:             });
624: 
625:             
626:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
627:             if (mintAmount != 0) {
628:                 ERC20._mint(to, mintAmount);
629:                 decreaseUnmintedRebaseRewards(mintAmount);
630:                 emit RebaseReward(to, block.timestamp, mintAmount);
631:             }
632:         }
633: 
634:         
635:         if (
636:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1
637:         ) {
638:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
639:         }
640: 
641:         return success;
642:     }
```

*GitHub* : [553](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L553-L620)

```646:     function transferFrom(
647:         address from,
648:         address to,
649:         uint256 amount
650:     ) public virtual override returns (bool) {
651:         
652:         
653:         RebasingState memory rebasingStateFrom = rebasingState[from];
654:         RebasingState memory rebasingStateTo = rebasingState[to];
655:         uint256 fromBalanceBefore = ERC20.balanceOf(from);
656:         uint256 _rebasingSharePrice = (rebasingStateFrom.isRebasing == 1 ||
657:             rebasingStateTo.isRebasing == 1)
658:             ? rebasingSharePrice()
659:             : 0;
660:         if (rebasingStateFrom.isRebasing == 1) {
661:             uint256 shares = uint256(rebasingStateFrom.nShares);
662:             uint256 rebasedBalance = _shares2balance(
663:                 shares,
664:                 _rebasingSharePrice,
665:                 0,
666:                 fromBalanceBefore
667:             );
668:             uint256 mintAmount = rebasedBalance - fromBalanceBefore;
669:             if (mintAmount != 0) {
670:                 ERC20._mint(from, mintAmount);
671:                 fromBalanceBefore += mintAmount;
672:                 decreaseUnmintedRebaseRewards(mintAmount);
673:                 emit RebaseReward(from, block.timestamp, mintAmount);
674:             }
675:         }
676: 
677:         
678:         bool success = ERC20.transferFrom(from, to, amount);
679: 
680:         
681:         int256 sharesDelta;
682:         if (rebasingStateFrom.isRebasing == 1) {
683:             uint256 fromBalanceAfter = fromBalanceBefore - amount;
684:             uint256 fromSharesAfter = _balance2shares(
685:                 fromBalanceAfter,
686:                 _rebasingSharePrice
687:             );
688:             uint256 sharesSpent = rebasingStateFrom.nShares - fromSharesAfter;
689:             sharesDelta -= int256(sharesSpent);
690:             rebasingState[from] = RebasingState({ // <= FOUND
691:                 isRebasing: 1,
692:                 nShares: uint248(fromSharesAfter)
693:             });
694:         }
695: 
696:         
697:         if (rebasingStateTo.isRebasing == 1) {
698:             
699:             uint256 rawToBalanceAfter = ERC20.balanceOf(to);
700:             uint256 toBalanceAfter = _shares2balance(
701:                 rebasingStateTo.nShares,
702:                 _rebasingSharePrice,
703:                 amount,
704:                 rawToBalanceAfter
705:             );
706: 
707:             
708:             uint256 toSharesAfter = _balance2shares(
709:                 toBalanceAfter,
710:                 _rebasingSharePrice
711:             );
712:             uint256 sharesReceived = toSharesAfter - rebasingStateTo.nShares;
713:             sharesDelta += int256(sharesReceived);
714:             rebasingState[to] = RebasingState({ // <= FOUND
715:                 isRebasing: 1,
716:                 nShares: uint248(toSharesAfter)
717:             });
718: 
719:             
720:             uint256 mintAmount = toBalanceAfter - rawToBalanceAfter;
721:             if (mintAmount != 0) {
722:                 ERC20._mint(to, mintAmount);
723:                 decreaseUnmintedRebaseRewards(mintAmount);
724:                 emit RebaseReward(to, block.timestamp, mintAmount);
725:             }
726:         }
727: 
728:         
729:         if (
730:             rebasingStateFrom.isRebasing == 1 || rebasingStateTo.isRebasing == 1
731:         ) {
732:             updateTotalRebasingShares(_rebasingSharePrice, sharesDelta);
733:         }
734: 
735:         return success;
736:     }
```

*GitHub* : [646](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20RebaseDistributor.sol#L646-L714)

```75:     function startAuction(bytes32 loanId, uint256 callDebt) external { // <= FOUND
76:         
77:         require(
78:             core().hasRole(CoreRoles.GAUGE_PNL_NOTIFIER, msg.sender),
79:             "AuctionHouse: invalid caller"
80:         );
81: 
82:         
83:         LendingTerm.Loan memory loan = LendingTerm(msg.sender).getLoan(loanId);
84:         require(
85:             loan.callTime == block.timestamp,
86:             "AuctionHouse: loan previously called"
87:         );
88: 
89:         
90:         require(
91:             auctions[loanId].startTime == 0,
92:             "AuctionHouse: auction exists"
93:         );
94: 
95:         
96:         auctions[loanId] = Auction({
97:             startTime: block.timestamp,
98:             endTime: 0,
99:             lendingTerm: msg.sender,
100:             collateralAmount: loan.collateralAmount,
101:             callDebt: callDebt
102:         });
103:         nAuctionsInProgress++;
104: 
105:         
106:         emit AuctionStart(
107:             block.timestamp,
108:             loanId,
109:             LendingTerm(msg.sender).collateralToken(),
110:             loan.collateralAmount,
111:             callDebt
112:         );
113:     }
```

*GitHub* : [75](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/AuctionHouse.sol#L75-L75)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp)
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this),
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this),
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L339)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount);
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L114)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward);
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({ // <= FOUND
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L276)
### [GAS-75]<a name="gas-75"></a> Cache address(this) when used more than once

*There are 7 instance(s) of this issue:*

```270:     function debtCeiling(
271:         int256 gaugeWeightDelta
272:     ) public view returns (uint256) {
273:         address _guildToken = refs.guildToken; 
274:         uint256 gaugeWeight = GuildToken(_guildToken).getGaugeWeight(
275:             address(this) // <= FOUND
276:         );
277:         gaugeWeight = uint256(int256(gaugeWeight) + gaugeWeightDelta);
278:         uint256 gaugeType = GuildToken(_guildToken).gaugeType(address(this)); // <= FOUND
279:         uint256 totalWeight = GuildToken(_guildToken).totalTypeWeight(
280:             gaugeType
281:         );
282:         uint256 creditMinterBuffer = RateLimitedMinter(refs.creditMinter)
283:             .buffer();
284:         uint256 _hardCap = params.hardCap; 
285:         if (gaugeWeight == 0) {
286:             return 0; 
287:         } else if (gaugeWeight == totalWeight) {
288:             
289:             
290:             return
291:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
292:         }
293:         uint256 _issuance = issuance; 
294:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
295:             .totalBorrowedCredit();
296:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
297:             .gaugeWeightTolerance();
298:         if (totalBorrowedCredit == 0 && gaugeWeight != 0) {
299:             
300:             
301:             
302:             return
303:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
304:         }
305:         uint256 toleratedGaugeWeight = (gaugeWeight * gaugeWeightTolerance) /
306:             1e18;
307:         uint256 debtCeilingBefore = (totalBorrowedCredit *
308:             toleratedGaugeWeight) / totalWeight;
309:         if (_issuance >= debtCeilingBefore) {
310:             return debtCeilingBefore; 
311:         }
312:         uint256 remainingDebtCeiling = debtCeilingBefore - _issuance; 
313:         if (toleratedGaugeWeight >= totalWeight) {
314:             
315:             
316:             return
317:                 _hardCap < creditMinterBuffer ? _hardCap : creditMinterBuffer;
318:         }
319:         uint256 otherGaugesWeight = totalWeight - toleratedGaugeWeight; 
320:         uint256 maxBorrow = (remainingDebtCeiling * totalWeight) /
321:             otherGaugesWeight;
322:         uint256 _debtCeiling = _issuance + maxBorrow;
323:         
324:         if (creditMinterBuffer < _debtCeiling) {
325:             return creditMinterBuffer;
326:         }
327:         if (_hardCap < _debtCeiling) {
```

*GitHub* : [270](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L270-L278)

```339:     function _borrow(
340:         address borrower,
341:         uint256 borrowAmount,
342:         uint256 collateralAmount
343:     ) internal returns (bytes32 loanId) {
344:         require(borrowAmount != 0, "LendingTerm: cannot borrow 0");
345:         require(collateralAmount != 0, "LendingTerm: cannot stake 0");
346: 
347:         loanId = keccak256(
348:             abi.encode(borrower, address(this), block.timestamp) // <= FOUND
349:         );
350: 
351:         
352:         require(loans[loanId].borrowTime == 0, "LendingTerm: loan exists");
353: 
354:         
355:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
356:             .creditMultiplier();
357:         uint256 maxBorrow = (collateralAmount *
358:             params.maxDebtPerCollateralToken) / creditMultiplier;
359:         require(
360:             borrowAmount <= maxBorrow,
361:             "LendingTerm: not enough collateral"
362:         );
363: 
364:         
365:         require(
366:             borrowAmount >= ProfitManager(refs.profitManager).minBorrow(),
367:             "LendingTerm: borrow amount too low"
368:         );
369: 
370:         
371:         uint256 _issuance = issuance;
372:         uint256 _postBorrowIssuance = _issuance + borrowAmount;
373:         require(
374:             _postBorrowIssuance <= params.hardCap,
375:             "LendingTerm: hardcap reached"
376:         );
377: 
378:         
379:         uint256 totalBorrowedCredit = ProfitManager(refs.profitManager)
380:             .totalBorrowedCredit();
381:         uint256 gaugeWeightTolerance = ProfitManager(refs.profitManager)
382:             .gaugeWeightTolerance();
383:         uint256 _debtCeiling = (GuildToken(refs.guildToken)
384:             .calculateGaugeAllocation(
385:                 address(this), // <= FOUND
386:                 totalBorrowedCredit + borrowAmount
387:             ) * gaugeWeightTolerance) / 1e18;
388:         if (totalBorrowedCredit == 0) {
389:             
390:             
391:             
392:             require(_debtCeiling != 0, "LendingTerm: debt ceiling reached");
393:         } else {
394:             require(
395:                 _postBorrowIssuance <= _debtCeiling,
396:                 "LendingTerm: debt ceiling reached"
397:             );
398:         }
399: 
400:         
401:         loans[loanId] = Loan({
402:             borrower: borrower,
403:             borrowTime: block.timestamp,
404:             borrowAmount: borrowAmount,
405:             borrowCreditMultiplier: creditMultiplier,
406:             collateralAmount: collateralAmount,
407:             caller: address(0),
408:             callTime: 0,
409:             callDebt: 0,
410:             closeTime: 0
411:         });
412:         issuance = _postBorrowIssuance;
413:         if (params.maxDelayBetweenPartialRepay != 0) {
414:             lastPartialRepay[loanId] = block.timestamp;
415:         }
416: 
417:         
418:         RateLimitedMinter(refs.creditMinter).mint(borrower, borrowAmount);
419: 
420:         
421:         IERC20(params.collateralToken).safeTransferFrom(
422:             borrower,
423:             address(this), // <= FOUND
424:             collateralAmount
425:         );
426: 
427:         
428:         emit LoanOpen(
429:             block.timestamp,
430:             loanId,
431:             borrower,
432:             collateralAmount,
433:             borrowAmount
434:         );
435:     }
```

*GitHub* : [339](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L339-L423)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this), // <= FOUND
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this), // <= FOUND
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L551)

```567:     function _repay(address repayer, bytes32 loanId) internal {
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this), // <= FOUND
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this), // <= FOUND
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
617:         
618:         IERC20(params.collateralToken).safeTransfer(
619:             loan.borrower,
620:             loan.collateralAmount
621:         );
622: 
623:         
624:         emit LoanClose(block.timestamp, loanId, LoanCloseType.Repay, loanDebt);
625:     }
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L604)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this), // <= FOUND
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl); // <= FOUND
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L797)

```114:     function stake(address term, uint256 amount) external whenNotPaused {
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount); // <= FOUND
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this), // <= FOUND
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L144)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this));  // <= FOUND
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term); // <= FOUND
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward);
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L241)### MEDIUM Risk Issues


### [MEDIUM-01]<a name="medium-01"></a> Privileged functions can create points of failure
Ensure such accounts are protected and consider implementing multi sig to prevent a single point of failure

*There are 1 instance(s) of this issue:*

```50:     function createRole(
51:         bytes32 role,
52:         bytes32 adminRole
53:     ) external onlyRole(CoreRoles.GOVERNOR)  // <= FOUND
```

*GitHub* : [53](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/core/Core.sol#L53-L53)
### [MEDIUM-02]<a name="medium-02"></a> Using block.number for time comparisons
Using block.number in time comparisons can break compatibility with some L2s such as Optimism whos time between blocks differ from Ethereum and isn't constant. Consider using block.timestamp to prevent compatibility issues

*There are 4 instance(s) of this issue:*

```89:     function proposeOffboard(address term) external whenNotPaused { // <= FOUND
90:         require(
91:             polls[block.number][term] == 0,
92:             "LendingTermOffboarding: poll exists"
93:         );
94:         require(
95:             block.number > lastPollBlock[term] + POLL_DURATION_BLOCKS,
96:             "LendingTermOffboarding: poll active"
97:         );
98:         
99:         require(
100:             GuildToken(guildToken).isGauge(term),
101:             "LendingTermOffboarding: not an active term"
102:         );
103: 
104:         polls[block.number][term] = 1; 
105:         lastPollBlock[term] = block.number;
106:         emit OffboardSupport(
107:             block.timestamp,
108:             term,
109:             block.number,
110:             address(0),
111:             1
112:         );
113:     }
```

*GitHub* : [89](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L89-L89)

```116:     function supportOffboard(
117:         uint256 snapshotBlock,
118:         address term
119:     ) external whenNotPaused {
120:         require(
121:             block.number <= snapshotBlock + POLL_DURATION_BLOCKS,
122:             "LendingTermOffboarding: poll expired"
123:         );
124:         uint256 _weight = polls[snapshotBlock][term];
125:         require(_weight != 0, "LendingTermOffboarding: poll not found");
126:         uint256 userWeight = GuildToken(guildToken).getPastVotes(
127:             msg.sender,
128:             snapshotBlock
129:         );
130:         require(userWeight != 0, "LendingTermOffboarding: zero weight");
131:         require(
132:             userPollVotes[msg.sender][snapshotBlock][term] == 0,
133:             "LendingTermOffboarding: already voted"
134:         );
135: 
136:         userPollVotes[msg.sender][snapshotBlock][term] = userWeight;
137:         polls[snapshotBlock][term] = _weight + userWeight;
138:         if (_weight + userWeight >= quorum) {
139:             canOffboard[term] = true;
140:         }
141:         emit OffboardSupport(
142:             block.timestamp,
143:             term,
144:             snapshotBlock,
145:             msg.sender,
146:             userWeight
147:         );
148:     }
```

*GitHub* : [116](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/LendingTermOffboarding.sol#L116-L116)

```91:     function getPastVotes(
92:         address account,
93:         uint256 blockNumber
94:     ) public view virtual returns (uint256) {
95:         require(
96:             blockNumber < block.number,
97:             "ERC20MultiVotes: not a past block"
98:         );
99:         return _checkpointsLookup(_checkpoints[account], blockNumber);
100:     }
```

*GitHub* : [91](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L91-L91)

```363:     function _writeCheckpoint(
364:         address delegatee,
365:         function(uint256, uint256) view returns (uint256) op,
366:         uint256 delta
367:     ) private {
368:         Checkpoint[] storage ckpts = _checkpoints[delegatee];
369: 
370:         uint256 pos = ckpts.length;
371:         uint256 oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;
372:         uint256 newWeight = op(oldWeight, delta);
373: 
374:         if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {
375:             ckpts[pos - 1].votes = newWeight.safeCastTo224();
376:         } else {
377:             ckpts.push(
378:                 Checkpoint({
379:                     fromBlock: block.number.safeCastTo32(),
380:                     votes: newWeight.safeCastTo224()
381:                 })
382:             );
383:         }
384:         emit DelegateVotesChanged(delegatee, oldWeight, newWeight);
385:     }
```

*GitHub* : [363](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/tokens/ERC20MultiVotes.sol#L363-L363)
### [MEDIUM-03]<a name="medium-03"></a> increase/decrease allowance should be used instead of approve/safeApprove
Using `approve()` in ERC20 tokens has a known race condition when resetting allowances, making it susceptible to double spending. Instead, the `increaseAllowance()` and `decreaseAllowance()` functions are introduced to safely adjust allowances without the need to first reset them to zero. They atomically change the allowance, avoiding potential vulnerabilities. Developers should transition from the deprecated `approve()` method to these newer functions to enhance security. By using `increaseAllowance()` or `decreaseAllowance()`, you can ensure that allowances are adjusted in a safer manner, mitigating possible attack vectors associated with the traditional `approve()` function.

*There are 1 instance(s) of this issue:*

```129:         CreditToken(credit).approve(address(profitManager), amount); // <= FOUND
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L129-L129)
### [MEDIUM-04]<a name="medium-04"></a> Return values not checked for approve()
The ERC-20 token standard does not dictate that the approve function must return a value. The function signature in the ERC-20 standard is function approve(address spender, uint tokens) public returns (bool success);. However, a well-implemented ERC-20 token contract will typically have approve return a boolean value indicating whether or not the operation was successful.

It's crucial to note that not all token contracts follow this practice. Some might not return a value, or they might return a value in a non-standard way. This inconsistency among token contracts is one reason why it's important to handle token interactions carefully in your smart contracts and to check the return value of approve when possible.

*There are 1 instance(s) of this issue:*

```129:         CreditToken(credit).approve(address(profitManager), amount); // <= FOUND
```

*GitHub* : [129](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L129-L129)
### [MEDIUM-05]<a name="medium-05"></a> Large transfers may not work with some ERC20 tokens
Large transfers with some ERC20 tokens may not work due to various reasons. Some tokens may have transfer restrictions built into the contract, such as daily transfer limits or maximum transfer sizes per transaction, to comply with regulatory requirements or to mitigate risks. Others may face issues with rounding errors when dealing with large quantities, especially if they have a high number of decimal places. Resolution involves carefully reading the token's contract to understand its constraints and behaviors and performing transfers accordingly. It may also be necessary to split large transfers into smaller increments if the token enforces specific transfer limits.

*There are 15 instance(s) of this issue:*

```251:     function donateToSurplusBuffer(uint256 amount) external { // <= FOUND
252:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
253:         uint256 newSurplusBuffer = surplusBuffer + amount;
254:         surplusBuffer = newSurplusBuffer;
255:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
256:     }
```

*GitHub* : [251](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L251-L252)

```259:     function donateToTermSurplusBuffer(address term, uint256 amount) external { // <= FOUND
260:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
261:         uint256 newSurplusBuffer = termSurplusBuffer[term] + amount;
262:         termSurplusBuffer[term] = newSurplusBuffer;
263:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
264:     }
```

*GitHub* : [259](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L259-L260)

```267:     function withdrawFromSurplusBuffer(
268:         address to,
269:         uint256 amount
270:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
271:         uint256 newSurplusBuffer = surplusBuffer - amount; 
272:         surplusBuffer = newSurplusBuffer;
273:         CreditToken(credit).transfer(to, amount); // <= FOUND
274:         emit SurplusBufferUpdate(block.timestamp, newSurplusBuffer);
275:     }
```

*GitHub* : [267](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L267-L273)

```278:     function withdrawFromTermSurplusBuffer(
279:         address term,
280:         address to,
281:         uint256 amount
282:     ) external onlyCoreRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW) {
283:         uint256 newSurplusBuffer = termSurplusBuffer[term] - amount; 
284:         termSurplusBuffer[term] = newSurplusBuffer;
285:         CreditToken(credit).transfer(to, amount); // <= FOUND
286:         emit TermSurplusBufferUpdate(block.timestamp, term, newSurplusBuffer);
287:     }
```

*GitHub* : [278](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L278-L285)

```292:     function notifyPnL(
293:         address gauge,
294:         int256 amount
295:     ) external onlyCoreRole(CoreRoles.GAUGE_PNL_NOTIFIER) {
296:         uint256 _surplusBuffer = surplusBuffer;
297:         uint256 _termSurplusBuffer = termSurplusBuffer[gauge];
298:         address _credit = credit;
299: 
300:         
301:         if (amount < 0) {
302:             uint256 loss = uint256(-amount);
303: 
304:             
305:             GuildToken(guild).notifyGaugeLoss(gauge);
306: 
307:             
308:             
309:             if (_termSurplusBuffer != 0) {
310:                 termSurplusBuffer[gauge] = 0;
311:                 emit TermSurplusBufferUpdate(block.timestamp, gauge, 0);
312:                 _surplusBuffer += _termSurplusBuffer;
313:             }
314: 
315:             if (loss < _surplusBuffer) {
316:                 
317:                 surplusBuffer = _surplusBuffer - loss;
318:                 emit SurplusBufferUpdate(
319:                     block.timestamp,
320:                     _surplusBuffer - loss
321:                 );
322:                 CreditToken(_credit).burn(loss);
323:             } else {
324:                 
325:                 loss -= _surplusBuffer;
326:                 surplusBuffer = 0;
327:                 CreditToken(_credit).burn(_surplusBuffer);
328:                 emit SurplusBufferUpdate(block.timestamp, 0);
329: 
330:                 
331:                 uint256 creditTotalSupply = CreditToken(_credit).totalSupply();
332:                 uint256 newCreditMultiplier = (creditMultiplier *
333:                     (creditTotalSupply - loss)) / creditTotalSupply;
334:                 creditMultiplier = newCreditMultiplier;
335:                 emit CreditMultiplierUpdate(
336:                     block.timestamp,
337:                     newCreditMultiplier
338:                 );
339:             }
340:         }
341:         
342:         else if (amount > 0) {
343:             ProfitSharingConfig
344:                 memory _profitSharingConfig = profitSharingConfig;
345: 
346:             uint256 amountForSurplusBuffer = (uint256(amount) *
347:                 uint256(_profitSharingConfig.surplusBufferSplit)) / 1e9;
348: 
349:             uint256 amountForGuild = (uint256(amount) *
350:                 uint256(_profitSharingConfig.guildSplit)) / 1e9;
351: 
352:             uint256 amountForOther = (uint256(amount) *
353:                 uint256(_profitSharingConfig.otherSplit)) / 1e9;
354: 
355:             uint256 amountForCredit = uint256(amount) -
356:                 amountForSurplusBuffer -
357:                 amountForGuild -
358:                 amountForOther;
359: 
360:             
361:             if (amountForSurplusBuffer != 0) {
362:                 surplusBuffer = _surplusBuffer + amountForSurplusBuffer;
363:                 emit SurplusBufferUpdate(
364:                     block.timestamp,
365:                     _surplusBuffer + amountForSurplusBuffer
366:                 );
367:             }
368: 
369:             
370:             if (amountForOther != 0) {
371:                 CreditToken(_credit).transfer(
372:                     _profitSharingConfig.otherRecipient,
373:                     amountForOther
374:                 );
375:             }
376: 
377:             
378:             if (amountForCredit != 0) {
379:                 CreditToken(_credit).distribute(amountForCredit);
380:             }
381: 
382:             
383:             if (amountForGuild != 0) {
384:                 
385:                 
386:                 
387:                 
388:                 uint256 _gaugeWeight = uint256(
389:                     GuildToken(guild).getGaugeWeight(gauge)
390:                 );
391:                 if (_gaugeWeight != 0) {
392:                     uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
393:                     if (_gaugeProfitIndex == 0) {
394:                         _gaugeProfitIndex = 1e18;
395:                     }
396:                     gaugeProfitIndex[gauge] =
397:                         _gaugeProfitIndex +
398:                         (amountForGuild * 1e18) /
399:                         _gaugeWeight;
400:                 }
401:             }
402:         }
403: 
404:         emit GaugePnL(gauge, block.timestamp, amount);
405:     }
```

*GitHub* : [292](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L292-L292)

```409:     function claimGaugeRewards(
410:         address user,
411:         address gauge
412:     ) public returns (uint256 creditEarned) {
413:         uint256 _userGaugeWeight = uint256(
414:             GuildToken(guild).getUserGaugeWeight(user, gauge)
415:         );
416:         if (_userGaugeWeight == 0) {
417:             return 0;
418:         }
419:         uint256 _gaugeProfitIndex = gaugeProfitIndex[gauge];
420:         uint256 _userGaugeProfitIndex = userGaugeProfitIndex[user][gauge];
421:         if (_gaugeProfitIndex == 0) {
422:             _gaugeProfitIndex = 1e18;
423:         }
424:         if (_userGaugeProfitIndex == 0) {
425:             _userGaugeProfitIndex = 1e18;
426:         }
427:         uint256 deltaIndex = _gaugeProfitIndex - _userGaugeProfitIndex;
428:         if (deltaIndex != 0) {
429:             creditEarned = (_userGaugeWeight * deltaIndex) / 1e18;
430:             userGaugeProfitIndex[user][gauge] = _gaugeProfitIndex;
431:         }
432:         if (creditEarned != 0) {
433:             emit ClaimRewards(block.timestamp, user, gauge, creditEarned);
434:             CreditToken(credit).transfer(user, creditEarned); // <= FOUND
435:         }
436:     }
```

*GitHub* : [409](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/governance/ProfitManager.sol#L409-L434)

```448:     function _addCollateral(
449:         address borrower,
450:         bytes32 loanId,
451:         uint256 collateralToAdd
452:     ) internal {
453:         require(collateralToAdd != 0, "LendingTerm: cannot add 0");
454: 
455:         Loan storage loan = loans[loanId];
456: 
457:         
458:         require(loan.borrowTime != 0, "LendingTerm: loan not found");
459:         require(loan.closeTime == 0, "LendingTerm: loan closed");
460:         require(loan.callTime == 0, "LendingTerm: loan called");
461: 
462:         
463:         loans[loanId].collateralAmount += collateralToAdd;
464: 
465:         
466:         IERC20(params.collateralToken).safeTransferFrom(
467:             borrower,
468:             address(this),
469:             collateralToAdd
470:         );
471: 
472:         
473:         emit LoanAddCollateral(
474:             block.timestamp,
475:             loanId,
476:             borrower,
477:             collateralToAdd
478:         );
479:     }
```

*GitHub* : [448](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L448-L448)

```490:     function _partialRepay(
491:         address repayer,
492:         bytes32 loanId,
493:         uint256 debtToRepay
494:     ) internal {
495:         Loan storage loan = loans[loanId];
496: 
497:         
498:         uint256 borrowTime = loan.borrowTime;
499:         require(borrowTime != 0, "LendingTerm: loan not found");
500:         require(
501:             borrowTime < block.timestamp,
502:             "LendingTerm: loan opened in same block"
503:         );
504:         require(loan.closeTime == 0, "LendingTerm: loan closed");
505:         require(loan.callTime == 0, "LendingTerm: loan called");
506: 
507:         
508:         uint256 loanDebt = getLoanDebt(loanId);
509:         require(debtToRepay < loanDebt, "LendingTerm: full repayment");
510:         uint256 percentRepaid = (debtToRepay * 1e18) / loanDebt; 
511:         uint256 borrowAmount = loan.borrowAmount;
512:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
513:             .creditMultiplier();
514:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
515:             creditMultiplier;
516:         uint256 principalRepaid = (principal * percentRepaid) / 1e18;
517:         uint256 interestRepaid = debtToRepay - principalRepaid;
518:         uint256 issuanceDecrease = (borrowAmount * percentRepaid) / 1e18;
519:         require(
520:             principalRepaid != 0 && interestRepaid != 0,
521:             "LendingTerm: repay too small"
522:         );
523:         require(
524:             debtToRepay >= (loanDebt * params.minPartialRepayPercent) / 1e18,
525:             "LendingTerm: repay below min"
526:         );
527:         require(
528:             borrowAmount - issuanceDecrease >
529:                 ProfitManager(refs.profitManager).minBorrow(),
530:             "LendingTerm: below min borrow"
531:         );
532: 
533:         
534:         loans[loanId].borrowAmount -= issuanceDecrease;
535:         lastPartialRepay[loanId] = block.timestamp;
536:         issuance -= issuanceDecrease;
537: 
538:         
539:         CreditToken(refs.creditToken).transferFrom(
540:             repayer,
541:             address(this),
542:             debtToRepay
543:         );
544: 
545:         
546:         CreditToken(refs.creditToken).transfer(
547:             refs.profitManager,
548:             interestRepaid
549:         );
550:         ProfitManager(refs.profitManager).notifyPnL(
551:             address(this),
552:             int256(interestRepaid)
553:         );
554:         CreditToken(refs.creditToken).burn(principalRepaid);
555:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principalRepaid);
556: 
557:         
558:         emit LoanPartialRepay(block.timestamp, loanId, repayer, debtToRepay);
559:     }
```

*GitHub* : [490](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L490-L490)

```567:     function _repay(address repayer, bytes32 loanId) internal { // <= FOUND
568:         Loan storage loan = loans[loanId];
569: 
570:         
571:         uint256 borrowTime = loan.borrowTime;
572:         require(borrowTime != 0, "LendingTerm: loan not found");
573:         require(
574:             borrowTime < block.timestamp,
575:             "LendingTerm: loan opened in same block"
576:         );
577:         require(loan.closeTime == 0, "LendingTerm: loan closed");
578:         require(loan.callTime == 0, "LendingTerm: loan called");
579: 
580:         
581:         uint256 loanDebt = getLoanDebt(loanId);
582:         uint256 borrowAmount = loan.borrowAmount;
583:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
584:             .creditMultiplier();
585:         uint256 principal = (borrowAmount * loan.borrowCreditMultiplier) /
586:             creditMultiplier;
587:         uint256 interest = loanDebt - principal;
588: 
589:         
590:         CreditToken(refs.creditToken).transferFrom(
591:             repayer,
592:             address(this),
593:             loanDebt
594:         );
595:         if (interest != 0) {
596:             
597:             CreditToken(refs.creditToken).transfer(
598:                 refs.profitManager,
599:                 interest
600:             );
601: 
602:             
603:             ProfitManager(refs.profitManager).notifyPnL(
604:                 address(this),
605:                 int256(interest)
606:             );
607:         }
608: 
609:         
610:         CreditToken(refs.creditToken).burn(principal);
611:         RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
612: 
613:         
614:         loan.closeTime = block.timestamp;
615:         issuance -= borrowAmount;
616: 
```

*GitHub* : [567](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L567-L567)

```725:     function onBid(
726:         bytes32 loanId,
727:         address bidder,
728:         uint256 collateralToBorrower,
729:         uint256 collateralToBidder,
730:         uint256 creditFromBidder
731:     ) external {
732:         
733:         require(msg.sender == refs.auctionHouse, "LendingTerm: invalid caller");
734:         require(
735:             loans[loanId].callTime != 0 && loans[loanId].callDebt != 0,
736:             "LendingTerm: loan not called"
737:         );
738:         require(loans[loanId].closeTime == 0, "LendingTerm: loan closed");
739: 
740:         
741:         
742:         
743:         uint256 collateralOut = collateralToBorrower + collateralToBidder;
744:         require(
745:             collateralOut == loans[loanId].collateralAmount ||
746:                 collateralOut == 0,
747:             "LendingTerm: invalid collateral movements"
748:         );
749: 
750:         
751:         uint256 creditMultiplier = ProfitManager(refs.profitManager)
752:             .creditMultiplier();
753:         uint256 borrowAmount = loans[loanId].borrowAmount;
754:         uint256 principal = (borrowAmount *
755:             loans[loanId].borrowCreditMultiplier) / creditMultiplier;
756:         int256 pnl;
757:         uint256 interest;
758:         if (creditFromBidder >= principal) {
759:             interest = creditFromBidder - principal;
760:             pnl = int256(interest);
761:         } else {
762:             pnl = int256(creditFromBidder) - int256(principal);
763:             principal = creditFromBidder;
764:             require(
765:                 collateralToBorrower == 0,
766:                 "LendingTerm: invalid collateral movement"
767:             );
768:         }
769: 
770:         
771:         loans[loanId].closeTime = block.timestamp;
772: 
773:         
774:         if (creditFromBidder != 0) {
775:             CreditToken(refs.creditToken).transferFrom(
776:                 bidder,
777:                 address(this),
778:                 creditFromBidder
779:             );
780:         }
781: 
782:         
783:         if (principal != 0) {
784:             CreditToken(refs.creditToken).burn(principal);
785:             RateLimitedMinter(refs.creditMinter).replenishBuffer(principal);
786:         }
787: 
788:         
789:         if (pnl != 0) {
790:             
791:             if (interest != 0) {
792:                 CreditToken(refs.creditToken).transfer(
793:                     refs.profitManager,
794:                     interest
795:                 );
796:             }
797:             ProfitManager(refs.profitManager).notifyPnL(address(this), pnl);
798:         }
799: 
800:         
801:         issuance -= borrowAmount;
802: 
803:         
804:         if (collateralToBorrower != 0) {
805:             IERC20(params.collateralToken).safeTransfer(
806:                 loans[loanId].borrower,
807:                 collateralToBorrower
808:             );
809:         }
810: 
811:         
812:         if (collateralToBidder != 0) {
813:             IERC20(params.collateralToken).safeTransfer(
814:                 bidder,
815:                 collateralToBidder
816:             );
817:         }
818: 
819:         emit LoanClose(
820:             block.timestamp,
821:             loanId,
822:             LoanCloseType.Call,
823:             creditFromBidder
824:         );
825:     }
```

*GitHub* : [725](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/LendingTerm.sol#L725-L725)

```103:     function mint(
104:         address to,
105:         uint256 amountIn
106:     ) external whenNotPaused returns (uint256 amountOut) {
107:         amountOut = getMintAmountOut(amountIn);
108:         pegTokenBalance += amountIn;
109:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
110:         CreditToken(credit).mint(to, amountOut);
111:         emit Mint(block.timestamp, to, amountIn, amountOut);
112:     }
```

*GitHub* : [103](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L103-L109)

```117:     function mintAndEnterRebase(
118:         uint256 amountIn
119:     ) external whenNotPaused returns (uint256 amountOut) {
120:         require(
121:             !CreditToken(credit).isRebasing(msg.sender),
122:             "SimplePSM: already rebasing"
123:         );
124:         amountOut = getMintAmountOut(amountIn);
125:         pegTokenBalance += amountIn;
126:         ERC20(pegToken).safeTransferFrom(msg.sender, address(this), amountIn); // <= FOUND
127:         CreditToken(credit).mint(msg.sender, amountOut);
128:         CreditToken(credit).forceEnterRebase(msg.sender);
129:         emit Mint(block.timestamp, msg.sender, amountIn, amountOut);
130:     }
```

*GitHub* : [117](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L117-L126)

```134:     function redeem(
135:         address to,
136:         uint256 amountIn
137:     ) external returns (uint256 amountOut) {
138:         require(!redemptionsPaused, "SimplePSM: redemptions paused");
139:         amountOut = getRedeemAmountOut(amountIn);
140:         CreditToken(credit).burnFrom(msg.sender, amountIn);
141:         pegTokenBalance -= amountOut;
142:         ERC20(pegToken).safeTransfer(to, amountOut); // <= FOUND
143:         emit Redeem(block.timestamp, to, amountIn, amountOut);
144:     }
```

*GitHub* : [134](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SimplePSM.sol#L134-L142)

```114:     function stake(address term, uint256 amount) external whenNotPaused { // <= FOUND
115:         
116:         (uint256 lastGaugeLoss, UserStake memory userStake, ) = getRewards(
117:             msg.sender,
118:             term
119:         );
120: 
121:         require(
122:             lastGaugeLoss != block.timestamp,
123:             "SurplusGuildMinter: loss in block"
124:         );
125:         require(amount >= MIN_STAKE, "SurplusGuildMinter: min stake");
126: 
127:         
128:         CreditToken(credit).transferFrom(msg.sender, address(this), amount); // <= FOUND
129:         CreditToken(credit).approve(address(profitManager), amount);
130:         ProfitManager(profitManager).donateToTermSurplusBuffer(term, amount);
131: 
132:         
133:         uint256 _mintRatio = mintRatio;
134:         uint256 guildAmount = (_mintRatio * amount) / 1e18;
135:         RateLimitedMinter(rlgm).mint(address(this), guildAmount);
136:         GuildToken(guild).incrementGauge(term, guildAmount);
137: 
138:         
139:         userStake = UserStake({
140:             stakeTime: SafeCastLib.safeCastTo48(block.timestamp),
141:             lastGaugeLoss: SafeCastLib.safeCastTo48(lastGaugeLoss),
142:             profitIndex: SafeCastLib.safeCastTo160(
143:                 ProfitManager(profitManager).userGaugeProfitIndex(
144:                     address(this),
145:                     term
146:                 )
147:             ),
148:             credit: userStake.credit + SafeCastLib.safeCastTo128(amount),
149:             guild: userStake.guild + SafeCastLib.safeCastTo128(guildAmount)
150:         });
151:         _stakes[msg.sender][term] = userStake;
152: 
153:         
154:         emit Stake(block.timestamp, term, amount);
155:     }
```

*GitHub* : [114](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L114-L128)

```216:     function getRewards(
217:         address user,
218:         address term
219:     )
220:         public
221:         returns (
222:             uint256 lastGaugeLoss, 
223:             UserStake memory userStake, 
224:             bool slashed 
225:         )
226:     {
227:         bool updateState;
228:         lastGaugeLoss = GuildToken(guild).lastGaugeLoss(term);
229:         if (lastGaugeLoss > uint256(userStake.lastGaugeLoss)) {
230:             slashed = true;
231:         }
232: 
233:         
234:         userStake = _stakes[user][term];
235:         if (userStake.stakeTime == 0)
236:             return (lastGaugeLoss, userStake, slashed);
237: 
238:         
239:         ProfitManager(profitManager).claimRewards(address(this)); 
240:         uint256 _profitIndex = ProfitManager(profitManager)
241:             .userGaugeProfitIndex(address(this), term);
242:         uint256 _userProfitIndex = uint256(userStake.profitIndex);
243: 
244:         if (_profitIndex == 0) _profitIndex = 1e18;
245:         if (_userProfitIndex == 0) _userProfitIndex = 1e18;
246: 
247:         uint256 deltaIndex = _profitIndex - _userProfitIndex;
248: 
249:         if (deltaIndex != 0) {
250:             uint256 creditReward = (uint256(userStake.guild) * deltaIndex) /
251:                 1e18;
252:             uint256 guildReward = (creditReward * rewardRatio) / 1e18;
253:             if (slashed) {
254:                 guildReward = 0;
255:             }
256: 
257:             
258:             if (guildReward != 0) {
259:                 RateLimitedMinter(rlgm).mint(user, guildReward);
260:                 emit GuildReward(block.timestamp, user, guildReward);
261:             }
262:             if (creditReward != 0) {
263:                 CreditToken(credit).transfer(user, creditReward); // <= FOUND
264:             }
265: 
266:             
267:             userStake.profitIndex = SafeCastLib.safeCastTo160(_profitIndex);
268:             updateState = true;
269:         }
270: 
271:         
272:         
273:         
274:         if (slashed) {
275:             emit Unstake(block.timestamp, term, uint256(userStake.credit));
276:             userStake = UserStake({
277:                 stakeTime: uint48(0),
278:                 lastGaugeLoss: uint48(0),
279:                 profitIndex: uint160(0),
280:                 credit: uint128(0),
281:                 guild: uint128(0)
282:             });
283:             updateState = true;
284:         }
285: 
286:         
287:         if (updateState) {
288:             _stakes[user][term] = userStake;
289:         }
290:     }
```

*GitHub* : [216](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/main/src/loan/SurplusGuildMinter.sol#L216-L263) V4 wen?
